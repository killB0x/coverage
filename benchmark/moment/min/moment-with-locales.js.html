
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for benchmark/moment/min/moment-with-locales.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../prettify.css" />
    <link rel="stylesheet" href="../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../index.html">All files</a> / <a href="index.html">benchmark/moment/min</a> moment-with-locales.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/4292</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/3940</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/772</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/474</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a>
<a name='L145'></a><a href='#L145'>145</a>
<a name='L146'></a><a href='#L146'>146</a>
<a name='L147'></a><a href='#L147'>147</a>
<a name='L148'></a><a href='#L148'>148</a>
<a name='L149'></a><a href='#L149'>149</a>
<a name='L150'></a><a href='#L150'>150</a>
<a name='L151'></a><a href='#L151'>151</a>
<a name='L152'></a><a href='#L152'>152</a>
<a name='L153'></a><a href='#L153'>153</a>
<a name='L154'></a><a href='#L154'>154</a>
<a name='L155'></a><a href='#L155'>155</a>
<a name='L156'></a><a href='#L156'>156</a>
<a name='L157'></a><a href='#L157'>157</a>
<a name='L158'></a><a href='#L158'>158</a>
<a name='L159'></a><a href='#L159'>159</a>
<a name='L160'></a><a href='#L160'>160</a>
<a name='L161'></a><a href='#L161'>161</a>
<a name='L162'></a><a href='#L162'>162</a>
<a name='L163'></a><a href='#L163'>163</a>
<a name='L164'></a><a href='#L164'>164</a>
<a name='L165'></a><a href='#L165'>165</a>
<a name='L166'></a><a href='#L166'>166</a>
<a name='L167'></a><a href='#L167'>167</a>
<a name='L168'></a><a href='#L168'>168</a>
<a name='L169'></a><a href='#L169'>169</a>
<a name='L170'></a><a href='#L170'>170</a>
<a name='L171'></a><a href='#L171'>171</a>
<a name='L172'></a><a href='#L172'>172</a>
<a name='L173'></a><a href='#L173'>173</a>
<a name='L174'></a><a href='#L174'>174</a>
<a name='L175'></a><a href='#L175'>175</a>
<a name='L176'></a><a href='#L176'>176</a>
<a name='L177'></a><a href='#L177'>177</a>
<a name='L178'></a><a href='#L178'>178</a>
<a name='L179'></a><a href='#L179'>179</a>
<a name='L180'></a><a href='#L180'>180</a>
<a name='L181'></a><a href='#L181'>181</a>
<a name='L182'></a><a href='#L182'>182</a>
<a name='L183'></a><a href='#L183'>183</a>
<a name='L184'></a><a href='#L184'>184</a>
<a name='L185'></a><a href='#L185'>185</a>
<a name='L186'></a><a href='#L186'>186</a>
<a name='L187'></a><a href='#L187'>187</a>
<a name='L188'></a><a href='#L188'>188</a>
<a name='L189'></a><a href='#L189'>189</a>
<a name='L190'></a><a href='#L190'>190</a>
<a name='L191'></a><a href='#L191'>191</a>
<a name='L192'></a><a href='#L192'>192</a>
<a name='L193'></a><a href='#L193'>193</a>
<a name='L194'></a><a href='#L194'>194</a>
<a name='L195'></a><a href='#L195'>195</a>
<a name='L196'></a><a href='#L196'>196</a>
<a name='L197'></a><a href='#L197'>197</a>
<a name='L198'></a><a href='#L198'>198</a>
<a name='L199'></a><a href='#L199'>199</a>
<a name='L200'></a><a href='#L200'>200</a>
<a name='L201'></a><a href='#L201'>201</a>
<a name='L202'></a><a href='#L202'>202</a>
<a name='L203'></a><a href='#L203'>203</a>
<a name='L204'></a><a href='#L204'>204</a>
<a name='L205'></a><a href='#L205'>205</a>
<a name='L206'></a><a href='#L206'>206</a>
<a name='L207'></a><a href='#L207'>207</a>
<a name='L208'></a><a href='#L208'>208</a>
<a name='L209'></a><a href='#L209'>209</a>
<a name='L210'></a><a href='#L210'>210</a>
<a name='L211'></a><a href='#L211'>211</a>
<a name='L212'></a><a href='#L212'>212</a>
<a name='L213'></a><a href='#L213'>213</a>
<a name='L214'></a><a href='#L214'>214</a>
<a name='L215'></a><a href='#L215'>215</a>
<a name='L216'></a><a href='#L216'>216</a>
<a name='L217'></a><a href='#L217'>217</a>
<a name='L218'></a><a href='#L218'>218</a>
<a name='L219'></a><a href='#L219'>219</a>
<a name='L220'></a><a href='#L220'>220</a>
<a name='L221'></a><a href='#L221'>221</a>
<a name='L222'></a><a href='#L222'>222</a>
<a name='L223'></a><a href='#L223'>223</a>
<a name='L224'></a><a href='#L224'>224</a>
<a name='L225'></a><a href='#L225'>225</a>
<a name='L226'></a><a href='#L226'>226</a>
<a name='L227'></a><a href='#L227'>227</a>
<a name='L228'></a><a href='#L228'>228</a>
<a name='L229'></a><a href='#L229'>229</a>
<a name='L230'></a><a href='#L230'>230</a>
<a name='L231'></a><a href='#L231'>231</a>
<a name='L232'></a><a href='#L232'>232</a>
<a name='L233'></a><a href='#L233'>233</a>
<a name='L234'></a><a href='#L234'>234</a>
<a name='L235'></a><a href='#L235'>235</a>
<a name='L236'></a><a href='#L236'>236</a>
<a name='L237'></a><a href='#L237'>237</a>
<a name='L238'></a><a href='#L238'>238</a>
<a name='L239'></a><a href='#L239'>239</a>
<a name='L240'></a><a href='#L240'>240</a>
<a name='L241'></a><a href='#L241'>241</a>
<a name='L242'></a><a href='#L242'>242</a>
<a name='L243'></a><a href='#L243'>243</a>
<a name='L244'></a><a href='#L244'>244</a>
<a name='L245'></a><a href='#L245'>245</a>
<a name='L246'></a><a href='#L246'>246</a>
<a name='L247'></a><a href='#L247'>247</a>
<a name='L248'></a><a href='#L248'>248</a>
<a name='L249'></a><a href='#L249'>249</a>
<a name='L250'></a><a href='#L250'>250</a>
<a name='L251'></a><a href='#L251'>251</a>
<a name='L252'></a><a href='#L252'>252</a>
<a name='L253'></a><a href='#L253'>253</a>
<a name='L254'></a><a href='#L254'>254</a>
<a name='L255'></a><a href='#L255'>255</a>
<a name='L256'></a><a href='#L256'>256</a>
<a name='L257'></a><a href='#L257'>257</a>
<a name='L258'></a><a href='#L258'>258</a>
<a name='L259'></a><a href='#L259'>259</a>
<a name='L260'></a><a href='#L260'>260</a>
<a name='L261'></a><a href='#L261'>261</a>
<a name='L262'></a><a href='#L262'>262</a>
<a name='L263'></a><a href='#L263'>263</a>
<a name='L264'></a><a href='#L264'>264</a>
<a name='L265'></a><a href='#L265'>265</a>
<a name='L266'></a><a href='#L266'>266</a>
<a name='L267'></a><a href='#L267'>267</a>
<a name='L268'></a><a href='#L268'>268</a>
<a name='L269'></a><a href='#L269'>269</a>
<a name='L270'></a><a href='#L270'>270</a>
<a name='L271'></a><a href='#L271'>271</a>
<a name='L272'></a><a href='#L272'>272</a>
<a name='L273'></a><a href='#L273'>273</a>
<a name='L274'></a><a href='#L274'>274</a>
<a name='L275'></a><a href='#L275'>275</a>
<a name='L276'></a><a href='#L276'>276</a>
<a name='L277'></a><a href='#L277'>277</a>
<a name='L278'></a><a href='#L278'>278</a>
<a name='L279'></a><a href='#L279'>279</a>
<a name='L280'></a><a href='#L280'>280</a>
<a name='L281'></a><a href='#L281'>281</a>
<a name='L282'></a><a href='#L282'>282</a>
<a name='L283'></a><a href='#L283'>283</a>
<a name='L284'></a><a href='#L284'>284</a>
<a name='L285'></a><a href='#L285'>285</a>
<a name='L286'></a><a href='#L286'>286</a>
<a name='L287'></a><a href='#L287'>287</a>
<a name='L288'></a><a href='#L288'>288</a>
<a name='L289'></a><a href='#L289'>289</a>
<a name='L290'></a><a href='#L290'>290</a>
<a name='L291'></a><a href='#L291'>291</a>
<a name='L292'></a><a href='#L292'>292</a>
<a name='L293'></a><a href='#L293'>293</a>
<a name='L294'></a><a href='#L294'>294</a>
<a name='L295'></a><a href='#L295'>295</a>
<a name='L296'></a><a href='#L296'>296</a>
<a name='L297'></a><a href='#L297'>297</a>
<a name='L298'></a><a href='#L298'>298</a>
<a name='L299'></a><a href='#L299'>299</a>
<a name='L300'></a><a href='#L300'>300</a>
<a name='L301'></a><a href='#L301'>301</a>
<a name='L302'></a><a href='#L302'>302</a>
<a name='L303'></a><a href='#L303'>303</a>
<a name='L304'></a><a href='#L304'>304</a>
<a name='L305'></a><a href='#L305'>305</a>
<a name='L306'></a><a href='#L306'>306</a>
<a name='L307'></a><a href='#L307'>307</a>
<a name='L308'></a><a href='#L308'>308</a>
<a name='L309'></a><a href='#L309'>309</a>
<a name='L310'></a><a href='#L310'>310</a>
<a name='L311'></a><a href='#L311'>311</a>
<a name='L312'></a><a href='#L312'>312</a>
<a name='L313'></a><a href='#L313'>313</a>
<a name='L314'></a><a href='#L314'>314</a>
<a name='L315'></a><a href='#L315'>315</a>
<a name='L316'></a><a href='#L316'>316</a>
<a name='L317'></a><a href='#L317'>317</a>
<a name='L318'></a><a href='#L318'>318</a>
<a name='L319'></a><a href='#L319'>319</a>
<a name='L320'></a><a href='#L320'>320</a>
<a name='L321'></a><a href='#L321'>321</a>
<a name='L322'></a><a href='#L322'>322</a>
<a name='L323'></a><a href='#L323'>323</a>
<a name='L324'></a><a href='#L324'>324</a>
<a name='L325'></a><a href='#L325'>325</a>
<a name='L326'></a><a href='#L326'>326</a>
<a name='L327'></a><a href='#L327'>327</a>
<a name='L328'></a><a href='#L328'>328</a>
<a name='L329'></a><a href='#L329'>329</a>
<a name='L330'></a><a href='#L330'>330</a>
<a name='L331'></a><a href='#L331'>331</a>
<a name='L332'></a><a href='#L332'>332</a>
<a name='L333'></a><a href='#L333'>333</a>
<a name='L334'></a><a href='#L334'>334</a>
<a name='L335'></a><a href='#L335'>335</a>
<a name='L336'></a><a href='#L336'>336</a>
<a name='L337'></a><a href='#L337'>337</a>
<a name='L338'></a><a href='#L338'>338</a>
<a name='L339'></a><a href='#L339'>339</a>
<a name='L340'></a><a href='#L340'>340</a>
<a name='L341'></a><a href='#L341'>341</a>
<a name='L342'></a><a href='#L342'>342</a>
<a name='L343'></a><a href='#L343'>343</a>
<a name='L344'></a><a href='#L344'>344</a>
<a name='L345'></a><a href='#L345'>345</a>
<a name='L346'></a><a href='#L346'>346</a>
<a name='L347'></a><a href='#L347'>347</a>
<a name='L348'></a><a href='#L348'>348</a>
<a name='L349'></a><a href='#L349'>349</a>
<a name='L350'></a><a href='#L350'>350</a>
<a name='L351'></a><a href='#L351'>351</a>
<a name='L352'></a><a href='#L352'>352</a>
<a name='L353'></a><a href='#L353'>353</a>
<a name='L354'></a><a href='#L354'>354</a>
<a name='L355'></a><a href='#L355'>355</a>
<a name='L356'></a><a href='#L356'>356</a>
<a name='L357'></a><a href='#L357'>357</a>
<a name='L358'></a><a href='#L358'>358</a>
<a name='L359'></a><a href='#L359'>359</a>
<a name='L360'></a><a href='#L360'>360</a>
<a name='L361'></a><a href='#L361'>361</a>
<a name='L362'></a><a href='#L362'>362</a>
<a name='L363'></a><a href='#L363'>363</a>
<a name='L364'></a><a href='#L364'>364</a>
<a name='L365'></a><a href='#L365'>365</a>
<a name='L366'></a><a href='#L366'>366</a>
<a name='L367'></a><a href='#L367'>367</a>
<a name='L368'></a><a href='#L368'>368</a>
<a name='L369'></a><a href='#L369'>369</a>
<a name='L370'></a><a href='#L370'>370</a>
<a name='L371'></a><a href='#L371'>371</a>
<a name='L372'></a><a href='#L372'>372</a>
<a name='L373'></a><a href='#L373'>373</a>
<a name='L374'></a><a href='#L374'>374</a>
<a name='L375'></a><a href='#L375'>375</a>
<a name='L376'></a><a href='#L376'>376</a>
<a name='L377'></a><a href='#L377'>377</a>
<a name='L378'></a><a href='#L378'>378</a>
<a name='L379'></a><a href='#L379'>379</a>
<a name='L380'></a><a href='#L380'>380</a>
<a name='L381'></a><a href='#L381'>381</a>
<a name='L382'></a><a href='#L382'>382</a>
<a name='L383'></a><a href='#L383'>383</a>
<a name='L384'></a><a href='#L384'>384</a>
<a name='L385'></a><a href='#L385'>385</a>
<a name='L386'></a><a href='#L386'>386</a>
<a name='L387'></a><a href='#L387'>387</a>
<a name='L388'></a><a href='#L388'>388</a>
<a name='L389'></a><a href='#L389'>389</a>
<a name='L390'></a><a href='#L390'>390</a>
<a name='L391'></a><a href='#L391'>391</a>
<a name='L392'></a><a href='#L392'>392</a>
<a name='L393'></a><a href='#L393'>393</a>
<a name='L394'></a><a href='#L394'>394</a>
<a name='L395'></a><a href='#L395'>395</a>
<a name='L396'></a><a href='#L396'>396</a>
<a name='L397'></a><a href='#L397'>397</a>
<a name='L398'></a><a href='#L398'>398</a>
<a name='L399'></a><a href='#L399'>399</a>
<a name='L400'></a><a href='#L400'>400</a>
<a name='L401'></a><a href='#L401'>401</a>
<a name='L402'></a><a href='#L402'>402</a>
<a name='L403'></a><a href='#L403'>403</a>
<a name='L404'></a><a href='#L404'>404</a>
<a name='L405'></a><a href='#L405'>405</a>
<a name='L406'></a><a href='#L406'>406</a>
<a name='L407'></a><a href='#L407'>407</a>
<a name='L408'></a><a href='#L408'>408</a>
<a name='L409'></a><a href='#L409'>409</a>
<a name='L410'></a><a href='#L410'>410</a>
<a name='L411'></a><a href='#L411'>411</a>
<a name='L412'></a><a href='#L412'>412</a>
<a name='L413'></a><a href='#L413'>413</a>
<a name='L414'></a><a href='#L414'>414</a>
<a name='L415'></a><a href='#L415'>415</a>
<a name='L416'></a><a href='#L416'>416</a>
<a name='L417'></a><a href='#L417'>417</a>
<a name='L418'></a><a href='#L418'>418</a>
<a name='L419'></a><a href='#L419'>419</a>
<a name='L420'></a><a href='#L420'>420</a>
<a name='L421'></a><a href='#L421'>421</a>
<a name='L422'></a><a href='#L422'>422</a>
<a name='L423'></a><a href='#L423'>423</a>
<a name='L424'></a><a href='#L424'>424</a>
<a name='L425'></a><a href='#L425'>425</a>
<a name='L426'></a><a href='#L426'>426</a>
<a name='L427'></a><a href='#L427'>427</a>
<a name='L428'></a><a href='#L428'>428</a>
<a name='L429'></a><a href='#L429'>429</a>
<a name='L430'></a><a href='#L430'>430</a>
<a name='L431'></a><a href='#L431'>431</a>
<a name='L432'></a><a href='#L432'>432</a>
<a name='L433'></a><a href='#L433'>433</a>
<a name='L434'></a><a href='#L434'>434</a>
<a name='L435'></a><a href='#L435'>435</a>
<a name='L436'></a><a href='#L436'>436</a>
<a name='L437'></a><a href='#L437'>437</a>
<a name='L438'></a><a href='#L438'>438</a>
<a name='L439'></a><a href='#L439'>439</a>
<a name='L440'></a><a href='#L440'>440</a>
<a name='L441'></a><a href='#L441'>441</a>
<a name='L442'></a><a href='#L442'>442</a>
<a name='L443'></a><a href='#L443'>443</a>
<a name='L444'></a><a href='#L444'>444</a>
<a name='L445'></a><a href='#L445'>445</a>
<a name='L446'></a><a href='#L446'>446</a>
<a name='L447'></a><a href='#L447'>447</a>
<a name='L448'></a><a href='#L448'>448</a>
<a name='L449'></a><a href='#L449'>449</a>
<a name='L450'></a><a href='#L450'>450</a>
<a name='L451'></a><a href='#L451'>451</a>
<a name='L452'></a><a href='#L452'>452</a>
<a name='L453'></a><a href='#L453'>453</a>
<a name='L454'></a><a href='#L454'>454</a>
<a name='L455'></a><a href='#L455'>455</a>
<a name='L456'></a><a href='#L456'>456</a>
<a name='L457'></a><a href='#L457'>457</a>
<a name='L458'></a><a href='#L458'>458</a>
<a name='L459'></a><a href='#L459'>459</a>
<a name='L460'></a><a href='#L460'>460</a>
<a name='L461'></a><a href='#L461'>461</a>
<a name='L462'></a><a href='#L462'>462</a>
<a name='L463'></a><a href='#L463'>463</a>
<a name='L464'></a><a href='#L464'>464</a>
<a name='L465'></a><a href='#L465'>465</a>
<a name='L466'></a><a href='#L466'>466</a>
<a name='L467'></a><a href='#L467'>467</a>
<a name='L468'></a><a href='#L468'>468</a>
<a name='L469'></a><a href='#L469'>469</a>
<a name='L470'></a><a href='#L470'>470</a>
<a name='L471'></a><a href='#L471'>471</a>
<a name='L472'></a><a href='#L472'>472</a>
<a name='L473'></a><a href='#L473'>473</a>
<a name='L474'></a><a href='#L474'>474</a>
<a name='L475'></a><a href='#L475'>475</a>
<a name='L476'></a><a href='#L476'>476</a>
<a name='L477'></a><a href='#L477'>477</a>
<a name='L478'></a><a href='#L478'>478</a>
<a name='L479'></a><a href='#L479'>479</a>
<a name='L480'></a><a href='#L480'>480</a>
<a name='L481'></a><a href='#L481'>481</a>
<a name='L482'></a><a href='#L482'>482</a>
<a name='L483'></a><a href='#L483'>483</a>
<a name='L484'></a><a href='#L484'>484</a>
<a name='L485'></a><a href='#L485'>485</a>
<a name='L486'></a><a href='#L486'>486</a>
<a name='L487'></a><a href='#L487'>487</a>
<a name='L488'></a><a href='#L488'>488</a>
<a name='L489'></a><a href='#L489'>489</a>
<a name='L490'></a><a href='#L490'>490</a>
<a name='L491'></a><a href='#L491'>491</a>
<a name='L492'></a><a href='#L492'>492</a>
<a name='L493'></a><a href='#L493'>493</a>
<a name='L494'></a><a href='#L494'>494</a>
<a name='L495'></a><a href='#L495'>495</a>
<a name='L496'></a><a href='#L496'>496</a>
<a name='L497'></a><a href='#L497'>497</a>
<a name='L498'></a><a href='#L498'>498</a>
<a name='L499'></a><a href='#L499'>499</a>
<a name='L500'></a><a href='#L500'>500</a>
<a name='L501'></a><a href='#L501'>501</a>
<a name='L502'></a><a href='#L502'>502</a>
<a name='L503'></a><a href='#L503'>503</a>
<a name='L504'></a><a href='#L504'>504</a>
<a name='L505'></a><a href='#L505'>505</a>
<a name='L506'></a><a href='#L506'>506</a>
<a name='L507'></a><a href='#L507'>507</a>
<a name='L508'></a><a href='#L508'>508</a>
<a name='L509'></a><a href='#L509'>509</a>
<a name='L510'></a><a href='#L510'>510</a>
<a name='L511'></a><a href='#L511'>511</a>
<a name='L512'></a><a href='#L512'>512</a>
<a name='L513'></a><a href='#L513'>513</a>
<a name='L514'></a><a href='#L514'>514</a>
<a name='L515'></a><a href='#L515'>515</a>
<a name='L516'></a><a href='#L516'>516</a>
<a name='L517'></a><a href='#L517'>517</a>
<a name='L518'></a><a href='#L518'>518</a>
<a name='L519'></a><a href='#L519'>519</a>
<a name='L520'></a><a href='#L520'>520</a>
<a name='L521'></a><a href='#L521'>521</a>
<a name='L522'></a><a href='#L522'>522</a>
<a name='L523'></a><a href='#L523'>523</a>
<a name='L524'></a><a href='#L524'>524</a>
<a name='L525'></a><a href='#L525'>525</a>
<a name='L526'></a><a href='#L526'>526</a>
<a name='L527'></a><a href='#L527'>527</a>
<a name='L528'></a><a href='#L528'>528</a>
<a name='L529'></a><a href='#L529'>529</a>
<a name='L530'></a><a href='#L530'>530</a>
<a name='L531'></a><a href='#L531'>531</a>
<a name='L532'></a><a href='#L532'>532</a>
<a name='L533'></a><a href='#L533'>533</a>
<a name='L534'></a><a href='#L534'>534</a>
<a name='L535'></a><a href='#L535'>535</a>
<a name='L536'></a><a href='#L536'>536</a>
<a name='L537'></a><a href='#L537'>537</a>
<a name='L538'></a><a href='#L538'>538</a>
<a name='L539'></a><a href='#L539'>539</a>
<a name='L540'></a><a href='#L540'>540</a>
<a name='L541'></a><a href='#L541'>541</a>
<a name='L542'></a><a href='#L542'>542</a>
<a name='L543'></a><a href='#L543'>543</a>
<a name='L544'></a><a href='#L544'>544</a>
<a name='L545'></a><a href='#L545'>545</a>
<a name='L546'></a><a href='#L546'>546</a>
<a name='L547'></a><a href='#L547'>547</a>
<a name='L548'></a><a href='#L548'>548</a>
<a name='L549'></a><a href='#L549'>549</a>
<a name='L550'></a><a href='#L550'>550</a>
<a name='L551'></a><a href='#L551'>551</a>
<a name='L552'></a><a href='#L552'>552</a>
<a name='L553'></a><a href='#L553'>553</a>
<a name='L554'></a><a href='#L554'>554</a>
<a name='L555'></a><a href='#L555'>555</a>
<a name='L556'></a><a href='#L556'>556</a>
<a name='L557'></a><a href='#L557'>557</a>
<a name='L558'></a><a href='#L558'>558</a>
<a name='L559'></a><a href='#L559'>559</a>
<a name='L560'></a><a href='#L560'>560</a>
<a name='L561'></a><a href='#L561'>561</a>
<a name='L562'></a><a href='#L562'>562</a>
<a name='L563'></a><a href='#L563'>563</a>
<a name='L564'></a><a href='#L564'>564</a>
<a name='L565'></a><a href='#L565'>565</a>
<a name='L566'></a><a href='#L566'>566</a>
<a name='L567'></a><a href='#L567'>567</a>
<a name='L568'></a><a href='#L568'>568</a>
<a name='L569'></a><a href='#L569'>569</a>
<a name='L570'></a><a href='#L570'>570</a>
<a name='L571'></a><a href='#L571'>571</a>
<a name='L572'></a><a href='#L572'>572</a>
<a name='L573'></a><a href='#L573'>573</a>
<a name='L574'></a><a href='#L574'>574</a>
<a name='L575'></a><a href='#L575'>575</a>
<a name='L576'></a><a href='#L576'>576</a>
<a name='L577'></a><a href='#L577'>577</a>
<a name='L578'></a><a href='#L578'>578</a>
<a name='L579'></a><a href='#L579'>579</a>
<a name='L580'></a><a href='#L580'>580</a>
<a name='L581'></a><a href='#L581'>581</a>
<a name='L582'></a><a href='#L582'>582</a>
<a name='L583'></a><a href='#L583'>583</a>
<a name='L584'></a><a href='#L584'>584</a>
<a name='L585'></a><a href='#L585'>585</a>
<a name='L586'></a><a href='#L586'>586</a>
<a name='L587'></a><a href='#L587'>587</a>
<a name='L588'></a><a href='#L588'>588</a>
<a name='L589'></a><a href='#L589'>589</a>
<a name='L590'></a><a href='#L590'>590</a>
<a name='L591'></a><a href='#L591'>591</a>
<a name='L592'></a><a href='#L592'>592</a>
<a name='L593'></a><a href='#L593'>593</a>
<a name='L594'></a><a href='#L594'>594</a>
<a name='L595'></a><a href='#L595'>595</a>
<a name='L596'></a><a href='#L596'>596</a>
<a name='L597'></a><a href='#L597'>597</a>
<a name='L598'></a><a href='#L598'>598</a>
<a name='L599'></a><a href='#L599'>599</a>
<a name='L600'></a><a href='#L600'>600</a>
<a name='L601'></a><a href='#L601'>601</a>
<a name='L602'></a><a href='#L602'>602</a>
<a name='L603'></a><a href='#L603'>603</a>
<a name='L604'></a><a href='#L604'>604</a>
<a name='L605'></a><a href='#L605'>605</a>
<a name='L606'></a><a href='#L606'>606</a>
<a name='L607'></a><a href='#L607'>607</a>
<a name='L608'></a><a href='#L608'>608</a>
<a name='L609'></a><a href='#L609'>609</a>
<a name='L610'></a><a href='#L610'>610</a>
<a name='L611'></a><a href='#L611'>611</a>
<a name='L612'></a><a href='#L612'>612</a>
<a name='L613'></a><a href='#L613'>613</a>
<a name='L614'></a><a href='#L614'>614</a>
<a name='L615'></a><a href='#L615'>615</a>
<a name='L616'></a><a href='#L616'>616</a>
<a name='L617'></a><a href='#L617'>617</a>
<a name='L618'></a><a href='#L618'>618</a>
<a name='L619'></a><a href='#L619'>619</a>
<a name='L620'></a><a href='#L620'>620</a>
<a name='L621'></a><a href='#L621'>621</a>
<a name='L622'></a><a href='#L622'>622</a>
<a name='L623'></a><a href='#L623'>623</a>
<a name='L624'></a><a href='#L624'>624</a>
<a name='L625'></a><a href='#L625'>625</a>
<a name='L626'></a><a href='#L626'>626</a>
<a name='L627'></a><a href='#L627'>627</a>
<a name='L628'></a><a href='#L628'>628</a>
<a name='L629'></a><a href='#L629'>629</a>
<a name='L630'></a><a href='#L630'>630</a>
<a name='L631'></a><a href='#L631'>631</a>
<a name='L632'></a><a href='#L632'>632</a>
<a name='L633'></a><a href='#L633'>633</a>
<a name='L634'></a><a href='#L634'>634</a>
<a name='L635'></a><a href='#L635'>635</a>
<a name='L636'></a><a href='#L636'>636</a>
<a name='L637'></a><a href='#L637'>637</a>
<a name='L638'></a><a href='#L638'>638</a>
<a name='L639'></a><a href='#L639'>639</a>
<a name='L640'></a><a href='#L640'>640</a>
<a name='L641'></a><a href='#L641'>641</a>
<a name='L642'></a><a href='#L642'>642</a>
<a name='L643'></a><a href='#L643'>643</a>
<a name='L644'></a><a href='#L644'>644</a>
<a name='L645'></a><a href='#L645'>645</a>
<a name='L646'></a><a href='#L646'>646</a>
<a name='L647'></a><a href='#L647'>647</a>
<a name='L648'></a><a href='#L648'>648</a>
<a name='L649'></a><a href='#L649'>649</a>
<a name='L650'></a><a href='#L650'>650</a>
<a name='L651'></a><a href='#L651'>651</a>
<a name='L652'></a><a href='#L652'>652</a>
<a name='L653'></a><a href='#L653'>653</a>
<a name='L654'></a><a href='#L654'>654</a>
<a name='L655'></a><a href='#L655'>655</a>
<a name='L656'></a><a href='#L656'>656</a>
<a name='L657'></a><a href='#L657'>657</a>
<a name='L658'></a><a href='#L658'>658</a>
<a name='L659'></a><a href='#L659'>659</a>
<a name='L660'></a><a href='#L660'>660</a>
<a name='L661'></a><a href='#L661'>661</a>
<a name='L662'></a><a href='#L662'>662</a>
<a name='L663'></a><a href='#L663'>663</a>
<a name='L664'></a><a href='#L664'>664</a>
<a name='L665'></a><a href='#L665'>665</a>
<a name='L666'></a><a href='#L666'>666</a>
<a name='L667'></a><a href='#L667'>667</a>
<a name='L668'></a><a href='#L668'>668</a>
<a name='L669'></a><a href='#L669'>669</a>
<a name='L670'></a><a href='#L670'>670</a>
<a name='L671'></a><a href='#L671'>671</a>
<a name='L672'></a><a href='#L672'>672</a>
<a name='L673'></a><a href='#L673'>673</a>
<a name='L674'></a><a href='#L674'>674</a>
<a name='L675'></a><a href='#L675'>675</a>
<a name='L676'></a><a href='#L676'>676</a>
<a name='L677'></a><a href='#L677'>677</a>
<a name='L678'></a><a href='#L678'>678</a>
<a name='L679'></a><a href='#L679'>679</a>
<a name='L680'></a><a href='#L680'>680</a>
<a name='L681'></a><a href='#L681'>681</a>
<a name='L682'></a><a href='#L682'>682</a>
<a name='L683'></a><a href='#L683'>683</a>
<a name='L684'></a><a href='#L684'>684</a>
<a name='L685'></a><a href='#L685'>685</a>
<a name='L686'></a><a href='#L686'>686</a>
<a name='L687'></a><a href='#L687'>687</a>
<a name='L688'></a><a href='#L688'>688</a>
<a name='L689'></a><a href='#L689'>689</a>
<a name='L690'></a><a href='#L690'>690</a>
<a name='L691'></a><a href='#L691'>691</a>
<a name='L692'></a><a href='#L692'>692</a>
<a name='L693'></a><a href='#L693'>693</a>
<a name='L694'></a><a href='#L694'>694</a>
<a name='L695'></a><a href='#L695'>695</a>
<a name='L696'></a><a href='#L696'>696</a>
<a name='L697'></a><a href='#L697'>697</a>
<a name='L698'></a><a href='#L698'>698</a>
<a name='L699'></a><a href='#L699'>699</a>
<a name='L700'></a><a href='#L700'>700</a>
<a name='L701'></a><a href='#L701'>701</a>
<a name='L702'></a><a href='#L702'>702</a>
<a name='L703'></a><a href='#L703'>703</a>
<a name='L704'></a><a href='#L704'>704</a>
<a name='L705'></a><a href='#L705'>705</a>
<a name='L706'></a><a href='#L706'>706</a>
<a name='L707'></a><a href='#L707'>707</a>
<a name='L708'></a><a href='#L708'>708</a>
<a name='L709'></a><a href='#L709'>709</a>
<a name='L710'></a><a href='#L710'>710</a>
<a name='L711'></a><a href='#L711'>711</a>
<a name='L712'></a><a href='#L712'>712</a>
<a name='L713'></a><a href='#L713'>713</a>
<a name='L714'></a><a href='#L714'>714</a>
<a name='L715'></a><a href='#L715'>715</a>
<a name='L716'></a><a href='#L716'>716</a>
<a name='L717'></a><a href='#L717'>717</a>
<a name='L718'></a><a href='#L718'>718</a>
<a name='L719'></a><a href='#L719'>719</a>
<a name='L720'></a><a href='#L720'>720</a>
<a name='L721'></a><a href='#L721'>721</a>
<a name='L722'></a><a href='#L722'>722</a>
<a name='L723'></a><a href='#L723'>723</a>
<a name='L724'></a><a href='#L724'>724</a>
<a name='L725'></a><a href='#L725'>725</a>
<a name='L726'></a><a href='#L726'>726</a>
<a name='L727'></a><a href='#L727'>727</a>
<a name='L728'></a><a href='#L728'>728</a>
<a name='L729'></a><a href='#L729'>729</a>
<a name='L730'></a><a href='#L730'>730</a>
<a name='L731'></a><a href='#L731'>731</a>
<a name='L732'></a><a href='#L732'>732</a>
<a name='L733'></a><a href='#L733'>733</a>
<a name='L734'></a><a href='#L734'>734</a>
<a name='L735'></a><a href='#L735'>735</a>
<a name='L736'></a><a href='#L736'>736</a>
<a name='L737'></a><a href='#L737'>737</a>
<a name='L738'></a><a href='#L738'>738</a>
<a name='L739'></a><a href='#L739'>739</a>
<a name='L740'></a><a href='#L740'>740</a>
<a name='L741'></a><a href='#L741'>741</a>
<a name='L742'></a><a href='#L742'>742</a>
<a name='L743'></a><a href='#L743'>743</a>
<a name='L744'></a><a href='#L744'>744</a>
<a name='L745'></a><a href='#L745'>745</a>
<a name='L746'></a><a href='#L746'>746</a>
<a name='L747'></a><a href='#L747'>747</a>
<a name='L748'></a><a href='#L748'>748</a>
<a name='L749'></a><a href='#L749'>749</a>
<a name='L750'></a><a href='#L750'>750</a>
<a name='L751'></a><a href='#L751'>751</a>
<a name='L752'></a><a href='#L752'>752</a>
<a name='L753'></a><a href='#L753'>753</a>
<a name='L754'></a><a href='#L754'>754</a>
<a name='L755'></a><a href='#L755'>755</a>
<a name='L756'></a><a href='#L756'>756</a>
<a name='L757'></a><a href='#L757'>757</a>
<a name='L758'></a><a href='#L758'>758</a>
<a name='L759'></a><a href='#L759'>759</a>
<a name='L760'></a><a href='#L760'>760</a>
<a name='L761'></a><a href='#L761'>761</a>
<a name='L762'></a><a href='#L762'>762</a>
<a name='L763'></a><a href='#L763'>763</a>
<a name='L764'></a><a href='#L764'>764</a>
<a name='L765'></a><a href='#L765'>765</a>
<a name='L766'></a><a href='#L766'>766</a>
<a name='L767'></a><a href='#L767'>767</a>
<a name='L768'></a><a href='#L768'>768</a>
<a name='L769'></a><a href='#L769'>769</a>
<a name='L770'></a><a href='#L770'>770</a>
<a name='L771'></a><a href='#L771'>771</a>
<a name='L772'></a><a href='#L772'>772</a>
<a name='L773'></a><a href='#L773'>773</a>
<a name='L774'></a><a href='#L774'>774</a>
<a name='L775'></a><a href='#L775'>775</a>
<a name='L776'></a><a href='#L776'>776</a>
<a name='L777'></a><a href='#L777'>777</a>
<a name='L778'></a><a href='#L778'>778</a>
<a name='L779'></a><a href='#L779'>779</a>
<a name='L780'></a><a href='#L780'>780</a>
<a name='L781'></a><a href='#L781'>781</a>
<a name='L782'></a><a href='#L782'>782</a>
<a name='L783'></a><a href='#L783'>783</a>
<a name='L784'></a><a href='#L784'>784</a>
<a name='L785'></a><a href='#L785'>785</a>
<a name='L786'></a><a href='#L786'>786</a>
<a name='L787'></a><a href='#L787'>787</a>
<a name='L788'></a><a href='#L788'>788</a>
<a name='L789'></a><a href='#L789'>789</a>
<a name='L790'></a><a href='#L790'>790</a>
<a name='L791'></a><a href='#L791'>791</a>
<a name='L792'></a><a href='#L792'>792</a>
<a name='L793'></a><a href='#L793'>793</a>
<a name='L794'></a><a href='#L794'>794</a>
<a name='L795'></a><a href='#L795'>795</a>
<a name='L796'></a><a href='#L796'>796</a>
<a name='L797'></a><a href='#L797'>797</a>
<a name='L798'></a><a href='#L798'>798</a>
<a name='L799'></a><a href='#L799'>799</a>
<a name='L800'></a><a href='#L800'>800</a>
<a name='L801'></a><a href='#L801'>801</a>
<a name='L802'></a><a href='#L802'>802</a>
<a name='L803'></a><a href='#L803'>803</a>
<a name='L804'></a><a href='#L804'>804</a>
<a name='L805'></a><a href='#L805'>805</a>
<a name='L806'></a><a href='#L806'>806</a>
<a name='L807'></a><a href='#L807'>807</a>
<a name='L808'></a><a href='#L808'>808</a>
<a name='L809'></a><a href='#L809'>809</a>
<a name='L810'></a><a href='#L810'>810</a>
<a name='L811'></a><a href='#L811'>811</a>
<a name='L812'></a><a href='#L812'>812</a>
<a name='L813'></a><a href='#L813'>813</a>
<a name='L814'></a><a href='#L814'>814</a>
<a name='L815'></a><a href='#L815'>815</a>
<a name='L816'></a><a href='#L816'>816</a>
<a name='L817'></a><a href='#L817'>817</a>
<a name='L818'></a><a href='#L818'>818</a>
<a name='L819'></a><a href='#L819'>819</a>
<a name='L820'></a><a href='#L820'>820</a>
<a name='L821'></a><a href='#L821'>821</a>
<a name='L822'></a><a href='#L822'>822</a>
<a name='L823'></a><a href='#L823'>823</a>
<a name='L824'></a><a href='#L824'>824</a>
<a name='L825'></a><a href='#L825'>825</a>
<a name='L826'></a><a href='#L826'>826</a>
<a name='L827'></a><a href='#L827'>827</a>
<a name='L828'></a><a href='#L828'>828</a>
<a name='L829'></a><a href='#L829'>829</a>
<a name='L830'></a><a href='#L830'>830</a>
<a name='L831'></a><a href='#L831'>831</a>
<a name='L832'></a><a href='#L832'>832</a>
<a name='L833'></a><a href='#L833'>833</a>
<a name='L834'></a><a href='#L834'>834</a>
<a name='L835'></a><a href='#L835'>835</a>
<a name='L836'></a><a href='#L836'>836</a>
<a name='L837'></a><a href='#L837'>837</a>
<a name='L838'></a><a href='#L838'>838</a>
<a name='L839'></a><a href='#L839'>839</a>
<a name='L840'></a><a href='#L840'>840</a>
<a name='L841'></a><a href='#L841'>841</a>
<a name='L842'></a><a href='#L842'>842</a>
<a name='L843'></a><a href='#L843'>843</a>
<a name='L844'></a><a href='#L844'>844</a>
<a name='L845'></a><a href='#L845'>845</a>
<a name='L846'></a><a href='#L846'>846</a>
<a name='L847'></a><a href='#L847'>847</a>
<a name='L848'></a><a href='#L848'>848</a>
<a name='L849'></a><a href='#L849'>849</a>
<a name='L850'></a><a href='#L850'>850</a>
<a name='L851'></a><a href='#L851'>851</a>
<a name='L852'></a><a href='#L852'>852</a>
<a name='L853'></a><a href='#L853'>853</a>
<a name='L854'></a><a href='#L854'>854</a>
<a name='L855'></a><a href='#L855'>855</a>
<a name='L856'></a><a href='#L856'>856</a>
<a name='L857'></a><a href='#L857'>857</a>
<a name='L858'></a><a href='#L858'>858</a>
<a name='L859'></a><a href='#L859'>859</a>
<a name='L860'></a><a href='#L860'>860</a>
<a name='L861'></a><a href='#L861'>861</a>
<a name='L862'></a><a href='#L862'>862</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(global,factory){<span class="cstat-no" title="statement not covered" >typeof exports==='object'&amp;&amp;typeof module!=='undefined'?module.exports=factory():typeof define==='function'&amp;&amp;define.amd?define(factory):global.moment=factory();}</span>)(void 0,<span class="fstat-no" title="function not covered" >fu</span>nction(){'use strict';var hookCallback;function <span class="fstat-no" title="function not covered" >hooks(</span>){<span class="cstat-no" title="statement not covered" >return hookCallback.apply(null,arguments);}</span>// This is done to register the method called with moment()</span>
// without creating circular dependencies.
function <span class="fstat-no" title="function not covered" >setHookCallback(</span>callback){<span class="cstat-no" title="statement not covered" >hookCallback=callback;}</span>function <span class="fstat-no" title="function not covered" >isArray(</span>input){<span class="cstat-no" title="statement not covered" >return input instanceof Array||Object.prototype.toString.call(input)==='[object Array]';}</span>function <span class="fstat-no" title="function not covered" >isObject(</span>input){// IE8 will treat undefined and null as object if it wasn't for
// input != null
<span class="cstat-no" title="statement not covered" >return input!=null&amp;&amp;Object.prototype.toString.call(input)==='[object Object]';}</span>function <span class="fstat-no" title="function not covered" >hasOwnProp(</span>a,b){<span class="cstat-no" title="statement not covered" >return Object.prototype.hasOwnProperty.call(a,b);}</span>function <span class="fstat-no" title="function not covered" >isObjectEmpty(</span>obj){<span class="cstat-no" title="statement not covered" >if(Object.getOwnPropertyNames){<span class="cstat-no" title="statement not covered" >return Object.getOwnPropertyNames(obj).length===0;}</span>else{var k;<span class="cstat-no" title="statement not covered" >for(k in obj){<span class="cstat-no" title="statement not covered" >if(hasOwnProp(obj,k)){<span class="cstat-no" title="statement not covered" >return false;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn true;}</span>}</span>function <span class="fstat-no" title="function not covered" >isUndefined(</span>input){<span class="cstat-no" title="statement not covered" >return input===void 0;}</span>function <span class="fstat-no" title="function not covered" >isNumber(</span>input){<span class="cstat-no" title="statement not covered" >return typeof input==='number'||Object.prototype.toString.call(input)==='[object Number]';}</span>function <span class="fstat-no" title="function not covered" >isDate(</span>input){<span class="cstat-no" title="statement not covered" >return input instanceof Date||Object.prototype.toString.call(input)==='[object Date]';}</span>function <span class="fstat-no" title="function not covered" >map(</span>arr,fn){var res=<span class="cstat-no" title="statement not covered" >[],</span>i;<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;arr.length;++i){<span class="cstat-no" title="statement not covered" >res.push(fn(arr[i],i));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn res;}</span>function <span class="fstat-no" title="function not covered" >extend(</span>a,b){<span class="cstat-no" title="statement not covered" >for(var i in b){<span class="cstat-no" title="statement not covered" >if(hasOwnProp(b,i)){<span class="cstat-no" title="statement not covered" >a[i]=b[i];}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(hasOwnProp(b,'toString')){<span class="cstat-no" title="statement not covered" >a.toString=b.toString;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(hasOwnProp(b,'valueOf')){<span class="cstat-no" title="statement not covered" >a.valueOf=b.valueOf;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a;}</span>function <span class="fstat-no" title="function not covered" >createUTC(</span>input,format,locale,strict){<span class="cstat-no" title="statement not covered" >return createLocalOrUTC(input,format,locale,strict,true).utc();}</span>function <span class="fstat-no" title="function not covered" >defaultParsingFlags(</span>){// We need to deep clone this object.
<span class="cstat-no" title="statement not covered" >return{empty:false,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:false,invalidEra:null,invalidMonth:null,invalidFormat:false,userInvalidated:false,iso:false,parsedDateParts:[],era:null,meridiem:null,rfc2822:false,weekdayMismatch:false};}</span>function <span class="fstat-no" title="function not covered" >getParsingFlags(</span>m){<span class="cstat-no" title="statement not covered" >if(m._pf==null){<span class="cstat-no" title="statement not covered" >m._pf=defaultParsingFlags();}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn m._pf;}</span>var some;<span class="cstat-no" title="statement not covered" >if(Array.prototype.some){<span class="cstat-no" title="statement not covered" >some=Array.prototype.some;}</span>else{<span class="cstat-no" title="statement not covered" >some=<span class="fstat-no" title="function not covered" >fu</span>nction(fun){var t=<span class="cstat-no" title="statement not covered" >Object(this),</span>len=<span class="cstat-no" title="statement not covered" >t.length&gt;&gt;&gt;0,</span>i;<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;len;i++){<span class="cstat-no" title="statement not covered" >if(i in t&amp;&amp;fun.call(this,t[i],i,t)){<span class="cstat-no" title="statement not covered" >return true;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span>;}</span>f</span>unction <span class="fstat-no" title="function not covered" >isValid(</span>m){<span class="cstat-no" title="statement not covered" >if(m._isValid==null){var flags=<span class="cstat-no" title="statement not covered" >getParsingFlags(m),</span>parsedParts=<span class="cstat-no" title="statement not covered" >some.call(flags.parsedDateParts,<span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >return i!=null;}</span>),</span>isNowValid=<span class="cstat-no" title="statement not covered" >!isNaN(m._d.getTime())&amp;&amp;flags.overflow&lt;0&amp;&amp;!flags.empty&amp;&amp;!flags.invalidEra&amp;&amp;!flags.invalidMonth&amp;&amp;!flags.invalidWeekday&amp;&amp;!flags.weekdayMismatch&amp;&amp;!flags.nullInput&amp;&amp;!flags.invalidFormat&amp;&amp;!flags.userInvalidated&amp;&amp;(!flags.meridiem||flags.meridiem&amp;&amp;parsedParts);<span class="cstat-no" title="statement not covered" ></span>if(m._strict){<span class="cstat-no" title="statement not covered" >isNowValid=isNowValid&amp;&amp;flags.charsLeftOver===0&amp;&amp;flags.unusedTokens.length===0&amp;&amp;flags.bigHour===undefined;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(Object.isFrozen==null||!Object.isFrozen(m)){<span class="cstat-no" title="statement not covered" >m._isValid=isNowValid;}</span>else{<span class="cstat-no" title="statement not covered" >return isNowValid;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn m._isValid;}</span>function <span class="fstat-no" title="function not covered" >createInvalid(</span>flags){var m=<span class="cstat-no" title="statement not covered" >createUTC(NaN);<span class="cstat-no" title="statement not covered" ></span>if(flags!=null){<span class="cstat-no" title="statement not covered" >extend(getParsingFlags(m),flags);}</span>else{<span class="cstat-no" title="statement not covered" >getParsingFlags(m).userInvalidated=true;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn m;}</span>// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties=<span class="cstat-no" title="statement not covered" >hooks.momentProperties=[],</span>updateInProgress=<span class="cstat-no" title="statement not covered" >false;</span>function <span class="fstat-no" title="function not covered" >copyConfig(</span>to,from){var i,prop,val;<span class="cstat-no" title="statement not covered" >if(!isUndefined(from._isAMomentObject)){<span class="cstat-no" title="statement not covered" >to._isAMomentObject=from._isAMomentObject;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isUndefined(from._i)){<span class="cstat-no" title="statement not covered" >to._i=from._i;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isUndefined(from._f)){<span class="cstat-no" title="statement not covered" >to._f=from._f;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isUndefined(from._l)){<span class="cstat-no" title="statement not covered" >to._l=from._l;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isUndefined(from._strict)){<span class="cstat-no" title="statement not covered" >to._strict=from._strict;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isUndefined(from._tzm)){<span class="cstat-no" title="statement not covered" >to._tzm=from._tzm;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isUndefined(from._isUTC)){<span class="cstat-no" title="statement not covered" >to._isUTC=from._isUTC;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isUndefined(from._offset)){<span class="cstat-no" title="statement not covered" >to._offset=from._offset;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isUndefined(from._pf)){<span class="cstat-no" title="statement not covered" >to._pf=getParsingFlags(from);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isUndefined(from._locale)){<span class="cstat-no" title="statement not covered" >to._locale=from._locale;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(momentProperties.length&gt;0){<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;momentProperties.length;i++){<span class="cstat-no" title="statement not covered" >prop=momentProperties[i];<span class="cstat-no" title="statement not covered" >v</span>al=from[prop];<span class="cstat-no" title="statement not covered" >i</span>f(!isUndefined(val)){<span class="cstat-no" title="statement not covered" >to[prop]=val;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn to;}</span>// Moment prototype object
function <span class="fstat-no" title="function not covered" >Moment(</span>config){<span class="cstat-no" title="statement not covered" >copyConfig(this,config);<span class="cstat-no" title="statement not covered" >t</span>his._d=new Date(config._d!=null?config._d.getTime():NaN);<span class="cstat-no" title="statement not covered" >i</span>f(!this.isValid()){<span class="cstat-no" title="statement not covered" >this._d=new Date(NaN);}</span>/</span>/ Prevent infinite loop in case updateOffset creates new moment
// objects.
<span class="cstat-no" title="statement not covered" >if(updateInProgress===false){<span class="cstat-no" title="statement not covered" >updateInProgress=true;<span class="cstat-no" title="statement not covered" >h</span>ooks.updateOffset(this);<span class="cstat-no" title="statement not covered" >u</span>pdateInProgress=false;}</span>}</span>function <span class="fstat-no" title="function not covered" >isMoment(</span>obj){<span class="cstat-no" title="statement not covered" >return obj instanceof Moment||obj!=null&amp;&amp;obj._isAMomentObject!=null;}</span>function <span class="fstat-no" title="function not covered" >warn(</span>msg){<span class="cstat-no" title="statement not covered" >if(hooks.suppressDeprecationWarnings===false&amp;&amp;typeof console!=='undefined'&amp;&amp;console.warn){<span class="cstat-no" title="statement not covered" >console.warn('Deprecation warning: '+msg);}</span>}</span>function <span class="fstat-no" title="function not covered" >deprecate(</span>msg,fn){var firstTime=<span class="cstat-no" title="statement not covered" >true;<span class="cstat-no" title="statement not covered" ></span>return extend(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(hooks.deprecationHandler!=null){<span class="cstat-no" title="statement not covered" >hooks.deprecationHandler(null,msg);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(firstTime){var args=<span class="cstat-no" title="statement not covered" >[],</span>arg,i,key;<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;arguments.length;i++){<span class="cstat-no" title="statement not covered" >arg='';<span class="cstat-no" title="statement not covered" >i</span>f(typeof arguments[i]==='object'){<span class="cstat-no" title="statement not covered" >arg+='\n['+i+'] ';<span class="cstat-no" title="statement not covered" >f</span>or(key in arguments[0]){<span class="cstat-no" title="statement not covered" >if(hasOwnProp(arguments[0],key)){<span class="cstat-no" title="statement not covered" >arg+=key+': '+arguments[0][key]+', ';}</span>}<span class="cstat-no" title="statement not covered" ></span>a</span>rg=arg.slice(0,-2);/</span>/ Remove trailing comma and space</span></span></span></span>
}else{<span class="cstat-no" title="statement not covered" >arg=arguments[i];}<span class="cstat-no" title="statement not covered" ></span>args.push(arg);}<span class="cstat-no" title="statement not covered" ></span>warn(msg+'\nArguments: '+Array.prototype.slice.call(args).join('')+'\n'+new Error().stack);<span class="cstat-no" title="statement not covered" >f</span>irstTime=false;}<span class="cstat-no" title="statement not covered" ></span>return fn.apply(this,arguments);}</span>,fn);}var deprecations=<span class="cstat-no" title="statement not covered" >{};</span>function <span class="fstat-no" title="function not covered" >deprecateSimple(</span>name,msg){<span class="cstat-no" title="statement not covered" >if(hooks.deprecationHandler!=null){<span class="cstat-no" title="statement not covered" >hooks.deprecationHandler(name,msg);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!deprecations[name]){<span class="cstat-no" title="statement not covered" >warn(msg);<span class="cstat-no" title="statement not covered" >d</span>eprecations[name]=true;}</span>}<span class="cstat-no" title="statement not covered" ></span>hooks.suppressDeprecationWarnings=false;<span class="cstat-no" title="statement not covered" >h</span>ooks.deprecationHandler=null;f</span>unction <span class="fstat-no" title="function not covered" >isFunction(</span>input){<span class="cstat-no" title="statement not covered" >return typeof Function!=='undefined'&amp;&amp;input instanceof Function||Object.prototype.toString.call(input)==='[object Function]';}</span>function <span class="fstat-no" title="function not covered" >set(</span>config){var prop,i;<span class="cstat-no" title="statement not covered" >for(i in config){<span class="cstat-no" title="statement not covered" >if(hasOwnProp(config,i)){<span class="cstat-no" title="statement not covered" >prop=config[i];<span class="cstat-no" title="statement not covered" >i</span>f(isFunction(prop)){<span class="cstat-no" title="statement not covered" >this[i]=prop;}</span>else{<span class="cstat-no" title="statement not covered" >this['_'+i]=prop;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his._config=config;/</span>/ Lenient ordinal parsing accepts just a number in addition to
// number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
// TODO: Remove "ordinalParse" fallback in next major release.
<span class="cstat-no" title="statement not covered" >this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+'|'+/\d{1,2}/.source);}</span>function <span class="fstat-no" title="function not covered" >mergeConfigs(</span>parentConfig,childConfig){var res=<span class="cstat-no" title="statement not covered" >extend({},parentConfig),</span>prop;<span class="cstat-no" title="statement not covered" >for(prop in childConfig){<span class="cstat-no" title="statement not covered" >if(hasOwnProp(childConfig,prop)){<span class="cstat-no" title="statement not covered" >if(isObject(parentConfig[prop])&amp;&amp;isObject(childConfig[prop])){<span class="cstat-no" title="statement not covered" >res[prop]={};<span class="cstat-no" title="statement not covered" >e</span>xtend(res[prop],parentConfig[prop]);<span class="cstat-no" title="statement not covered" >e</span>xtend(res[prop],childConfig[prop]);}</span>else <span class="cstat-no" title="statement not covered" >if(childConfig[prop]!=null){<span class="cstat-no" title="statement not covered" >res[prop]=childConfig[prop];}</span>else{<span class="cstat-no" title="statement not covered" >delete res[prop];}</span>}</span></span>}<span class="cstat-no" title="statement not covered" ></span>f</span>or(prop in parentConfig){<span class="cstat-no" title="statement not covered" >if(hasOwnProp(parentConfig,prop)&amp;&amp;!hasOwnProp(childConfig,prop)&amp;&amp;isObject(parentConfig[prop])){// make sure changes to properties don't modify parent config</span></span>
<span class="cstat-no" title="statement not covered" >res[prop]=extend({},res[prop]);}</span>}<span class="cstat-no" title="statement not covered" >return res;}</span>function <span class="fstat-no" title="function not covered" >Locale(</span>config){<span class="cstat-no" title="statement not covered" >if(config!=null){<span class="cstat-no" title="statement not covered" >this.set(config);}</span>}</span>var keys;<span class="cstat-no" title="statement not covered" >if(Object.keys){<span class="cstat-no" title="statement not covered" >keys=Object.keys;}</span>else{<span class="cstat-no" title="statement not covered" >keys=<span class="fstat-no" title="function not covered" >fu</span>nction(obj){var i,res=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(i in obj){<span class="cstat-no" title="statement not covered" >if(hasOwnProp(obj,i)){<span class="cstat-no" title="statement not covered" >res.push(i);}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn res;}</span>;}</span>v</span>ar defaultCalendar=<span class="cstat-no" title="statement not covered" >{sameDay:'[Today at] LT',nextDay:'[Tomorrow at] LT',nextWeek:'dddd [at] LT',lastDay:'[Yesterday at] LT',lastWeek:'[Last] dddd [at] LT',sameElse:'L'};</span>function <span class="fstat-no" title="function not covered" >calendar(</span>key,mom,now){var output=<span class="cstat-no" title="statement not covered" >this._calendar[key]||this._calendar['sameElse'];<span class="cstat-no" title="statement not covered" ></span>return isFunction(output)?output.call(mom,now):output;}</span>function <span class="fstat-no" title="function not covered" >zeroFill(</span>number,targetLength,forceSign){var absNumber=<span class="cstat-no" title="statement not covered" >''+Math.abs(number),</span>zerosToFill=<span class="cstat-no" title="statement not covered" >targetLength-absNumber.length,</span>sign=<span class="cstat-no" title="statement not covered" >number&gt;=0;<span class="cstat-no" title="statement not covered" ></span>return(sign?forceSign?'+':'':'-')+Math.pow(10,Math.max(0,zerosToFill)).toString().substr(1)+absNumber;}</span>var formattingTokens=<span class="cstat-no" title="statement not covered" >/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,</span>localFormattingTokens=<span class="cstat-no" title="statement not covered" >/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,</span>formatFunctions=<span class="cstat-no" title="statement not covered" >{},</span>formatTokenFunctions=<span class="cstat-no" title="statement not covered" >{};</span>// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function <span class="fstat-no" title="function not covered" >addFormatToken(</span>token,padded,ordinal,callback){var func=<span class="cstat-no" title="statement not covered" >callback;<span class="cstat-no" title="statement not covered" ></span>if(typeof callback==='string'){<span class="cstat-no" title="statement not covered" >func=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this[callback]();}</span>;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(token){<span class="cstat-no" title="statement not covered" >formatTokenFunctions[token]=func;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(padded){<span class="cstat-no" title="statement not covered" >formatTokenFunctions[padded[0]]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return zeroFill(func.apply(this,arguments),padded[1],padded[2]);}</span>;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(ordinal){<span class="cstat-no" title="statement not covered" >formatTokenFunctions[ordinal]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.localeData().ordinal(func.apply(this,arguments),token);}</span>;}</span>}</span>function <span class="fstat-no" title="function not covered" >removeFormattingTokens(</span>input){<span class="cstat-no" title="statement not covered" >if(input.match(/\[[\s\S]/)){<span class="cstat-no" title="statement not covered" >return input.replace(/^\[|\]$/g,'');}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn input.replace(/\\/g,'');}</span>function <span class="fstat-no" title="function not covered" >makeFormatFunction(</span>format){var array=<span class="cstat-no" title="statement not covered" >format.match(formattingTokens),</span>i,length;<span class="cstat-no" title="statement not covered" >for(i=0,length=array.length;i&lt;length;i++){<span class="cstat-no" title="statement not covered" >if(formatTokenFunctions[array[i]]){<span class="cstat-no" title="statement not covered" >array[i]=formatTokenFunctions[array[i]];}</span>else{<span class="cstat-no" title="statement not covered" >array[i]=removeFormattingTokens(array[i]);}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn <span class="fstat-no" title="function not covered" >fu</span>nction(mom){var output=<span class="cstat-no" title="statement not covered" >'',</span>i;<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;length;i++){<span class="cstat-no" title="statement not covered" >output+=isFunction(array[i])?array[i].call(mom,format):array[i];}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn output;}</span>;}</span>// format date using native date object
function <span class="fstat-no" title="function not covered" >formatMoment(</span>m,format){<span class="cstat-no" title="statement not covered" >if(!m.isValid()){<span class="cstat-no" title="statement not covered" >return m.localeData().invalidDate();}<span class="cstat-no" title="statement not covered" ></span>f</span>ormat=expandFormat(format,m.localeData());<span class="cstat-no" title="statement not covered" >f</span>ormatFunctions[format]=formatFunctions[format]||makeFormatFunction(format);<span class="cstat-no" title="statement not covered" >r</span>eturn formatFunctions[format](m);}</span>function <span class="fstat-no" title="function not covered" >expandFormat(</span>format,locale){var i=<span class="cstat-no" title="statement not covered" >5;</span>function <span class="fstat-no" title="function not covered" >replaceLongDateFormatTokens(</span>input){<span class="cstat-no" title="statement not covered" >return locale.longDateFormat(input)||input;}<span class="cstat-no" title="statement not covered" ></span>localFormattingTokens.lastIndex=0;<span class="cstat-no" title="statement not covered" >w</span>hile(i&gt;=0&amp;&amp;localFormattingTokens.test(format)){<span class="cstat-no" title="statement not covered" >format=format.replace(localFormattingTokens,replaceLongDateFormatTokens);<span class="cstat-no" title="statement not covered" >l</span>ocalFormattingTokens.lastIndex=0;<span class="cstat-no" title="statement not covered" >i</span>-=1;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn format;}</span>var defaultLongDateFormat=<span class="cstat-no" title="statement not covered" >{LTS:'h:mm:ss A',LT:'h:mm A',L:'MM/DD/YYYY',LL:'MMMM D, YYYY',LLL:'MMMM D, YYYY h:mm A',LLLL:'dddd, MMMM D, YYYY h:mm A'};</span>function <span class="fstat-no" title="function not covered" >longDateFormat(</span>key){var format=<span class="cstat-no" title="statement not covered" >this._longDateFormat[key],</span>formatUpper=<span class="cstat-no" title="statement not covered" >this._longDateFormat[key.toUpperCase()];<span class="cstat-no" title="statement not covered" ></span>if(format||!formatUpper){<span class="cstat-no" title="statement not covered" >return format;}<span class="cstat-no" title="statement not covered" ></span>t</span>his._longDateFormat[key]=formatUpper.match(formattingTokens).map(<span class="fstat-no" title="function not covered" >fu</span>nction(tok){<span class="cstat-no" title="statement not covered" >if(tok==='MMMM'||tok==='MM'||tok==='DD'||tok==='dddd'){<span class="cstat-no" title="statement not covered" >return tok.slice(1);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn tok;}</span>).join('');<span class="cstat-no" title="statement not covered" >r</span>eturn this._longDateFormat[key];}</span>var defaultInvalidDate=<span class="cstat-no" title="statement not covered" >'Invalid date';</span>function <span class="fstat-no" title="function not covered" >invalidDate(</span>){<span class="cstat-no" title="statement not covered" >return this._invalidDate;}</span>var defaultOrdinal=<span class="cstat-no" title="statement not covered" >'%d',</span>defaultDayOfMonthOrdinalParse=<span class="cstat-no" title="statement not covered" >/\d{1,2}/;</span>function <span class="fstat-no" title="function not covered" >ordinal(</span>number){<span class="cstat-no" title="statement not covered" >return this._ordinal.replace('%d',number);}</span>var defaultRelativeTime=<span class="cstat-no" title="statement not covered" >{future:'in %s',past:'%s ago',s:'a few seconds',ss:'%d seconds',m:'a minute',mm:'%d minutes',h:'an hour',hh:'%d hours',d:'a day',dd:'%d days',w:'a week',ww:'%d weeks',M:'a month',MM:'%d months',y:'a year',yy:'%d years'};</span>function <span class="fstat-no" title="function not covered" >relativeTime(</span>number,withoutSuffix,string,isFuture){var output=<span class="cstat-no" title="statement not covered" >this._relativeTime[string];<span class="cstat-no" title="statement not covered" ></span>return isFunction(output)?output(number,withoutSuffix,string,isFuture):output.replace(/%d/i,number);}</span>function <span class="fstat-no" title="function not covered" >pastFuture(</span>diff,output){var format=<span class="cstat-no" title="statement not covered" >this._relativeTime[diff&gt;0?'future':'past'];<span class="cstat-no" title="statement not covered" ></span>return isFunction(format)?format(output):format.replace(/%s/i,output);}</span>var aliases=<span class="cstat-no" title="statement not covered" >{};</span>function <span class="fstat-no" title="function not covered" >addUnitAlias(</span>unit,shorthand){var lowerCase=<span class="cstat-no" title="statement not covered" >unit.toLowerCase();<span class="cstat-no" title="statement not covered" ></span>aliases[lowerCase]=aliases[lowerCase+'s']=aliases[shorthand]=unit;}</span>function <span class="fstat-no" title="function not covered" >normalizeUnits(</span>units){<span class="cstat-no" title="statement not covered" >return typeof units==='string'?aliases[units]||aliases[units.toLowerCase()]:undefined;}</span>function <span class="fstat-no" title="function not covered" >normalizeObjectUnits(</span>inputObject){var normalizedInput=<span class="cstat-no" title="statement not covered" >{},</span>normalizedProp,prop;<span class="cstat-no" title="statement not covered" >for(prop in inputObject){<span class="cstat-no" title="statement not covered" >if(hasOwnProp(inputObject,prop)){<span class="cstat-no" title="statement not covered" >normalizedProp=normalizeUnits(prop);<span class="cstat-no" title="statement not covered" >i</span>f(normalizedProp){<span class="cstat-no" title="statement not covered" >normalizedInput[normalizedProp]=inputObject[prop];}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn normalizedInput;}</span>var priorities=<span class="cstat-no" title="statement not covered" >{};</span>function <span class="fstat-no" title="function not covered" >addUnitPriority(</span>unit,priority){<span class="cstat-no" title="statement not covered" >priorities[unit]=priority;}</span>function <span class="fstat-no" title="function not covered" >getPrioritizedUnits(</span>unitsObj){var units=<span class="cstat-no" title="statement not covered" >[],</span>u;<span class="cstat-no" title="statement not covered" >for(u in unitsObj){<span class="cstat-no" title="statement not covered" >if(hasOwnProp(unitsObj,u)){<span class="cstat-no" title="statement not covered" >units.push({unit:u,priority:priorities[u]});}</span>}<span class="cstat-no" title="statement not covered" ></span>u</span>nits.sort(<span class="fstat-no" title="function not covered" >fu</span>nction(a,b){<span class="cstat-no" title="statement not covered" >return a.priority-b.priority;}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn units;}</span>function <span class="fstat-no" title="function not covered" >isLeapYear(</span>year){<span class="cstat-no" title="statement not covered" >return year%4===0&amp;&amp;year%100!==0||year%400===0;}</span>function <span class="fstat-no" title="function not covered" >absFloor(</span>number){<span class="cstat-no" title="statement not covered" >if(number&lt;0){// -0 -&gt; 0</span>
<span class="cstat-no" title="statement not covered" >return Math.ceil(number)||0;}</span>else{<span class="cstat-no" title="statement not covered" >return Math.floor(number);}</span>}function <span class="fstat-no" title="function not covered" >toInt(</span>argumentForCoercion){var coercedNumber=<span class="cstat-no" title="statement not covered" >+argumentForCoercion,</span>value=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(coercedNumber!==0&amp;&amp;isFinite(coercedNumber)){<span class="cstat-no" title="statement not covered" >value=absFloor(coercedNumber);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn value;}</span>function <span class="fstat-no" title="function not covered" >makeGetSet(</span>unit,keepTime){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(value){<span class="cstat-no" title="statement not covered" >if(value!=null){<span class="cstat-no" title="statement not covered" >set$1(this,unit,value);<span class="cstat-no" title="statement not covered" >h</span>ooks.updateOffset(this,keepTime);<span class="cstat-no" title="statement not covered" >r</span>eturn this;}</span>else{<span class="cstat-no" title="statement not covered" >return get(this,unit);}</span>}</span>;}</span>function <span class="fstat-no" title="function not covered" >get(</span>mom,unit){<span class="cstat-no" title="statement not covered" >return mom.isValid()?mom._d['get'+(mom._isUTC?'UTC':'')+unit]():NaN;}</span>function <span class="fstat-no" title="function not covered" >set$1(</span>mom,unit,value){<span class="cstat-no" title="statement not covered" >if(mom.isValid()&amp;&amp;!isNaN(value)){<span class="cstat-no" title="statement not covered" >if(unit==='FullYear'&amp;&amp;isLeapYear(mom.year())&amp;&amp;mom.month()===1&amp;&amp;mom.date()===29){<span class="cstat-no" title="statement not covered" >value=toInt(value);<span class="cstat-no" title="statement not covered" >m</span>om._d['set'+(mom._isUTC?'UTC':'')+unit](value,mom.month(),daysInMonth(value,mom.month()));}</span>else{<span class="cstat-no" title="statement not covered" >mom._d['set'+(mom._isUTC?'UTC':'')+unit](value);}</span>}</span>}</span>// MOMENTS
function <span class="fstat-no" title="function not covered" >stringGet(</span>units){<span class="cstat-no" title="statement not covered" >units=normalizeUnits(units);<span class="cstat-no" title="statement not covered" >i</span>f(isFunction(this[units])){<span class="cstat-no" title="statement not covered" >return this[units]();}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this;}</span>function <span class="fstat-no" title="function not covered" >stringSet(</span>units,value){<span class="cstat-no" title="statement not covered" >if(typeof units==='object'){<span class="cstat-no" title="statement not covered" >units=normalizeObjectUnits(units);v</span>ar prioritized=<span class="cstat-no" title="statement not covered" >getPrioritizedUnits(units),</span>i;<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;prioritized.length;i++){<span class="cstat-no" title="statement not covered" >this[prioritized[i].unit](units[prioritized[i].unit]);}</span>}</span>else{<span class="cstat-no" title="statement not covered" >units=normalizeUnits(units);<span class="cstat-no" title="statement not covered" >i</span>f(isFunction(this[units])){<span class="cstat-no" title="statement not covered" >return this[units](value);}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this;}</span>var match1=<span class="cstat-no" title="statement not covered" >/\d/,</span>//       0 - 9
match2=<span class="cstat-no" title="statement not covered" >/\d\d/,</span>//      00 - 99
match3=<span class="cstat-no" title="statement not covered" >/\d{3}/,</span>//     000 - 999
match4=<span class="cstat-no" title="statement not covered" >/\d{4}/,</span>//    0000 - 9999
match6=<span class="cstat-no" title="statement not covered" >/[+-]?\d{6}/,</span>// -999999 - 999999
match1to2=<span class="cstat-no" title="statement not covered" >/\d\d?/,</span>//       0 - 99
match3to4=<span class="cstat-no" title="statement not covered" >/\d\d\d\d?/,</span>//     999 - 9999
match5to6=<span class="cstat-no" title="statement not covered" >/\d\d\d\d\d\d?/,</span>//   99999 - 999999
match1to3=<span class="cstat-no" title="statement not covered" >/\d{1,3}/,</span>//       0 - 999
match1to4=<span class="cstat-no" title="statement not covered" >/\d{1,4}/,</span>//       0 - 9999
match1to6=<span class="cstat-no" title="statement not covered" >/[+-]?\d{1,6}/,</span>// -999999 - 999999
matchUnsigned=<span class="cstat-no" title="statement not covered" >/\d+/,</span>//       0 - inf
matchSigned=<span class="cstat-no" title="statement not covered" >/[+-]?\d+/,</span>//    -inf - inf
matchOffset=<span class="cstat-no" title="statement not covered" >/Z|[+-]\d\d:?\d\d/gi,</span>// +00:00 -00:00 +0000 -0000 or Z
matchShortOffset=<span class="cstat-no" title="statement not covered" >/Z|[+-]\d\d(?::?\d\d)?/gi,</span>// +00 -00 +00:00 -00:00 +0000 -0000 or Z
matchTimestamp=<span class="cstat-no" title="statement not covered" >/[+-]?\d+(\.\d{1,3})?/,</span>// 123456789 123456789.123
// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
matchWord=<span class="cstat-no" title="statement not covered" >/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,</span>regexes;<span class="cstat-no" title="statement not covered" >regexes={};f</span>unction <span class="fstat-no" title="function not covered" >addRegexToken(</span>token,regex,strictRegex){<span class="cstat-no" title="statement not covered" >regexes[token]=isFunction(regex)?regex:<span class="fstat-no" title="function not covered" >fu</span>nction(isStrict,localeData){<span class="cstat-no" title="statement not covered" >return isStrict&amp;&amp;strictRegex?strictRegex:regex;}</span>;}</span>function <span class="fstat-no" title="function not covered" >getParseRegexForToken(</span>token,config){<span class="cstat-no" title="statement not covered" >if(!hasOwnProp(regexes,token)){<span class="cstat-no" title="statement not covered" >return new RegExp(unescapeFormat(token));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn regexes[token](config._strict,config._locale);}</span>// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function <span class="fstat-no" title="function not covered" >unescapeFormat(</span>s){<span class="cstat-no" title="statement not covered" >return regexEscape(s.replace('\\','').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,<span class="fstat-no" title="function not covered" >fu</span>nction(matched,p1,p2,p3,p4){<span class="cstat-no" title="statement not covered" >return p1||p2||p3||p4;}</span>));}</span>function <span class="fstat-no" title="function not covered" >regexEscape(</span>s){<span class="cstat-no" title="statement not covered" >return s.replace(/[-\/\\^$*+?.()|[\]{}]/g,'\\$&amp;');}</span>var tokens=<span class="cstat-no" title="statement not covered" >{};</span>function <span class="fstat-no" title="function not covered" >addParseToken(</span>token,callback){var i,func=<span class="cstat-no" title="statement not covered" >callback;<span class="cstat-no" title="statement not covered" ></span>if(typeof token==='string'){<span class="cstat-no" title="statement not covered" >token=[token];}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isNumber(callback)){<span class="cstat-no" title="statement not covered" >func=<span class="fstat-no" title="function not covered" >fu</span>nction(input,array){<span class="cstat-no" title="statement not covered" >array[callback]=toInt(input);}</span>;}<span class="cstat-no" title="statement not covered" ></span>f</span>or(i=0;i&lt;token.length;i++){<span class="cstat-no" title="statement not covered" >tokens[token[i]]=func;}</span>}</span>function <span class="fstat-no" title="function not covered" >addWeekParseToken(</span>token,callback){<span class="cstat-no" title="statement not covered" >addParseToken(token,<span class="fstat-no" title="function not covered" >fu</span>nction(input,array,config,token){<span class="cstat-no" title="statement not covered" >config._w=config._w||{};<span class="cstat-no" title="statement not covered" >c</span>allback(input,config._w,config,token);}</span>);}</span>function <span class="fstat-no" title="function not covered" >addTimeToArrayFromToken(</span>token,input,config){<span class="cstat-no" title="statement not covered" >if(input!=null&amp;&amp;hasOwnProp(tokens,token)){<span class="cstat-no" title="statement not covered" >tokens[token](input,config._a,config,token);}</span>}</span>var YEAR=<span class="cstat-no" title="statement not covered" >0,</span>MONTH=<span class="cstat-no" title="statement not covered" >1,</span>DATE=<span class="cstat-no" title="statement not covered" >2,</span>HOUR=<span class="cstat-no" title="statement not covered" >3,</span>MINUTE=<span class="cstat-no" title="statement not covered" >4,</span>SECOND=<span class="cstat-no" title="statement not covered" >5,</span>MILLISECOND=<span class="cstat-no" title="statement not covered" >6,</span>WEEK=<span class="cstat-no" title="statement not covered" >7,</span>WEEKDAY=<span class="cstat-no" title="statement not covered" >8;</span>function <span class="fstat-no" title="function not covered" >mod(</span>n,x){<span class="cstat-no" title="statement not covered" >return(n%x+x)%x;}</span>var indexOf;<span class="cstat-no" title="statement not covered" >if(Array.prototype.indexOf){<span class="cstat-no" title="statement not covered" >indexOf=Array.prototype.indexOf;}</span>else{<span class="cstat-no" title="statement not covered" >indexOf=<span class="fstat-no" title="function not covered" >fu</span>nction(o){// I know</span></span>
var i;<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;this.length;++i){<span class="cstat-no" title="statement not covered" >if(this[i]===o){<span class="cstat-no" title="statement not covered" >return i;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn-1;}</span>;}function <span class="fstat-no" title="function not covered" >daysInMonth(</span>year,month){<span class="cstat-no" title="statement not covered" >if(isNaN(year)||isNaN(month)){<span class="cstat-no" title="statement not covered" >return NaN;}</span>v</span>ar modMonth=<span class="cstat-no" title="statement not covered" >mod(month,12);<span class="cstat-no" title="statement not covered" ></span>year+=(month-modMonth)/12;<span class="cstat-no" title="statement not covered" >r</span>eturn modMonth===1?isLeapYear(year)?29:28:31-modMonth%7%2;}</span>// FORMATTING
<span class="cstat-no" title="statement not covered" >addFormatToken('M',['MM',2],'Mo',<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.month()+1;}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('MMM',0,0,<span class="fstat-no" title="function not covered" >fu</span>nction(format){<span class="cstat-no" title="statement not covered" >return this.localeData().monthsShort(this,format);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('MMMM',0,0,<span class="fstat-no" title="function not covered" >fu</span>nction(format){<span class="cstat-no" title="statement not covered" >return this.localeData().months(this,format);}</span>);/</span>/ ALIASES
<span class="cstat-no" title="statement not covered" >addUnitAlias('month','M');/</span>/ PRIORITY
<span class="cstat-no" title="statement not covered" >addUnitPriority('month',8);/</span>/ PARSING
<span class="cstat-no" title="statement not covered" >addRegexToken('M',match1to2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('MM',match1to2,match2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('MMM',<span class="fstat-no" title="function not covered" >fu</span>nction(isStrict,locale){<span class="cstat-no" title="statement not covered" >return locale.monthsShortRegex(isStrict);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('MMMM',<span class="fstat-no" title="function not covered" >fu</span>nction(isStrict,locale){<span class="cstat-no" title="statement not covered" >return locale.monthsRegex(isStrict);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken(['M','MM'],<span class="fstat-no" title="function not covered" >fu</span>nction(input,array){<span class="cstat-no" title="statement not covered" >array[MONTH]=toInt(input)-1;}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken(['MMM','MMMM'],<span class="fstat-no" title="function not covered" >fu</span>nction(input,array,config,token){var month=<span class="cstat-no" title="statement not covered" >config._locale.monthsParse(input,token,config._strict);</span>// if we didn't find a month name, mark the date as invalid.</span>
<span class="cstat-no" title="statement not covered" >if(month!=null){<span class="cstat-no" title="statement not covered" >array[MONTH]=month;}</span>else{<span class="cstat-no" title="statement not covered" >getParsingFlags(config).invalidMonth=input;}</span>}</span>);// LOCALES
var defaultLocaleMonths=<span class="cstat-no" title="statement not covered" >'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),</span>defaultLocaleMonthsShort=<span class="cstat-no" title="statement not covered" >'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),</span>MONTHS_IN_FORMAT=<span class="cstat-no" title="statement not covered" >/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,</span>defaultMonthsShortRegex=<span class="cstat-no" title="statement not covered" >matchWord,</span>defaultMonthsRegex=<span class="cstat-no" title="statement not covered" >matchWord;</span>function <span class="fstat-no" title="function not covered" >localeMonths(</span>m,format){<span class="cstat-no" title="statement not covered" >if(!m){<span class="cstat-no" title="statement not covered" >return isArray(this._months)?this._months:this._months['standalone'];}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn isArray(this._months)?this._months[m.month()]:this._months[(this._months.isFormat||MONTHS_IN_FORMAT).test(format)?'format':'standalone'][m.month()];}</span>function <span class="fstat-no" title="function not covered" >localeMonthsShort(</span>m,format){<span class="cstat-no" title="statement not covered" >if(!m){<span class="cstat-no" title="statement not covered" >return isArray(this._monthsShort)?this._monthsShort:this._monthsShort['standalone'];}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn isArray(this._monthsShort)?this._monthsShort[m.month()]:this._monthsShort[MONTHS_IN_FORMAT.test(format)?'format':'standalone'][m.month()];}</span>function <span class="fstat-no" title="function not covered" >handleStrictParse(</span>monthName,format,strict){var i,ii,mom,llc=<span class="cstat-no" title="statement not covered" >monthName.toLocaleLowerCase();<span class="cstat-no" title="statement not covered" ></span>if(!this._monthsParse){// this is not used</span>
<span class="cstat-no" title="statement not covered" >this._monthsParse=[];<span class="cstat-no" title="statement not covered" >t</span>his._longMonthsParse=[];<span class="cstat-no" title="statement not covered" >t</span>his._shortMonthsParse=[];<span class="cstat-no" title="statement not covered" >f</span>or(i=0;i&lt;12;++i){<span class="cstat-no" title="statement not covered" >mom=createUTC([2000,i]);<span class="cstat-no" title="statement not covered" >t</span>his._shortMonthsParse[i]=this.monthsShort(mom,'').toLocaleLowerCase();<span class="cstat-no" title="statement not covered" >t</span>his._longMonthsParse[i]=this.months(mom,'').toLocaleLowerCase();}</span>}<span class="cstat-no" title="statement not covered" ></span>if(strict){<span class="cstat-no" title="statement not covered" >if(format==='MMM'){<span class="cstat-no" title="statement not covered" >ii=indexOf.call(this._shortMonthsParse,llc);<span class="cstat-no" title="statement not covered" >r</span>eturn ii!==-1?ii:null;}</span>else{<span class="cstat-no" title="statement not covered" >ii=indexOf.call(this._longMonthsParse,llc);<span class="cstat-no" title="statement not covered" >r</span>eturn ii!==-1?ii:null;}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(format==='MMM'){<span class="cstat-no" title="statement not covered" >ii=indexOf.call(this._shortMonthsParse,llc);<span class="cstat-no" title="statement not covered" >i</span>f(ii!==-1){<span class="cstat-no" title="statement not covered" >return ii;}<span class="cstat-no" title="statement not covered" ></span>i</span>i=indexOf.call(this._longMonthsParse,llc);<span class="cstat-no" title="statement not covered" >r</span>eturn ii!==-1?ii:null;}</span>else{<span class="cstat-no" title="statement not covered" >ii=indexOf.call(this._longMonthsParse,llc);<span class="cstat-no" title="statement not covered" >i</span>f(ii!==-1){<span class="cstat-no" title="statement not covered" >return ii;}<span class="cstat-no" title="statement not covered" ></span>i</span>i=indexOf.call(this._shortMonthsParse,llc);<span class="cstat-no" title="statement not covered" >r</span>eturn ii!==-1?ii:null;}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >localeMonthsParse(</span>monthName,format,strict){var i,mom,regex;<span class="cstat-no" title="statement not covered" >if(this._monthsParseExact){<span class="cstat-no" title="statement not covered" >return handleStrictParse.call(this,monthName,format,strict);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this._monthsParse){<span class="cstat-no" title="statement not covered" >this._monthsParse=[];<span class="cstat-no" title="statement not covered" >t</span>his._longMonthsParse=[];<span class="cstat-no" title="statement not covered" >t</span>his._shortMonthsParse=[];}</span>/</span>/ TODO: add sorting
// Sorting makes sure if one month (or abbr) is a prefix of another
// see sorting in computeMonthsParse
<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;12;i++){// make the regex if we don't have it already</span>
<span class="cstat-no" title="statement not covered" >mom=createUTC([2000,i]);<span class="cstat-no" title="statement not covered" >i</span>f(strict&amp;&amp;!this._longMonthsParse[i]){<span class="cstat-no" title="statement not covered" >this._longMonthsParse[i]=new RegExp('^'+this.months(mom,'').replace('.','')+'$','i');<span class="cstat-no" title="statement not covered" >t</span>his._shortMonthsParse[i]=new RegExp('^'+this.monthsShort(mom,'').replace('.','')+'$','i');}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!strict&amp;&amp;!this._monthsParse[i]){<span class="cstat-no" title="statement not covered" >regex='^'+this.months(mom,'')+'|^'+this.monthsShort(mom,'');<span class="cstat-no" title="statement not covered" >t</span>his._monthsParse[i]=new RegExp(regex.replace('.',''),'i');}</span>/</span>/ test the regex
<span class="cstat-no" title="statement not covered" >if(strict&amp;&amp;format==='MMMM'&amp;&amp;this._longMonthsParse[i].test(monthName)){<span class="cstat-no" title="statement not covered" >return i;}</span>else <span class="cstat-no" title="statement not covered" >if(strict&amp;&amp;format==='MMM'&amp;&amp;this._shortMonthsParse[i].test(monthName)){<span class="cstat-no" title="statement not covered" >return i;}</span>else <span class="cstat-no" title="statement not covered" >if(!strict&amp;&amp;this._monthsParse[i].test(monthName)){<span class="cstat-no" title="statement not covered" >return i;}</span>}</span></span></span>}// MOMENTS
function <span class="fstat-no" title="function not covered" >setMonth(</span>mom,value){var dayOfMonth;<span class="cstat-no" title="statement not covered" >if(!mom.isValid()){// No op</span>
<span class="cstat-no" title="statement not covered" >return mom;}<span class="cstat-no" title="statement not covered" ></span>if(typeof value==='string'){<span class="cstat-no" title="statement not covered" >if(/^\d+$/.test(value)){<span class="cstat-no" title="statement not covered" >value=toInt(value);}</span>else{<span class="cstat-no" title="statement not covered" >value=mom.localeData().monthsParse(value);/</span>/ TODO: Another silent failure?</span></span>
<span class="cstat-no" title="statement not covered" >if(!isNumber(value)){<span class="cstat-no" title="statement not covered" >return mom;}</span>}</span>}<span class="cstat-no" title="statement not covered" >dayOfMonth=Math.min(mom.date(),daysInMonth(mom.year(),value));<span class="cstat-no" title="statement not covered" >m</span>om._d['set'+(mom._isUTC?'UTC':'')+'Month'](value,dayOfMonth);<span class="cstat-no" title="statement not covered" >r</span>eturn mom;}</span>function <span class="fstat-no" title="function not covered" >getSetMonth(</span>value){<span class="cstat-no" title="statement not covered" >if(value!=null){<span class="cstat-no" title="statement not covered" >setMonth(this,value);<span class="cstat-no" title="statement not covered" >h</span>ooks.updateOffset(this,true);<span class="cstat-no" title="statement not covered" >r</span>eturn this;}</span>else{<span class="cstat-no" title="statement not covered" >return get(this,'Month');}</span>}</span>function <span class="fstat-no" title="function not covered" >getDaysInMonth(</span>){<span class="cstat-no" title="statement not covered" >return daysInMonth(this.year(),this.month());}</span>function <span class="fstat-no" title="function not covered" >monthsShortRegex(</span>isStrict){<span class="cstat-no" title="statement not covered" >if(this._monthsParseExact){<span class="cstat-no" title="statement not covered" >if(!hasOwnProp(this,'_monthsRegex')){<span class="cstat-no" title="statement not covered" >computeMonthsParse.call(this);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isStrict){<span class="cstat-no" title="statement not covered" >return this._monthsShortStrictRegex;}</span>else{<span class="cstat-no" title="statement not covered" >return this._monthsShortRegex;}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(!hasOwnProp(this,'_monthsShortRegex')){<span class="cstat-no" title="statement not covered" >this._monthsShortRegex=defaultMonthsShortRegex;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._monthsShortStrictRegex&amp;&amp;isStrict?this._monthsShortStrictRegex:this._monthsShortRegex;}</span>}</span>function <span class="fstat-no" title="function not covered" >monthsRegex(</span>isStrict){<span class="cstat-no" title="statement not covered" >if(this._monthsParseExact){<span class="cstat-no" title="statement not covered" >if(!hasOwnProp(this,'_monthsRegex')){<span class="cstat-no" title="statement not covered" >computeMonthsParse.call(this);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isStrict){<span class="cstat-no" title="statement not covered" >return this._monthsStrictRegex;}</span>else{<span class="cstat-no" title="statement not covered" >return this._monthsRegex;}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(!hasOwnProp(this,'_monthsRegex')){<span class="cstat-no" title="statement not covered" >this._monthsRegex=defaultMonthsRegex;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._monthsStrictRegex&amp;&amp;isStrict?this._monthsStrictRegex:this._monthsRegex;}</span>}</span>function <span class="fstat-no" title="function not covered" >computeMonthsParse(</span>){function <span class="fstat-no" title="function not covered" >cmpLenRev(</span>a,b){<span class="cstat-no" title="statement not covered" >return b.length-a.length;}</span>var shortPieces=<span class="cstat-no" title="statement not covered" >[],</span>longPieces=<span class="cstat-no" title="statement not covered" >[],</span>mixedPieces=<span class="cstat-no" title="statement not covered" >[],</span>i,mom;<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;12;i++){// make the regex if we don't have it already</span>
<span class="cstat-no" title="statement not covered" >mom=createUTC([2000,i]);<span class="cstat-no" title="statement not covered" >s</span>hortPieces.push(this.monthsShort(mom,''));<span class="cstat-no" title="statement not covered" >l</span>ongPieces.push(this.months(mom,''));<span class="cstat-no" title="statement not covered" >m</span>ixedPieces.push(this.months(mom,''));<span class="cstat-no" title="statement not covered" >m</span>ixedPieces.push(this.monthsShort(mom,''));}</span>// Sorting makes sure if one month (or abbr) is a prefix of another it
// will match the longer piece.
<span class="cstat-no" title="statement not covered" >shortPieces.sort(cmpLenRev);<span class="cstat-no" title="statement not covered" >l</span>ongPieces.sort(cmpLenRev);<span class="cstat-no" title="statement not covered" >m</span>ixedPieces.sort(cmpLenRev);<span class="cstat-no" title="statement not covered" >f</span>or(i=0;i&lt;12;i++){<span class="cstat-no" title="statement not covered" >shortPieces[i]=regexEscape(shortPieces[i]);<span class="cstat-no" title="statement not covered" >l</span>ongPieces[i]=regexEscape(longPieces[i]);}<span class="cstat-no" title="statement not covered" ></span>f</span>or(i=0;i&lt;24;i++){<span class="cstat-no" title="statement not covered" >mixedPieces[i]=regexEscape(mixedPieces[i]);}<span class="cstat-no" title="statement not covered" ></span>t</span>his._monthsRegex=new RegExp('^('+mixedPieces.join('|')+')','i');<span class="cstat-no" title="statement not covered" >t</span>his._monthsShortRegex=this._monthsRegex;<span class="cstat-no" title="statement not covered" >t</span>his._monthsStrictRegex=new RegExp('^('+longPieces.join('|')+')','i');<span class="cstat-no" title="statement not covered" >t</span>his._monthsShortStrictRegex=new RegExp('^('+shortPieces.join('|')+')','i');}</span>// FORMATTING
<span class="cstat-no" title="statement not covered" >addFormatToken('Y',0,0,<span class="fstat-no" title="function not covered" >fu</span>nction(){var y=<span class="cstat-no" title="statement not covered" >this.year();<span class="cstat-no" title="statement not covered" ></span>return y&lt;=9999?zeroFill(y,4):'+'+y;}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken(0,['YY',2],0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.year()%100;}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken(0,['YYYY',4],0,'year');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken(0,['YYYYY',5],0,'year');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken(0,['YYYYYY',6,true],0,'year');/</span>/ ALIASES
<span class="cstat-no" title="statement not covered" >addUnitAlias('year','y');/</span>/ PRIORITIES
<span class="cstat-no" title="statement not covered" >addUnitPriority('year',1);/</span>/ PARSING
<span class="cstat-no" title="statement not covered" >addRegexToken('Y',matchSigned);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('YY',match1to2,match2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('YYYY',match1to4,match4);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('YYYYY',match1to6,match6);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('YYYYYY',match1to6,match6);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken(['YYYYY','YYYYYY'],YEAR);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken('YYYY',<span class="fstat-no" title="function not covered" >fu</span>nction(input,array){<span class="cstat-no" title="statement not covered" >array[YEAR]=input.length===2?hooks.parseTwoDigitYear(input):toInt(input);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken('YY',<span class="fstat-no" title="function not covered" >fu</span>nction(input,array){<span class="cstat-no" title="statement not covered" >array[YEAR]=hooks.parseTwoDigitYear(input);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken('Y',<span class="fstat-no" title="function not covered" >fu</span>nction(input,array){<span class="cstat-no" title="statement not covered" >array[YEAR]=parseInt(input,10);}</span>);/</span>/ HELPERS
function <span class="fstat-no" title="function not covered" >daysInYear(</span>year){<span class="cstat-no" title="statement not covered" >return isLeapYear(year)?366:365;}</span>// HOOKS
<span class="cstat-no" title="statement not covered" >hooks.parseTwoDigitYear=<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return toInt(input)+(toInt(input)&gt;68?1900:2000);}</span>;/</span>/ MOMENTS
var getSetYear=<span class="cstat-no" title="statement not covered" >makeGetSet('FullYear',true);</span>function <span class="fstat-no" title="function not covered" >getIsLeapYear(</span>){<span class="cstat-no" title="statement not covered" >return isLeapYear(this.year());}</span>function <span class="fstat-no" title="function not covered" >createDate(</span>y,m,d,h,M,s,ms){// can't just apply() to create a date:
// https://stackoverflow.com/q/181348
var date;// the date constructor remaps years 0-99 to 1900-1999
<span class="cstat-no" title="statement not covered" >if(y&lt;100&amp;&amp;y&gt;=0){// preserve leap years using a full 400 year cycle, then reset</span>
<span class="cstat-no" title="statement not covered" >date=new Date(y+400,m,d,h,M,s,ms);<span class="cstat-no" title="statement not covered" >i</span>f(isFinite(date.getFullYear())){<span class="cstat-no" title="statement not covered" >date.setFullYear(y);}</span>}</span>else{<span class="cstat-no" title="statement not covered" >date=new Date(y,m,d,h,M,s,ms);}<span class="cstat-no" title="statement not covered" ></span>return date;}</span>function <span class="fstat-no" title="function not covered" >createUTCDate(</span>y){var date,args;// the Date.UTC function remaps years 0-99 to 1900-1999
<span class="cstat-no" title="statement not covered" >if(y&lt;100&amp;&amp;y&gt;=0){<span class="cstat-no" title="statement not covered" >args=Array.prototype.slice.call(arguments);/</span>/ preserve leap years using a full 400 year cycle, then reset</span>
<span class="cstat-no" title="statement not covered" >args[0]=y+400;<span class="cstat-no" title="statement not covered" >d</span>ate=new Date(Date.UTC.apply(null,args));<span class="cstat-no" title="statement not covered" >i</span>f(isFinite(date.getUTCFullYear())){<span class="cstat-no" title="statement not covered" >date.setUTCFullYear(y);}</span>}</span>else{<span class="cstat-no" title="statement not covered" >date=new Date(Date.UTC.apply(null,arguments));}<span class="cstat-no" title="statement not covered" ></span>return date;}</span>// start-of-first-week - start-of-year
function <span class="fstat-no" title="function not covered" >firstWeekOffset(</span>year,dow,doy){var// first-week day -- which january is always in the first week (4 for iso, 1 for other)
fwd=<span class="cstat-no" title="statement not covered" >7+dow-doy,</span>// first-week day local weekday -- which local weekday is fwd
fwdlw=<span class="cstat-no" title="statement not covered" >(7+createUTCDate(year,0,fwd).getUTCDay()-dow)%7;<span class="cstat-no" title="statement not covered" ></span>return-fwdlw+fwd-1;}</span>// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function <span class="fstat-no" title="function not covered" >dayOfYearFromWeeks(</span>year,week,weekday,dow,doy){var localWeekday=<span class="cstat-no" title="statement not covered" >(7+weekday-dow)%7,</span>weekOffset=<span class="cstat-no" title="statement not covered" >firstWeekOffset(year,dow,doy),</span>dayOfYear=<span class="cstat-no" title="statement not covered" >1+7*(week-1)+localWeekday+weekOffset,</span>resYear,resDayOfYear;<span class="cstat-no" title="statement not covered" >if(dayOfYear&lt;=0){<span class="cstat-no" title="statement not covered" >resYear=year-1;<span class="cstat-no" title="statement not covered" >r</span>esDayOfYear=daysInYear(resYear)+dayOfYear;}</span>else <span class="cstat-no" title="statement not covered" >if(dayOfYear&gt;daysInYear(year)){<span class="cstat-no" title="statement not covered" >resYear=year+1;<span class="cstat-no" title="statement not covered" >r</span>esDayOfYear=dayOfYear-daysInYear(year);}</span>else{<span class="cstat-no" title="statement not covered" >resYear=year;<span class="cstat-no" title="statement not covered" >r</span>esDayOfYear=dayOfYear;}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn{year:resYear,dayOfYear:resDayOfYear};}</span>function <span class="fstat-no" title="function not covered" >weekOfYear(</span>mom,dow,doy){var weekOffset=<span class="cstat-no" title="statement not covered" >firstWeekOffset(mom.year(),dow,doy),</span>week=<span class="cstat-no" title="statement not covered" >Math.floor((mom.dayOfYear()-weekOffset-1)/7)+1,</span>resWeek,resYear;<span class="cstat-no" title="statement not covered" >if(week&lt;1){<span class="cstat-no" title="statement not covered" >resYear=mom.year()-1;<span class="cstat-no" title="statement not covered" >r</span>esWeek=week+weeksInYear(resYear,dow,doy);}</span>else <span class="cstat-no" title="statement not covered" >if(week&gt;weeksInYear(mom.year(),dow,doy)){<span class="cstat-no" title="statement not covered" >resWeek=week-weeksInYear(mom.year(),dow,doy);<span class="cstat-no" title="statement not covered" >r</span>esYear=mom.year()+1;}</span>else{<span class="cstat-no" title="statement not covered" >resYear=mom.year();<span class="cstat-no" title="statement not covered" >r</span>esWeek=week;}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn{week:resWeek,year:resYear};}</span>function <span class="fstat-no" title="function not covered" >weeksInYear(</span>year,dow,doy){var weekOffset=<span class="cstat-no" title="statement not covered" >firstWeekOffset(year,dow,doy),</span>weekOffsetNext=<span class="cstat-no" title="statement not covered" >firstWeekOffset(year+1,dow,doy);<span class="cstat-no" title="statement not covered" ></span>return(daysInYear(year)-weekOffset+weekOffsetNext)/7;}</span>// FORMATTING
<span class="cstat-no" title="statement not covered" >addFormatToken('w',['ww',2],'wo','week');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('W',['WW',2],'Wo','isoWeek');/</span>/ ALIASES
<span class="cstat-no" title="statement not covered" >addUnitAlias('week','w');<span class="cstat-no" title="statement not covered" >a</span>ddUnitAlias('isoWeek','W');/</span>/ PRIORITIES
<span class="cstat-no" title="statement not covered" >addUnitPriority('week',5);<span class="cstat-no" title="statement not covered" >a</span>ddUnitPriority('isoWeek',5);/</span>/ PARSING
<span class="cstat-no" title="statement not covered" >addRegexToken('w',match1to2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('ww',match1to2,match2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('W',match1to2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('WW',match1to2,match2);<span class="cstat-no" title="statement not covered" >a</span>ddWeekParseToken(['w','ww','W','WW'],<span class="fstat-no" title="function not covered" >fu</span>nction(input,week,config,token){<span class="cstat-no" title="statement not covered" >week[token.substr(0,1)]=toInt(input);}</span>);/</span>/ HELPERS
// LOCALES
function <span class="fstat-no" title="function not covered" >localeWeek(</span>mom){<span class="cstat-no" title="statement not covered" >return weekOfYear(mom,this._week.dow,this._week.doy).week;}</span>var defaultLocaleWeek=<span class="cstat-no" title="statement not covered" >{dow:0,// Sunday is the first day of the week.</span>
doy:6// The week that contains Jan 6th is the first week of the year.
};function <span class="fstat-no" title="function not covered" >localeFirstDayOfWeek(</span>){<span class="cstat-no" title="statement not covered" >return this._week.dow;}</span>function <span class="fstat-no" title="function not covered" >localeFirstDayOfYear(</span>){<span class="cstat-no" title="statement not covered" >return this._week.doy;}</span>// MOMENTS
function <span class="fstat-no" title="function not covered" >getSetWeek(</span>input){var week=<span class="cstat-no" title="statement not covered" >this.localeData().week(this);<span class="cstat-no" title="statement not covered" ></span>return input==null?week:this.add((input-week)*7,'d');}</span>function <span class="fstat-no" title="function not covered" >getSetISOWeek(</span>input){var week=<span class="cstat-no" title="statement not covered" >weekOfYear(this,1,4).week;<span class="cstat-no" title="statement not covered" ></span>return input==null?week:this.add((input-week)*7,'d');}</span>// FORMATTING
<span class="cstat-no" title="statement not covered" >addFormatToken('d',0,'do','day');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('dd',0,0,<span class="fstat-no" title="function not covered" >fu</span>nction(format){<span class="cstat-no" title="statement not covered" >return this.localeData().weekdaysMin(this,format);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('ddd',0,0,<span class="fstat-no" title="function not covered" >fu</span>nction(format){<span class="cstat-no" title="statement not covered" >return this.localeData().weekdaysShort(this,format);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('dddd',0,0,<span class="fstat-no" title="function not covered" >fu</span>nction(format){<span class="cstat-no" title="statement not covered" >return this.localeData().weekdays(this,format);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('e',0,0,'weekday');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('E',0,0,'isoWeekday');/</span>/ ALIASES
<span class="cstat-no" title="statement not covered" >addUnitAlias('day','d');<span class="cstat-no" title="statement not covered" >a</span>ddUnitAlias('weekday','e');<span class="cstat-no" title="statement not covered" >a</span>ddUnitAlias('isoWeekday','E');/</span>/ PRIORITY
<span class="cstat-no" title="statement not covered" >addUnitPriority('day',11);<span class="cstat-no" title="statement not covered" >a</span>ddUnitPriority('weekday',11);<span class="cstat-no" title="statement not covered" >a</span>ddUnitPriority('isoWeekday',11);/</span>/ PARSING
<span class="cstat-no" title="statement not covered" >addRegexToken('d',match1to2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('e',match1to2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('E',match1to2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('dd',<span class="fstat-no" title="function not covered" >fu</span>nction(isStrict,locale){<span class="cstat-no" title="statement not covered" >return locale.weekdaysMinRegex(isStrict);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('ddd',<span class="fstat-no" title="function not covered" >fu</span>nction(isStrict,locale){<span class="cstat-no" title="statement not covered" >return locale.weekdaysShortRegex(isStrict);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('dddd',<span class="fstat-no" title="function not covered" >fu</span>nction(isStrict,locale){<span class="cstat-no" title="statement not covered" >return locale.weekdaysRegex(isStrict);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddWeekParseToken(['dd','ddd','dddd'],<span class="fstat-no" title="function not covered" >fu</span>nction(input,week,config,token){var weekday=<span class="cstat-no" title="statement not covered" >config._locale.weekdaysParse(input,token,config._strict);</span>// if we didn't get a weekday name, mark the date as invalid</span>
<span class="cstat-no" title="statement not covered" >if(weekday!=null){<span class="cstat-no" title="statement not covered" >week.d=weekday;}</span>else{<span class="cstat-no" title="statement not covered" >getParsingFlags(config).invalidWeekday=input;}</span>}</span>);<span class="cstat-no" title="statement not covered" >addWeekParseToken(['d','e','E'],<span class="fstat-no" title="function not covered" >fu</span>nction(input,week,config,token){<span class="cstat-no" title="statement not covered" >week[token]=toInt(input);}</span>);/</span>/ HELPERS
function <span class="fstat-no" title="function not covered" >parseWeekday(</span>input,locale){<span class="cstat-no" title="statement not covered" >if(typeof input!=='string'){<span class="cstat-no" title="statement not covered" >return input;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isNaN(input)){<span class="cstat-no" title="statement not covered" >return parseInt(input,10);}<span class="cstat-no" title="statement not covered" ></span>i</span>nput=locale.weekdaysParse(input);<span class="cstat-no" title="statement not covered" >i</span>f(typeof input==='number'){<span class="cstat-no" title="statement not covered" >return input;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null;}</span>function <span class="fstat-no" title="function not covered" >parseIsoWeekday(</span>input,locale){<span class="cstat-no" title="statement not covered" >if(typeof input==='string'){<span class="cstat-no" title="statement not covered" >return locale.weekdaysParse(input)%7||7;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn isNaN(input)?null:input;}</span>// LOCALES
function <span class="fstat-no" title="function not covered" >shiftWeekdays(</span>ws,n){<span class="cstat-no" title="statement not covered" >return ws.slice(n,7).concat(ws.slice(0,n));}</span>var defaultLocaleWeekdays=<span class="cstat-no" title="statement not covered" >'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),</span>defaultLocaleWeekdaysShort=<span class="cstat-no" title="statement not covered" >'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),</span>defaultLocaleWeekdaysMin=<span class="cstat-no" title="statement not covered" >'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),</span>defaultWeekdaysRegex=<span class="cstat-no" title="statement not covered" >matchWord,</span>defaultWeekdaysShortRegex=<span class="cstat-no" title="statement not covered" >matchWord,</span>defaultWeekdaysMinRegex=<span class="cstat-no" title="statement not covered" >matchWord;</span>function <span class="fstat-no" title="function not covered" >localeWeekdays(</span>m,format){var weekdays=<span class="cstat-no" title="statement not covered" >isArray(this._weekdays)?this._weekdays:this._weekdays[m&amp;&amp;m!==true&amp;&amp;this._weekdays.isFormat.test(format)?'format':'standalone'];<span class="cstat-no" title="statement not covered" ></span>return m===true?shiftWeekdays(weekdays,this._week.dow):m?weekdays[m.day()]:weekdays;}</span>function <span class="fstat-no" title="function not covered" >localeWeekdaysShort(</span>m){<span class="cstat-no" title="statement not covered" >return m===true?shiftWeekdays(this._weekdaysShort,this._week.dow):m?this._weekdaysShort[m.day()]:this._weekdaysShort;}</span>function <span class="fstat-no" title="function not covered" >localeWeekdaysMin(</span>m){<span class="cstat-no" title="statement not covered" >return m===true?shiftWeekdays(this._weekdaysMin,this._week.dow):m?this._weekdaysMin[m.day()]:this._weekdaysMin;}</span>function <span class="fstat-no" title="function not covered" >handleStrictParse$1(</span>weekdayName,format,strict){var i,ii,mom,llc=<span class="cstat-no" title="statement not covered" >weekdayName.toLocaleLowerCase();<span class="cstat-no" title="statement not covered" ></span>if(!this._weekdaysParse){<span class="cstat-no" title="statement not covered" >this._weekdaysParse=[];<span class="cstat-no" title="statement not covered" >t</span>his._shortWeekdaysParse=[];<span class="cstat-no" title="statement not covered" >t</span>his._minWeekdaysParse=[];<span class="cstat-no" title="statement not covered" >f</span>or(i=0;i&lt;7;++i){<span class="cstat-no" title="statement not covered" >mom=createUTC([2000,1]).day(i);<span class="cstat-no" title="statement not covered" >t</span>his._minWeekdaysParse[i]=this.weekdaysMin(mom,'').toLocaleLowerCase();<span class="cstat-no" title="statement not covered" >t</span>his._shortWeekdaysParse[i]=this.weekdaysShort(mom,'').toLocaleLowerCase();<span class="cstat-no" title="statement not covered" >t</span>his._weekdaysParse[i]=this.weekdays(mom,'').toLocaleLowerCase();}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(strict){<span class="cstat-no" title="statement not covered" >if(format==='dddd'){<span class="cstat-no" title="statement not covered" >ii=indexOf.call(this._weekdaysParse,llc);<span class="cstat-no" title="statement not covered" >r</span>eturn ii!==-1?ii:null;}</span>else <span class="cstat-no" title="statement not covered" >if(format==='ddd'){<span class="cstat-no" title="statement not covered" >ii=indexOf.call(this._shortWeekdaysParse,llc);<span class="cstat-no" title="statement not covered" >r</span>eturn ii!==-1?ii:null;}</span>else{<span class="cstat-no" title="statement not covered" >ii=indexOf.call(this._minWeekdaysParse,llc);<span class="cstat-no" title="statement not covered" >r</span>eturn ii!==-1?ii:null;}</span>}</span></span>else{<span class="cstat-no" title="statement not covered" >if(format==='dddd'){<span class="cstat-no" title="statement not covered" >ii=indexOf.call(this._weekdaysParse,llc);<span class="cstat-no" title="statement not covered" >i</span>f(ii!==-1){<span class="cstat-no" title="statement not covered" >return ii;}<span class="cstat-no" title="statement not covered" ></span>i</span>i=indexOf.call(this._shortWeekdaysParse,llc);<span class="cstat-no" title="statement not covered" >i</span>f(ii!==-1){<span class="cstat-no" title="statement not covered" >return ii;}<span class="cstat-no" title="statement not covered" ></span>i</span>i=indexOf.call(this._minWeekdaysParse,llc);<span class="cstat-no" title="statement not covered" >r</span>eturn ii!==-1?ii:null;}</span>else <span class="cstat-no" title="statement not covered" >if(format==='ddd'){<span class="cstat-no" title="statement not covered" >ii=indexOf.call(this._shortWeekdaysParse,llc);<span class="cstat-no" title="statement not covered" >i</span>f(ii!==-1){<span class="cstat-no" title="statement not covered" >return ii;}<span class="cstat-no" title="statement not covered" ></span>i</span>i=indexOf.call(this._weekdaysParse,llc);<span class="cstat-no" title="statement not covered" >i</span>f(ii!==-1){<span class="cstat-no" title="statement not covered" >return ii;}<span class="cstat-no" title="statement not covered" ></span>i</span>i=indexOf.call(this._minWeekdaysParse,llc);<span class="cstat-no" title="statement not covered" >r</span>eturn ii!==-1?ii:null;}</span>else{<span class="cstat-no" title="statement not covered" >ii=indexOf.call(this._minWeekdaysParse,llc);<span class="cstat-no" title="statement not covered" >i</span>f(ii!==-1){<span class="cstat-no" title="statement not covered" >return ii;}<span class="cstat-no" title="statement not covered" ></span>i</span>i=indexOf.call(this._weekdaysParse,llc);<span class="cstat-no" title="statement not covered" >i</span>f(ii!==-1){<span class="cstat-no" title="statement not covered" >return ii;}<span class="cstat-no" title="statement not covered" ></span>i</span>i=indexOf.call(this._shortWeekdaysParse,llc);<span class="cstat-no" title="statement not covered" >r</span>eturn ii!==-1?ii:null;}</span>}</span></span>}</span>function <span class="fstat-no" title="function not covered" >localeWeekdaysParse(</span>weekdayName,format,strict){var i,mom,regex;<span class="cstat-no" title="statement not covered" >if(this._weekdaysParseExact){<span class="cstat-no" title="statement not covered" >return handleStrictParse$1.call(this,weekdayName,format,strict);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this._weekdaysParse){<span class="cstat-no" title="statement not covered" >this._weekdaysParse=[];<span class="cstat-no" title="statement not covered" >t</span>his._minWeekdaysParse=[];<span class="cstat-no" title="statement not covered" >t</span>his._shortWeekdaysParse=[];<span class="cstat-no" title="statement not covered" >t</span>his._fullWeekdaysParse=[];}<span class="cstat-no" title="statement not covered" ></span>f</span>or(i=0;i&lt;7;i++){// make the regex if we don't have it already</span>
<span class="cstat-no" title="statement not covered" >mom=createUTC([2000,1]).day(i);<span class="cstat-no" title="statement not covered" >i</span>f(strict&amp;&amp;!this._fullWeekdaysParse[i]){<span class="cstat-no" title="statement not covered" >this._fullWeekdaysParse[i]=new RegExp('^'+this.weekdays(mom,'').replace('.','\\.?')+'$','i');<span class="cstat-no" title="statement not covered" >t</span>his._shortWeekdaysParse[i]=new RegExp('^'+this.weekdaysShort(mom,'').replace('.','\\.?')+'$','i');<span class="cstat-no" title="statement not covered" >t</span>his._minWeekdaysParse[i]=new RegExp('^'+this.weekdaysMin(mom,'').replace('.','\\.?')+'$','i');}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!this._weekdaysParse[i]){<span class="cstat-no" title="statement not covered" >regex='^'+this.weekdays(mom,'')+'|^'+this.weekdaysShort(mom,'')+'|^'+this.weekdaysMin(mom,'');<span class="cstat-no" title="statement not covered" >t</span>his._weekdaysParse[i]=new RegExp(regex.replace('.',''),'i');}</span>/</span>/ test the regex
<span class="cstat-no" title="statement not covered" >if(strict&amp;&amp;format==='dddd'&amp;&amp;this._fullWeekdaysParse[i].test(weekdayName)){<span class="cstat-no" title="statement not covered" >return i;}</span>else <span class="cstat-no" title="statement not covered" >if(strict&amp;&amp;format==='ddd'&amp;&amp;this._shortWeekdaysParse[i].test(weekdayName)){<span class="cstat-no" title="statement not covered" >return i;}</span>else <span class="cstat-no" title="statement not covered" >if(strict&amp;&amp;format==='dd'&amp;&amp;this._minWeekdaysParse[i].test(weekdayName)){<span class="cstat-no" title="statement not covered" >return i;}</span>else <span class="cstat-no" title="statement not covered" >if(!strict&amp;&amp;this._weekdaysParse[i].test(weekdayName)){<span class="cstat-no" title="statement not covered" >return i;}</span>}</span></span></span></span>}// MOMENTS
function <span class="fstat-no" title="function not covered" >getSetDayOfWeek(</span>input){<span class="cstat-no" title="statement not covered" >if(!this.isValid()){<span class="cstat-no" title="statement not covered" >return input!=null?this:NaN;}</span>v</span>ar day=<span class="cstat-no" title="statement not covered" >this._isUTC?this._d.getUTCDay():this._d.getDay();<span class="cstat-no" title="statement not covered" ></span>if(input!=null){<span class="cstat-no" title="statement not covered" >input=parseWeekday(input,this.localeData());<span class="cstat-no" title="statement not covered" >r</span>eturn this.add(input-day,'d');}</span>else{<span class="cstat-no" title="statement not covered" >return day;}</span>}</span>function <span class="fstat-no" title="function not covered" >getSetLocaleDayOfWeek(</span>input){<span class="cstat-no" title="statement not covered" >if(!this.isValid()){<span class="cstat-no" title="statement not covered" >return input!=null?this:NaN;}</span>v</span>ar weekday=<span class="cstat-no" title="statement not covered" >(this.day()+7-this.localeData()._week.dow)%7;<span class="cstat-no" title="statement not covered" ></span>return input==null?weekday:this.add(input-weekday,'d');}</span>function <span class="fstat-no" title="function not covered" >getSetISODayOfWeek(</span>input){<span class="cstat-no" title="statement not covered" >if(!this.isValid()){<span class="cstat-no" title="statement not covered" >return input!=null?this:NaN;}</span>/</span>/ behaves the same as moment#day except
// as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
// as a setter, sunday should belong to the previous week.
<span class="cstat-no" title="statement not covered" >if(input!=null){var weekday=<span class="cstat-no" title="statement not covered" >parseIsoWeekday(input,this.localeData());<span class="cstat-no" title="statement not covered" ></span>return this.day(this.day()%7?weekday:weekday-7);}</span>else{<span class="cstat-no" title="statement not covered" >return this.day()||7;}</span>}</span>function <span class="fstat-no" title="function not covered" >weekdaysRegex(</span>isStrict){<span class="cstat-no" title="statement not covered" >if(this._weekdaysParseExact){<span class="cstat-no" title="statement not covered" >if(!hasOwnProp(this,'_weekdaysRegex')){<span class="cstat-no" title="statement not covered" >computeWeekdaysParse.call(this);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isStrict){<span class="cstat-no" title="statement not covered" >return this._weekdaysStrictRegex;}</span>else{<span class="cstat-no" title="statement not covered" >return this._weekdaysRegex;}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(!hasOwnProp(this,'_weekdaysRegex')){<span class="cstat-no" title="statement not covered" >this._weekdaysRegex=defaultWeekdaysRegex;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._weekdaysStrictRegex&amp;&amp;isStrict?this._weekdaysStrictRegex:this._weekdaysRegex;}</span>}</span>function <span class="fstat-no" title="function not covered" >weekdaysShortRegex(</span>isStrict){<span class="cstat-no" title="statement not covered" >if(this._weekdaysParseExact){<span class="cstat-no" title="statement not covered" >if(!hasOwnProp(this,'_weekdaysRegex')){<span class="cstat-no" title="statement not covered" >computeWeekdaysParse.call(this);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isStrict){<span class="cstat-no" title="statement not covered" >return this._weekdaysShortStrictRegex;}</span>else{<span class="cstat-no" title="statement not covered" >return this._weekdaysShortRegex;}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(!hasOwnProp(this,'_weekdaysShortRegex')){<span class="cstat-no" title="statement not covered" >this._weekdaysShortRegex=defaultWeekdaysShortRegex;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._weekdaysShortStrictRegex&amp;&amp;isStrict?this._weekdaysShortStrictRegex:this._weekdaysShortRegex;}</span>}</span>function <span class="fstat-no" title="function not covered" >weekdaysMinRegex(</span>isStrict){<span class="cstat-no" title="statement not covered" >if(this._weekdaysParseExact){<span class="cstat-no" title="statement not covered" >if(!hasOwnProp(this,'_weekdaysRegex')){<span class="cstat-no" title="statement not covered" >computeWeekdaysParse.call(this);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isStrict){<span class="cstat-no" title="statement not covered" >return this._weekdaysMinStrictRegex;}</span>else{<span class="cstat-no" title="statement not covered" >return this._weekdaysMinRegex;}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(!hasOwnProp(this,'_weekdaysMinRegex')){<span class="cstat-no" title="statement not covered" >this._weekdaysMinRegex=defaultWeekdaysMinRegex;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._weekdaysMinStrictRegex&amp;&amp;isStrict?this._weekdaysMinStrictRegex:this._weekdaysMinRegex;}</span>}</span>function <span class="fstat-no" title="function not covered" >computeWeekdaysParse(</span>){function <span class="fstat-no" title="function not covered" >cmpLenRev(</span>a,b){<span class="cstat-no" title="statement not covered" >return b.length-a.length;}</span>var minPieces=<span class="cstat-no" title="statement not covered" >[],</span>shortPieces=<span class="cstat-no" title="statement not covered" >[],</span>longPieces=<span class="cstat-no" title="statement not covered" >[],</span>mixedPieces=<span class="cstat-no" title="statement not covered" >[],</span>i,mom,minp,shortp,longp;<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;7;i++){// make the regex if we don't have it already</span>
<span class="cstat-no" title="statement not covered" >mom=createUTC([2000,1]).day(i);<span class="cstat-no" title="statement not covered" >m</span>inp=regexEscape(this.weekdaysMin(mom,''));<span class="cstat-no" title="statement not covered" >s</span>hortp=regexEscape(this.weekdaysShort(mom,''));<span class="cstat-no" title="statement not covered" >l</span>ongp=regexEscape(this.weekdays(mom,''));<span class="cstat-no" title="statement not covered" >m</span>inPieces.push(minp);<span class="cstat-no" title="statement not covered" >s</span>hortPieces.push(shortp);<span class="cstat-no" title="statement not covered" >l</span>ongPieces.push(longp);<span class="cstat-no" title="statement not covered" >m</span>ixedPieces.push(minp);<span class="cstat-no" title="statement not covered" >m</span>ixedPieces.push(shortp);<span class="cstat-no" title="statement not covered" >m</span>ixedPieces.push(longp);}</span>// Sorting makes sure if one weekday (or abbr) is a prefix of another it
// will match the longer piece.
<span class="cstat-no" title="statement not covered" >minPieces.sort(cmpLenRev);<span class="cstat-no" title="statement not covered" >s</span>hortPieces.sort(cmpLenRev);<span class="cstat-no" title="statement not covered" >l</span>ongPieces.sort(cmpLenRev);<span class="cstat-no" title="statement not covered" >m</span>ixedPieces.sort(cmpLenRev);<span class="cstat-no" title="statement not covered" >t</span>his._weekdaysRegex=new RegExp('^('+mixedPieces.join('|')+')','i');<span class="cstat-no" title="statement not covered" >t</span>his._weekdaysShortRegex=this._weekdaysRegex;<span class="cstat-no" title="statement not covered" >t</span>his._weekdaysMinRegex=this._weekdaysRegex;<span class="cstat-no" title="statement not covered" >t</span>his._weekdaysStrictRegex=new RegExp('^('+longPieces.join('|')+')','i');<span class="cstat-no" title="statement not covered" >t</span>his._weekdaysShortStrictRegex=new RegExp('^('+shortPieces.join('|')+')','i');<span class="cstat-no" title="statement not covered" >t</span>his._weekdaysMinStrictRegex=new RegExp('^('+minPieces.join('|')+')','i');}</span>// FORMATTING
function <span class="fstat-no" title="function not covered" >hFormat(</span>){<span class="cstat-no" title="statement not covered" >return this.hours()%12||12;}</span>function <span class="fstat-no" title="function not covered" >kFormat(</span>){<span class="cstat-no" title="statement not covered" >return this.hours()||24;}<span class="cstat-no" title="statement not covered" ></span>addFormatToken('H',['HH',2],0,'hour');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('h',['hh',2],0,hFormat);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('k',['kk',2],0,kFormat);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('hmm',0,0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return''+hFormat.apply(this)+zeroFill(this.minutes(),2);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('hmmss',0,0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return''+hFormat.apply(this)+zeroFill(this.minutes(),2)+zeroFill(this.seconds(),2);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('Hmm',0,0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return''+this.hours()+zeroFill(this.minutes(),2);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('Hmmss',0,0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return''+this.hours()+zeroFill(this.minutes(),2)+zeroFill(this.seconds(),2);}</span>);f</span>unction <span class="fstat-no" title="function not covered" >meridiem(</span>token,lowercase){<span class="cstat-no" title="statement not covered" >addFormatToken(token,0,0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.localeData().meridiem(this.hours(),this.minutes(),lowercase);}</span>);}<span class="cstat-no" title="statement not covered" ></span>meridiem('a',true);<span class="cstat-no" title="statement not covered" >m</span>eridiem('A',false);/</span>/ ALIASES
<span class="cstat-no" title="statement not covered" >addUnitAlias('hour','h');/</span>/ PRIORITY
<span class="cstat-no" title="statement not covered" >addUnitPriority('hour',13);/</span>/ PARSING
function <span class="fstat-no" title="function not covered" >matchMeridiem(</span>isStrict,locale){<span class="cstat-no" title="statement not covered" >return locale._meridiemParse;}<span class="cstat-no" title="statement not covered" ></span>addRegexToken('a',matchMeridiem);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('A',matchMeridiem);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('H',match1to2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('h',match1to2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('k',match1to2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('HH',match1to2,match2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('hh',match1to2,match2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('kk',match1to2,match2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('hmm',match3to4);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('hmmss',match5to6);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('Hmm',match3to4);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('Hmmss',match5to6);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken(['H','HH'],HOUR);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken(['k','kk'],<span class="fstat-no" title="function not covered" >fu</span>nction(input,array,config){var kInput=<span class="cstat-no" title="statement not covered" >toInt(input);<span class="cstat-no" title="statement not covered" ></span>array[HOUR]=kInput===24?0:kInput;}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken(['a','A'],<span class="fstat-no" title="function not covered" >fu</span>nction(input,array,config){<span class="cstat-no" title="statement not covered" >config._isPm=config._locale.isPM(input);<span class="cstat-no" title="statement not covered" >c</span>onfig._meridiem=input;}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken(['h','hh'],<span class="fstat-no" title="function not covered" >fu</span>nction(input,array,config){<span class="cstat-no" title="statement not covered" >array[HOUR]=toInt(input);<span class="cstat-no" title="statement not covered" >g</span>etParsingFlags(config).bigHour=true;}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken('hmm',<span class="fstat-no" title="function not covered" >fu</span>nction(input,array,config){var pos=<span class="cstat-no" title="statement not covered" >input.length-2;<span class="cstat-no" title="statement not covered" ></span>array[HOUR]=toInt(input.substr(0,pos));<span class="cstat-no" title="statement not covered" >a</span>rray[MINUTE]=toInt(input.substr(pos));<span class="cstat-no" title="statement not covered" >g</span>etParsingFlags(config).bigHour=true;}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken('hmmss',<span class="fstat-no" title="function not covered" >fu</span>nction(input,array,config){var pos1=<span class="cstat-no" title="statement not covered" >input.length-4,</span>pos2=<span class="cstat-no" title="statement not covered" >input.length-2;<span class="cstat-no" title="statement not covered" ></span>array[HOUR]=toInt(input.substr(0,pos1));<span class="cstat-no" title="statement not covered" >a</span>rray[MINUTE]=toInt(input.substr(pos1,2));<span class="cstat-no" title="statement not covered" >a</span>rray[SECOND]=toInt(input.substr(pos2));<span class="cstat-no" title="statement not covered" >g</span>etParsingFlags(config).bigHour=true;}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken('Hmm',<span class="fstat-no" title="function not covered" >fu</span>nction(input,array,config){var pos=<span class="cstat-no" title="statement not covered" >input.length-2;<span class="cstat-no" title="statement not covered" ></span>array[HOUR]=toInt(input.substr(0,pos));<span class="cstat-no" title="statement not covered" >a</span>rray[MINUTE]=toInt(input.substr(pos));}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken('Hmmss',<span class="fstat-no" title="function not covered" >fu</span>nction(input,array,config){var pos1=<span class="cstat-no" title="statement not covered" >input.length-4,</span>pos2=<span class="cstat-no" title="statement not covered" >input.length-2;<span class="cstat-no" title="statement not covered" ></span>array[HOUR]=toInt(input.substr(0,pos1));<span class="cstat-no" title="statement not covered" >a</span>rray[MINUTE]=toInt(input.substr(pos1,2));<span class="cstat-no" title="statement not covered" >a</span>rray[SECOND]=toInt(input.substr(pos2));}</span>);/</span>/ LOCALES
function <span class="fstat-no" title="function not covered" >localeIsPM(</span>input){// IE8 Quirks Mode &amp; IE7 Standards Mode do not allow accessing strings like arrays
// Using charAt should be more compatible.
<span class="cstat-no" title="statement not covered" >return(input+'').toLowerCase().charAt(0)==='p';}</span>var defaultLocaleMeridiemParse=<span class="cstat-no" title="statement not covered" >/[ap]\.?m?\.?/i,</span>// Setting the hour should keep the time, because the user explicitly
// specified which hour they want. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
getSetHour=<span class="cstat-no" title="statement not covered" >makeGetSet('Hours',true);</span>function <span class="fstat-no" title="function not covered" >localeMeridiem(</span>hours,minutes,isLower){<span class="cstat-no" title="statement not covered" >if(hours&gt;11){<span class="cstat-no" title="statement not covered" >return isLower?'pm':'PM';}</span>else{<span class="cstat-no" title="statement not covered" >return isLower?'am':'AM';}</span>}</span>var baseConfig=<span class="cstat-no" title="statement not covered" >{calendar:defaultCalendar,longDateFormat:defaultLongDateFormat,invalidDate:defaultInvalidDate,ordinal:defaultOrdinal,dayOfMonthOrdinalParse:defaultDayOfMonthOrdinalParse,relativeTime:defaultRelativeTime,months:defaultLocaleMonths,monthsShort:defaultLocaleMonthsShort,week:defaultLocaleWeek,weekdays:defaultLocaleWeekdays,weekdaysMin:defaultLocaleWeekdaysMin,weekdaysShort:defaultLocaleWeekdaysShort,meridiemParse:defaultLocaleMeridiemParse};</span>// internal storage for locale config files
var locales=<span class="cstat-no" title="statement not covered" >{},</span>localeFamilies=<span class="cstat-no" title="statement not covered" >{},</span>globalLocale;function <span class="fstat-no" title="function not covered" >commonPrefix(</span>arr1,arr2){var i,minl=<span class="cstat-no" title="statement not covered" >Math.min(arr1.length,arr2.length);<span class="cstat-no" title="statement not covered" ></span>for(i=0;i&lt;minl;i+=1){<span class="cstat-no" title="statement not covered" >if(arr1[i]!==arr2[i]){<span class="cstat-no" title="statement not covered" >return i;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn minl;}</span>function <span class="fstat-no" title="function not covered" >normalizeLocale(</span>key){<span class="cstat-no" title="statement not covered" >return key?key.toLowerCase().replace('_','-'):key;}</span>// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function <span class="fstat-no" title="function not covered" >chooseLocale(</span>names){var i=<span class="cstat-no" title="statement not covered" >0,</span>j,next,locale,split;<span class="cstat-no" title="statement not covered" >while(i&lt;names.length){<span class="cstat-no" title="statement not covered" >split=normalizeLocale(names[i]).split('-');<span class="cstat-no" title="statement not covered" >j</span>=split.length;<span class="cstat-no" title="statement not covered" >n</span>ext=normalizeLocale(names[i+1]);<span class="cstat-no" title="statement not covered" >n</span>ext=next?next.split('-'):null;<span class="cstat-no" title="statement not covered" >w</span>hile(j&gt;0){<span class="cstat-no" title="statement not covered" >locale=loadLocale(split.slice(0,j).join('-'));<span class="cstat-no" title="statement not covered" >i</span>f(locale){<span class="cstat-no" title="statement not covered" >return locale;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(next&amp;&amp;next.length&gt;=j&amp;&amp;commonPrefix(split,next)&gt;=j-1){//the next array item is better than a shallower substring of this one</span></span></span>
<span class="cstat-no" title="statement not covered" >break;}<span class="cstat-no" title="statement not covered" ></span>j--;}<span class="cstat-no" title="statement not covered" ></span>i++;}<span class="cstat-no" title="statement not covered" ></span>return globalLocale;}</span>function <span class="fstat-no" title="function not covered" >loadLocale(</span>name){var oldLocale=<span class="cstat-no" title="statement not covered" >null,</span>aliasedRequire;// TODO: Find a better way to register and load all the locales in Node
<span class="cstat-no" title="statement not covered" >if(locales[name]===undefined&amp;&amp;typeof module!=='undefined'&amp;&amp;module&amp;&amp;module.exports){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >oldLocale=globalLocale._abbr;<span class="cstat-no" title="statement not covered" >a</span>liasedRequire=require;<span class="cstat-no" title="statement not covered" >a</span>liasedRequire('./locale/'+name);<span class="cstat-no" title="statement not covered" >g</span>etSetGlobalLocale(oldLocale);}</span>catch(e){// mark as not found to avoid repeating expensive file require call causing high CPU</span></span>
// when trying to find en-US, en_US, en-us for every format call
<span class="cstat-no" title="statement not covered" >locales[name]=null;/</span>/ null means not found
}}<span class="cstat-no" title="statement not covered" >return locales[name];}</span>// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function <span class="fstat-no" title="function not covered" >getSetGlobalLocale(</span>key,values){var data;<span class="cstat-no" title="statement not covered" >if(key){<span class="cstat-no" title="statement not covered" >if(isUndefined(values)){<span class="cstat-no" title="statement not covered" >data=getLocale(key);}</span>else{<span class="cstat-no" title="statement not covered" >data=defineLocale(key,values);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(data){// moment.duration._locale = moment._locale = data;</span></span>
<span class="cstat-no" title="statement not covered" >globalLocale=data;}</span>else{<span class="cstat-no" title="statement not covered" >if(typeof console!=='undefined'&amp;&amp;console.warn){//warn user if arguments are passed but the locale could not be set</span>
<span class="cstat-no" title="statement not covered" >console.warn('Locale '+key+' not found. Did you forget to load it?');}</span>}}<span class="cstat-no" title="statement not covered" >return globalLocale._abbr;}</span>function <span class="fstat-no" title="function not covered" >defineLocale(</span>name,config){<span class="cstat-no" title="statement not covered" >if(config!==null){var locale,parentConfig=<span class="cstat-no" title="statement not covered" >baseConfig;<span class="cstat-no" title="statement not covered" ></span>config.abbr=name;<span class="cstat-no" title="statement not covered" >i</span>f(locales[name]!=null){<span class="cstat-no" title="statement not covered" >deprecateSimple('defineLocaleOverride','use moment.updateLocale(localeName, config) to change '+'an existing locale. moment.defineLocale(localeName, '+'config) should only be used for creating a new locale '+'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');<span class="cstat-no" title="statement not covered" >p</span>arentConfig=locales[name]._config;}</span>else <span class="cstat-no" title="statement not covered" >if(config.parentLocale!=null){<span class="cstat-no" title="statement not covered" >if(locales[config.parentLocale]!=null){<span class="cstat-no" title="statement not covered" >parentConfig=locales[config.parentLocale]._config;}</span>else{<span class="cstat-no" title="statement not covered" >locale=loadLocale(config.parentLocale);<span class="cstat-no" title="statement not covered" >i</span>f(locale!=null){<span class="cstat-no" title="statement not covered" >parentConfig=locale._config;}</span>else{<span class="cstat-no" title="statement not covered" >if(!localeFamilies[config.parentLocale]){<span class="cstat-no" title="statement not covered" >localeFamilies[config.parentLocale]=[];}<span class="cstat-no" title="statement not covered" ></span>l</span>ocaleFamilies[config.parentLocale].push({name:name,config:config});<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>l</span></span>ocales[name]=new Locale(mergeConfigs(parentConfig,config));<span class="cstat-no" title="statement not covered" >i</span>f(localeFamilies[name]){<span class="cstat-no" title="statement not covered" >localeFamilies[name].forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(x){<span class="cstat-no" title="statement not covered" >defineLocale(x.name,x.config);}</span>);}</span>/</span>/ backwards compat for now: also set the locale</span>
// make sure we set the locale AFTER all child locales have been
// created, so we won't end up with the child locale set.
<span class="cstat-no" title="statement not covered" >getSetGlobalLocale(name);<span class="cstat-no" title="statement not covered" >r</span>eturn locales[name];}</span>else{// useful for testing
<span class="cstat-no" title="statement not covered" >delete locales[name];<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>}function <span class="fstat-no" title="function not covered" >updateLocale(</span>name,config){<span class="cstat-no" title="statement not covered" >if(config!=null){var locale,tmpLocale,parentConfig=<span class="cstat-no" title="statement not covered" >baseConfig;<span class="cstat-no" title="statement not covered" ></span>if(locales[name]!=null&amp;&amp;locales[name].parentLocale!=null){// Update existing child locale in-place to avoid memory-leaks</span></span>
<span class="cstat-no" title="statement not covered" >locales[name].set(mergeConfigs(locales[name]._config,config));}</span>else{// MERGE
<span class="cstat-no" title="statement not covered" >tmpLocale=loadLocale(name);<span class="cstat-no" title="statement not covered" >i</span>f(tmpLocale!=null){<span class="cstat-no" title="statement not covered" >parentConfig=tmpLocale._config;}<span class="cstat-no" title="statement not covered" ></span>c</span>onfig=mergeConfigs(parentConfig,config);<span class="cstat-no" title="statement not covered" >i</span>f(tmpLocale==null){// updateLocale is called for creating a new locale</span>
// Set abbr so it will have a name (getters return
// undefined otherwise).
<span class="cstat-no" title="statement not covered" >config.abbr=name;}<span class="cstat-no" title="statement not covered" ></span>locale=new Locale(config);<span class="cstat-no" title="statement not covered" >l</span>ocale.parentLocale=locales[name];<span class="cstat-no" title="statement not covered" >l</span>ocales[name]=locale;}</span>// backwards compat for now: also set the locale
<span class="cstat-no" title="statement not covered" >getSetGlobalLocale(name);}</span>else{// pass null for config to unupdate, useful for tests
<span class="cstat-no" title="statement not covered" >if(locales[name]!=null){<span class="cstat-no" title="statement not covered" >if(locales[name].parentLocale!=null){<span class="cstat-no" title="statement not covered" >locales[name]=locales[name].parentLocale;<span class="cstat-no" title="statement not covered" >i</span>f(name===getSetGlobalLocale()){<span class="cstat-no" title="statement not covered" >getSetGlobalLocale(name);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(locales[name]!=null){<span class="cstat-no" title="statement not covered" >delete locales[name];}</span>}</span></span>}<span class="cstat-no" title="statement not covered" ></span>return locales[name];}</span>// returns locale data
function <span class="fstat-no" title="function not covered" >getLocale(</span>key){var locale;<span class="cstat-no" title="statement not covered" >if(key&amp;&amp;key._locale&amp;&amp;key._locale._abbr){<span class="cstat-no" title="statement not covered" >key=key._locale._abbr;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!key){<span class="cstat-no" title="statement not covered" >return globalLocale;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isArray(key)){//short-circuit everything else</span>
<span class="cstat-no" title="statement not covered" >locale=loadLocale(key);<span class="cstat-no" title="statement not covered" >i</span>f(locale){<span class="cstat-no" title="statement not covered" >return locale;}<span class="cstat-no" title="statement not covered" ></span>k</span>ey=[key];}<span class="cstat-no" title="statement not covered" ></span>return chooseLocale(key);}</span>function <span class="fstat-no" title="function not covered" >listLocales(</span>){<span class="cstat-no" title="statement not covered" >return keys(locales);}</span>function <span class="fstat-no" title="function not covered" >checkOverflow(</span>m){var overflow,a=<span class="cstat-no" title="statement not covered" >m._a;<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;getParsingFlags(m).overflow===-2){<span class="cstat-no" title="statement not covered" >overflow=a[MONTH]&lt;0||a[MONTH]&gt;11?MONTH:a[DATE]&lt;1||a[DATE]&gt;daysInMonth(a[YEAR],a[MONTH])?DATE:a[HOUR]&lt;0||a[HOUR]&gt;24||a[HOUR]===24&amp;&amp;(a[MINUTE]!==0||a[SECOND]!==0||a[MILLISECOND]!==0)?HOUR:a[MINUTE]&lt;0||a[MINUTE]&gt;59?MINUTE:a[SECOND]&lt;0||a[SECOND]&gt;59?SECOND:a[MILLISECOND]&lt;0||a[MILLISECOND]&gt;999?MILLISECOND:-1;<span class="cstat-no" title="statement not covered" >i</span>f(getParsingFlags(m)._overflowDayOfYear&amp;&amp;(overflow&lt;YEAR||overflow&gt;DATE)){<span class="cstat-no" title="statement not covered" >overflow=DATE;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(getParsingFlags(m)._overflowWeeks&amp;&amp;overflow===-1){<span class="cstat-no" title="statement not covered" >overflow=WEEK;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(getParsingFlags(m)._overflowWeekday&amp;&amp;overflow===-1){<span class="cstat-no" title="statement not covered" >overflow=WEEKDAY;}<span class="cstat-no" title="statement not covered" ></span>g</span>etParsingFlags(m).overflow=overflow;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn m;}</span>// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex=<span class="cstat-no" title="statement not covered" >/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,</span>basicIsoRegex=<span class="cstat-no" title="statement not covered" >/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,</span>tzRegex=<span class="cstat-no" title="statement not covered" >/Z|[+-]\d\d(?::?\d\d)?/,</span>isoDates=<span class="cstat-no" title="statement not covered" >[['YYYYYY-MM-DD',/[+-]\d{6}-\d\d-\d\d/],['YYYY-MM-DD',/\d{4}-\d\d-\d\d/],['GGGG-[W]WW-E',/\d{4}-W\d\d-\d/],['GGGG-[W]WW',/\d{4}-W\d\d/,false],['YYYY-DDD',/\d{4}-\d{3}/],['YYYY-MM',/\d{4}-\d\d/,false],['YYYYYYMMDD',/[+-]\d{10}/],['YYYYMMDD',/\d{8}/],['GGGG[W]WWE',/\d{4}W\d{3}/],['GGGG[W]WW',/\d{4}W\d{2}/,false],['YYYYDDD',/\d{7}/],['YYYYMM',/\d{6}/,false],['YYYY',/\d{4}/,false]],</span>// iso time formats and regexes
isoTimes=<span class="cstat-no" title="statement not covered" >[['HH:mm:ss.SSSS',/\d\d:\d\d:\d\d\.\d+/],['HH:mm:ss,SSSS',/\d\d:\d\d:\d\d,\d+/],['HH:mm:ss',/\d\d:\d\d:\d\d/],['HH:mm',/\d\d:\d\d/],['HHmmss.SSSS',/\d\d\d\d\d\d\.\d+/],['HHmmss,SSSS',/\d\d\d\d\d\d,\d+/],['HHmmss',/\d\d\d\d\d\d/],['HHmm',/\d\d\d\d/],['HH',/\d\d/]],</span>aspNetJsonRegex=<span class="cstat-no" title="statement not covered" >/^\/?Date\((-?\d+)/i,</span>// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
rfc2822=<span class="cstat-no" title="statement not covered" >/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,</span>obsOffsets=<span class="cstat-no" title="statement not covered" >{UT:0,GMT:0,EDT:-4*60,EST:-5*60,CDT:-5*60,CST:-6*60,MDT:-6*60,MST:-7*60,PDT:-7*60,PST:-8*60};</span>// date from iso format
function <span class="fstat-no" title="function not covered" >configFromISO(</span>config){var i,l,string=<span class="cstat-no" title="statement not covered" >config._i,</span>match=<span class="cstat-no" title="statement not covered" >extendedIsoRegex.exec(string)||basicIsoRegex.exec(string),</span>allowTime,dateFormat,timeFormat,tzFormat;<span class="cstat-no" title="statement not covered" >if(match){<span class="cstat-no" title="statement not covered" >getParsingFlags(config).iso=true;<span class="cstat-no" title="statement not covered" >f</span>or(i=0,l=isoDates.length;i&lt;l;i++){<span class="cstat-no" title="statement not covered" >if(isoDates[i][1].exec(match[1])){<span class="cstat-no" title="statement not covered" >dateFormat=isoDates[i][0];<span class="cstat-no" title="statement not covered" >a</span>llowTime=isoDates[i][2]!==false;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(dateFormat==null){<span class="cstat-no" title="statement not covered" >config._isValid=false;<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(match[3]){<span class="cstat-no" title="statement not covered" >for(i=0,l=isoTimes.length;i&lt;l;i++){<span class="cstat-no" title="statement not covered" >if(isoTimes[i][1].exec(match[3])){// match[2] should be 'T' or space</span></span></span></span>
<span class="cstat-no" title="statement not covered" >timeFormat=(match[2]||' ')+isoTimes[i][0];<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}<span class="cstat-no" title="statement not covered" >if(timeFormat==null){<span class="cstat-no" title="statement not covered" >config._isValid=false;<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>}<span class="cstat-no" title="statement not covered" ></span>if(!allowTime&amp;&amp;timeFormat!=null){<span class="cstat-no" title="statement not covered" >config._isValid=false;<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(match[4]){<span class="cstat-no" title="statement not covered" >if(tzRegex.exec(match[4])){<span class="cstat-no" title="statement not covered" >tzFormat='Z';}</span>else{<span class="cstat-no" title="statement not covered" >config._isValid=false;<span class="cstat-no" title="statement not covered" >r</span>eturn;}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>onfig._f=dateFormat+(timeFormat||'')+(tzFormat||'');<span class="cstat-no" title="statement not covered" >c</span>onfigFromStringAndFormat(config);}</span>else{<span class="cstat-no" title="statement not covered" >config._isValid=false;}</span>}function <span class="fstat-no" title="function not covered" >extractFromRFC2822Strings(</span>yearStr,monthStr,dayStr,hourStr,minuteStr,secondStr){var result=<span class="cstat-no" title="statement not covered" >[untruncateYear(yearStr),defaultLocaleMonthsShort.indexOf(monthStr),parseInt(dayStr,10),parseInt(hourStr,10),parseInt(minuteStr,10)];<span class="cstat-no" title="statement not covered" ></span>if(secondStr){<span class="cstat-no" title="statement not covered" >result.push(parseInt(secondStr,10));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn result;}</span>function <span class="fstat-no" title="function not covered" >untruncateYear(</span>yearStr){var year=<span class="cstat-no" title="statement not covered" >parseInt(yearStr,10);<span class="cstat-no" title="statement not covered" ></span>if(year&lt;=49){<span class="cstat-no" title="statement not covered" >return 2000+year;}</span>else <span class="cstat-no" title="statement not covered" >if(year&lt;=999){<span class="cstat-no" title="statement not covered" >return 1900+year;}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn year;}</span>function <span class="fstat-no" title="function not covered" >preprocessRFC2822(</span>s){// Remove comments and folding whitespace and replace multiple-spaces with a single space
<span class="cstat-no" title="statement not covered" >return s.replace(/\([^)]*\)|[\n\t]/g,' ').replace(/(\s\s+)/g,' ').replace(/^\s\s*/,'').replace(/\s\s*$/,'');}</span>function <span class="fstat-no" title="function not covered" >checkWeekday(</span>weekdayStr,parsedInput,config){<span class="cstat-no" title="statement not covered" >if(weekdayStr){// TODO: Replace the vanilla JS Date object with an independent day-of-week check.</span>
var weekdayProvided=<span class="cstat-no" title="statement not covered" >defaultLocaleWeekdaysShort.indexOf(weekdayStr),</span>weekdayActual=<span class="cstat-no" title="statement not covered" >new Date(parsedInput[0],parsedInput[1],parsedInput[2]).getDay();<span class="cstat-no" title="statement not covered" ></span>if(weekdayProvided!==weekdayActual){<span class="cstat-no" title="statement not covered" >getParsingFlags(config).weekdayMismatch=true;<span class="cstat-no" title="statement not covered" >c</span>onfig._isValid=false;<span class="cstat-no" title="statement not covered" >r</span>eturn false;}</span>}<span class="cstat-no" title="statement not covered" ></span>return true;}</span>function <span class="fstat-no" title="function not covered" >calculateOffset(</span>obsOffset,militaryOffset,numOffset){<span class="cstat-no" title="statement not covered" >if(obsOffset){<span class="cstat-no" title="statement not covered" >return obsOffsets[obsOffset];}</span>else <span class="cstat-no" title="statement not covered" >if(militaryOffset){// the only allowed military tz is Z</span></span>
<span class="cstat-no" title="statement not covered" >return 0;}</span>else{var hm=<span class="cstat-no" title="statement not covered" >parseInt(numOffset,10),</span>m=<span class="cstat-no" title="statement not covered" >hm%100,</span>h=<span class="cstat-no" title="statement not covered" >(hm-m)/100;<span class="cstat-no" title="statement not covered" ></span>return h*60+m;}</span>}// date and time from ref 2822 format
function <span class="fstat-no" title="function not covered" >configFromRFC2822(</span>config){var match=<span class="cstat-no" title="statement not covered" >rfc2822.exec(preprocessRFC2822(config._i)),</span>parsedArray;<span class="cstat-no" title="statement not covered" >if(match){<span class="cstat-no" title="statement not covered" >parsedArray=extractFromRFC2822Strings(match[4],match[3],match[2],match[5],match[6],match[7]);<span class="cstat-no" title="statement not covered" >i</span>f(!checkWeekday(match[1],parsedArray,config)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>c</span>onfig._a=parsedArray;<span class="cstat-no" title="statement not covered" >c</span>onfig._tzm=calculateOffset(match[8],match[9],match[10]);<span class="cstat-no" title="statement not covered" >c</span>onfig._d=createUTCDate.apply(null,config._a);<span class="cstat-no" title="statement not covered" >c</span>onfig._d.setUTCMinutes(config._d.getUTCMinutes()-config._tzm);<span class="cstat-no" title="statement not covered" >g</span>etParsingFlags(config).rfc2822=true;}</span>else{<span class="cstat-no" title="statement not covered" >config._isValid=false;}</span>}</span>// date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
function <span class="fstat-no" title="function not covered" >configFromString(</span>config){var matched=<span class="cstat-no" title="statement not covered" >aspNetJsonRegex.exec(config._i);<span class="cstat-no" title="statement not covered" ></span>if(matched!==null){<span class="cstat-no" title="statement not covered" >config._d=new Date(+matched[1]);<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>c</span>onfigFromISO(config);<span class="cstat-no" title="statement not covered" >i</span>f(config._isValid===false){<span class="cstat-no" title="statement not covered" >delete config._isValid;}</span>else{<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>c</span>onfigFromRFC2822(config);<span class="cstat-no" title="statement not covered" >i</span>f(config._isValid===false){<span class="cstat-no" title="statement not covered" >delete config._isValid;}</span>else{<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(config._strict){<span class="cstat-no" title="statement not covered" >config._isValid=false;}</span>else{// Final attempt, use Input Fallback</span>
<span class="cstat-no" title="statement not covered" >hooks.createFromInputFallback(config);}</span>}<span class="cstat-no" title="statement not covered" >hooks.createFromInputFallback=deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), '+'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are '+'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',<span class="fstat-no" title="function not covered" >fu</span>nction(config){<span class="cstat-no" title="statement not covered" >config._d=new Date(config._i+(config._useUTC?' UTC':''));}</span>);/</span>/ Pick the first defined of two or three arguments.
function <span class="fstat-no" title="function not covered" >defaults(</span>a,b,c){<span class="cstat-no" title="statement not covered" >if(a!=null){<span class="cstat-no" title="statement not covered" >return a;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b!=null){<span class="cstat-no" title="statement not covered" >return b;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn c;}</span>function <span class="fstat-no" title="function not covered" >currentDateArray(</span>config){// hooks is actually the exported moment object
var nowValue=<span class="cstat-no" title="statement not covered" >new Date(hooks.now());<span class="cstat-no" title="statement not covered" ></span>if(config._useUTC){<span class="cstat-no" title="statement not covered" >return[nowValue.getUTCFullYear(),nowValue.getUTCMonth(),nowValue.getUTCDate()];}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn[nowValue.getFullYear(),nowValue.getMonth(),nowValue.getDate()];}</span>// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function <span class="fstat-no" title="function not covered" >configFromArray(</span>config){var i,date,input=<span class="cstat-no" title="statement not covered" >[],</span>currentDate,expectedWeekday,yearToUse;<span class="cstat-no" title="statement not covered" >if(config._d){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>c</span>urrentDate=currentDateArray(config);/</span>/compute day of the year from weeks and weekdays
<span class="cstat-no" title="statement not covered" >if(config._w&amp;&amp;config._a[DATE]==null&amp;&amp;config._a[MONTH]==null){<span class="cstat-no" title="statement not covered" >dayOfYearFromWeekInfo(config);}</span>/</span>/if the day of the year is set, figure out what it is
<span class="cstat-no" title="statement not covered" >if(config._dayOfYear!=null){<span class="cstat-no" title="statement not covered" >yearToUse=defaults(config._a[YEAR],currentDate[YEAR]);<span class="cstat-no" title="statement not covered" >i</span>f(config._dayOfYear&gt;daysInYear(yearToUse)||config._dayOfYear===0){<span class="cstat-no" title="statement not covered" >getParsingFlags(config)._overflowDayOfYear=true;}<span class="cstat-no" title="statement not covered" ></span>d</span>ate=createUTCDate(yearToUse,0,config._dayOfYear);<span class="cstat-no" title="statement not covered" >c</span>onfig._a[MONTH]=date.getUTCMonth();<span class="cstat-no" title="statement not covered" >c</span>onfig._a[DATE]=date.getUTCDate();}</span>/</span>/ Default to current date.
// * if no year, month, day of month are given, default to today
// * if day of month is given, default month and year
// * if month is given, default only year
// * if year is given, don't default anything
<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;3&amp;&amp;config._a[i]==null;++i){<span class="cstat-no" title="statement not covered" >config._a[i]=input[i]=currentDate[i];}</span>/</span>/ Zero out whatever was not defaulted, including time
<span class="cstat-no" title="statement not covered" >for(;i&lt;7;i++){<span class="cstat-no" title="statement not covered" >config._a[i]=input[i]=config._a[i]==null?i===2?1:0:config._a[i];}</span>/</span>/ Check for 24:00:00.000
<span class="cstat-no" title="statement not covered" >if(config._a[HOUR]===24&amp;&amp;config._a[MINUTE]===0&amp;&amp;config._a[SECOND]===0&amp;&amp;config._a[MILLISECOND]===0){<span class="cstat-no" title="statement not covered" >config._nextDay=true;<span class="cstat-no" title="statement not covered" >c</span>onfig._a[HOUR]=0;}<span class="cstat-no" title="statement not covered" ></span>c</span>onfig._d=(config._useUTC?createUTCDate:createDate).apply(null,input);<span class="cstat-no" title="statement not covered" >e</span>xpectedWeekday=config._useUTC?config._d.getUTCDay():config._d.getDay();/</span>/ Apply timezone offset from input. The actual utcOffset can be changed
// with parseZone.
<span class="cstat-no" title="statement not covered" >if(config._tzm!=null){<span class="cstat-no" title="statement not covered" >config._d.setUTCMinutes(config._d.getUTCMinutes()-config._tzm);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(config._nextDay){<span class="cstat-no" title="statement not covered" >config._a[HOUR]=24;}</span>/</span>/ check for mismatching day of week
<span class="cstat-no" title="statement not covered" >if(config._w&amp;&amp;typeof config._w.d!=='undefined'&amp;&amp;config._w.d!==expectedWeekday){<span class="cstat-no" title="statement not covered" >getParsingFlags(config).weekdayMismatch=true;}</span>}</span>function <span class="fstat-no" title="function not covered" >dayOfYearFromWeekInfo(</span>config){var w,weekYear,week,weekday,dow,doy,temp,weekdayOverflow,curWeek;<span class="cstat-no" title="statement not covered" >w=config._w;<span class="cstat-no" title="statement not covered" >i</span>f(w.GG!=null||w.W!=null||w.E!=null){<span class="cstat-no" title="statement not covered" >dow=1;<span class="cstat-no" title="statement not covered" >d</span>oy=4;/</span>/ TODO: We need to take the current isoWeekYear, but that depends on</span>
// how we interpret now (local, utc, fixed offset). So create
// a now version of current config (take local/utc/offset flags, and
// create now).
<span class="cstat-no" title="statement not covered" >weekYear=defaults(w.GG,config._a[YEAR],weekOfYear(createLocal(),1,4).year);<span class="cstat-no" title="statement not covered" >w</span>eek=defaults(w.W,1);<span class="cstat-no" title="statement not covered" >w</span>eekday=defaults(w.E,1);<span class="cstat-no" title="statement not covered" >i</span>f(weekday&lt;1||weekday&gt;7){<span class="cstat-no" title="statement not covered" >weekdayOverflow=true;}</span>}</span>else{<span class="cstat-no" title="statement not covered" >dow=config._locale._week.dow;<span class="cstat-no" title="statement not covered" >d</span>oy=config._locale._week.doy;<span class="cstat-no" title="statement not covered" >c</span>urWeek=weekOfYear(createLocal(),dow,doy);<span class="cstat-no" title="statement not covered" >w</span>eekYear=defaults(w.gg,config._a[YEAR],curWeek.year);/</span>/ Default to current week.
<span class="cstat-no" title="statement not covered" >week=defaults(w.w,curWeek.week);<span class="cstat-no" title="statement not covered" >i</span>f(w.d!=null){// weekday -- low day numbers are considered next week</span>
<span class="cstat-no" title="statement not covered" >weekday=w.d;<span class="cstat-no" title="statement not covered" >i</span>f(weekday&lt;0||weekday&gt;6){<span class="cstat-no" title="statement not covered" >weekdayOverflow=true;}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(w.e!=null){// local weekday -- counting starts from beginning of week</span>
<span class="cstat-no" title="statement not covered" >weekday=w.e+dow;<span class="cstat-no" title="statement not covered" >i</span>f(w.e&lt;0||w.e&gt;6){<span class="cstat-no" title="statement not covered" >weekdayOverflow=true;}</span>}</span>else{// default to beginning of week
<span class="cstat-no" title="statement not covered" >weekday=dow;}</span>}<span class="cstat-no" title="statement not covered" >if(week&lt;1||week&gt;weeksInYear(weekYear,dow,doy)){<span class="cstat-no" title="statement not covered" >getParsingFlags(config)._overflowWeeks=true;}</span>else <span class="cstat-no" title="statement not covered" >if(weekdayOverflow!=null){<span class="cstat-no" title="statement not covered" >getParsingFlags(config)._overflowWeekday=true;}</span>else{<span class="cstat-no" title="statement not covered" >temp=dayOfYearFromWeeks(weekYear,week,weekday,dow,doy);<span class="cstat-no" title="statement not covered" >c</span>onfig._a[YEAR]=temp.year;<span class="cstat-no" title="statement not covered" >c</span>onfig._dayOfYear=temp.dayOfYear;}</span>}</span></span>// constant that refers to the ISO standard
<span class="cstat-no" title="statement not covered" >hooks.ISO_8601=<span class="fstat-no" title="function not covered" >fu</span>nction(){};/</span>/ constant that refers to the RFC 2822 form
<span class="cstat-no" title="statement not covered" >hooks.RFC_2822=<span class="fstat-no" title="function not covered" >fu</span>nction(){};/</span>/ date from string and format string
function <span class="fstat-no" title="function not covered" >configFromStringAndFormat(</span>config){// TODO: Move this to another part of the creation flow to prevent circular deps
<span class="cstat-no" title="statement not covered" >if(config._f===hooks.ISO_8601){<span class="cstat-no" title="statement not covered" >configFromISO(config);<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(config._f===hooks.RFC_2822){<span class="cstat-no" title="statement not covered" >configFromRFC2822(config);<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>c</span>onfig._a=[];<span class="cstat-no" title="statement not covered" >g</span>etParsingFlags(config).empty=true;/</span>/ This array is used to make a Date, either with `new Date` or `Date.UTC`
var string=<span class="cstat-no" title="statement not covered" >''+config._i,</span>i,parsedInput,tokens,token,skipped,stringLength=<span class="cstat-no" title="statement not covered" >string.length,</span>totalParsedInputLength=<span class="cstat-no" title="statement not covered" >0,</span>era;<span class="cstat-no" title="statement not covered" >tokens=expandFormat(config._f,config._locale).match(formattingTokens)||[];<span class="cstat-no" title="statement not covered" >f</span>or(i=0;i&lt;tokens.length;i++){<span class="cstat-no" title="statement not covered" >token=tokens[i];<span class="cstat-no" title="statement not covered" >p</span>arsedInput=(string.match(getParseRegexForToken(token,config))||[])[0];<span class="cstat-no" title="statement not covered" >i</span>f(parsedInput){<span class="cstat-no" title="statement not covered" >skipped=string.substr(0,string.indexOf(parsedInput));<span class="cstat-no" title="statement not covered" >i</span>f(skipped.length&gt;0){<span class="cstat-no" title="statement not covered" >getParsingFlags(config).unusedInput.push(skipped);}<span class="cstat-no" title="statement not covered" ></span>s</span>tring=string.slice(string.indexOf(parsedInput)+parsedInput.length);<span class="cstat-no" title="statement not covered" >t</span>otalParsedInputLength+=parsedInput.length;}</span>/</span>/ don't parse if it's not a known token</span>
<span class="cstat-no" title="statement not covered" >if(formatTokenFunctions[token]){<span class="cstat-no" title="statement not covered" >if(parsedInput){<span class="cstat-no" title="statement not covered" >getParsingFlags(config).empty=false;}</span>else{<span class="cstat-no" title="statement not covered" >getParsingFlags(config).unusedTokens.push(token);}<span class="cstat-no" title="statement not covered" ></span>a</span>ddTimeToArrayFromToken(token,parsedInput,config);}</span>else <span class="cstat-no" title="statement not covered" >if(config._strict&amp;&amp;!parsedInput){<span class="cstat-no" title="statement not covered" >getParsingFlags(config).unusedTokens.push(token);}</span>}</span></span>// add remaining unparsed input length to the string
<span class="cstat-no" title="statement not covered" >getParsingFlags(config).charsLeftOver=stringLength-totalParsedInputLength;<span class="cstat-no" title="statement not covered" >i</span>f(string.length&gt;0){<span class="cstat-no" title="statement not covered" >getParsingFlags(config).unusedInput.push(string);}</span>/</span>/ clear _12h flag if hour is &lt;= 12
<span class="cstat-no" title="statement not covered" >if(config._a[HOUR]&lt;=12&amp;&amp;getParsingFlags(config).bigHour===true&amp;&amp;config._a[HOUR]&gt;0){<span class="cstat-no" title="statement not covered" >getParsingFlags(config).bigHour=undefined;}<span class="cstat-no" title="statement not covered" ></span>g</span>etParsingFlags(config).parsedDateParts=config._a.slice(0);<span class="cstat-no" title="statement not covered" >g</span>etParsingFlags(config).meridiem=config._meridiem;/</span>/ handle meridiem
<span class="cstat-no" title="statement not covered" >config._a[HOUR]=meridiemFixWrap(config._locale,config._a[HOUR],config._meridiem);/</span>/ handle era
<span class="cstat-no" title="statement not covered" >era=getParsingFlags(config).era;<span class="cstat-no" title="statement not covered" >i</span>f(era!==null){<span class="cstat-no" title="statement not covered" >config._a[YEAR]=config._locale.erasConvertYear(era,config._a[YEAR]);}<span class="cstat-no" title="statement not covered" ></span>c</span>onfigFromArray(config);<span class="cstat-no" title="statement not covered" >c</span>heckOverflow(config);}</span>function <span class="fstat-no" title="function not covered" >meridiemFixWrap(</span>locale,hour,meridiem){var isPm;<span class="cstat-no" title="statement not covered" >if(meridiem==null){// nothing to do</span>
<span class="cstat-no" title="statement not covered" >return hour;}<span class="cstat-no" title="statement not covered" ></span>if(locale.meridiemHour!=null){<span class="cstat-no" title="statement not covered" >return locale.meridiemHour(hour,meridiem);}</span>else <span class="cstat-no" title="statement not covered" >if(locale.isPM!=null){// Fallback</span></span>
<span class="cstat-no" title="statement not covered" >isPm=locale.isPM(meridiem);<span class="cstat-no" title="statement not covered" >i</span>f(isPm&amp;&amp;hour&lt;12){<span class="cstat-no" title="statement not covered" >hour+=12;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isPm&amp;&amp;hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn hour;}</span>else{// this is not supposed to happen
<span class="cstat-no" title="statement not covered" >return hour;}</span>}// date from string and array of format strings
function <span class="fstat-no" title="function not covered" >configFromStringAndArray(</span>config){var tempConfig,bestMoment,scoreToBeat,i,currentScore,validFormatFound,bestFormatIsValid=<span class="cstat-no" title="statement not covered" >false;<span class="cstat-no" title="statement not covered" ></span>if(config._f.length===0){<span class="cstat-no" title="statement not covered" >getParsingFlags(config).invalidFormat=true;<span class="cstat-no" title="statement not covered" >c</span>onfig._d=new Date(NaN);<span class="cstat-no" title="statement not covered" >r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>f</span>or(i=0;i&lt;config._f.length;i++){<span class="cstat-no" title="statement not covered" >currentScore=0;<span class="cstat-no" title="statement not covered" >v</span>alidFormatFound=false;<span class="cstat-no" title="statement not covered" >t</span>empConfig=copyConfig({},config);<span class="cstat-no" title="statement not covered" >i</span>f(config._useUTC!=null){<span class="cstat-no" title="statement not covered" >tempConfig._useUTC=config._useUTC;}<span class="cstat-no" title="statement not covered" ></span>t</span>empConfig._f=config._f[i];<span class="cstat-no" title="statement not covered" >c</span>onfigFromStringAndFormat(tempConfig);<span class="cstat-no" title="statement not covered" >i</span>f(isValid(tempConfig)){<span class="cstat-no" title="statement not covered" >validFormatFound=true;}</span>/</span>/ if there is any input that was not parsed add a penalty for that format</span>
<span class="cstat-no" title="statement not covered" >currentScore+=getParsingFlags(tempConfig).charsLeftOver;/</span>/or tokens
<span class="cstat-no" title="statement not covered" >currentScore+=getParsingFlags(tempConfig).unusedTokens.length*10;<span class="cstat-no" title="statement not covered" >g</span>etParsingFlags(tempConfig).score=currentScore;<span class="cstat-no" title="statement not covered" >i</span>f(!bestFormatIsValid){<span class="cstat-no" title="statement not covered" >if(scoreToBeat==null||currentScore&lt;scoreToBeat||validFormatFound){<span class="cstat-no" title="statement not covered" >scoreToBeat=currentScore;<span class="cstat-no" title="statement not covered" >b</span>estMoment=tempConfig;<span class="cstat-no" title="statement not covered" >i</span>f(validFormatFound){<span class="cstat-no" title="statement not covered" >bestFormatIsValid=true;}</span>}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(currentScore&lt;scoreToBeat){<span class="cstat-no" title="statement not covered" >scoreToBeat=currentScore;<span class="cstat-no" title="statement not covered" >b</span>estMoment=tempConfig;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>extend(config,bestMoment||tempConfig);}</span>function <span class="fstat-no" title="function not covered" >configFromObject(</span>config){<span class="cstat-no" title="statement not covered" >if(config._d){<span class="cstat-no" title="statement not covered" >return;}</span>v</span>ar i=<span class="cstat-no" title="statement not covered" >normalizeObjectUnits(config._i),</span>dayOrDate=<span class="cstat-no" title="statement not covered" >i.day===undefined?i.date:i.day;<span class="cstat-no" title="statement not covered" ></span>config._a=map([i.year,i.month,dayOrDate,i.hour,i.minute,i.second,i.millisecond],<span class="fstat-no" title="function not covered" >fu</span>nction(obj){<span class="cstat-no" title="statement not covered" >return obj&amp;&amp;parseInt(obj,10);}</span>);<span class="cstat-no" title="statement not covered" >c</span>onfigFromArray(config);}</span>function <span class="fstat-no" title="function not covered" >createFromConfig(</span>config){var res=<span class="cstat-no" title="statement not covered" >new Moment(checkOverflow(prepareConfig(config)));<span class="cstat-no" title="statement not covered" ></span>if(res._nextDay){// Adding is smart enough around DST</span>
<span class="cstat-no" title="statement not covered" >res.add(1,'d');<span class="cstat-no" title="statement not covered" >r</span>es._nextDay=undefined;}<span class="cstat-no" title="statement not covered" ></span>return res;}</span>function <span class="fstat-no" title="function not covered" >prepareConfig(</span>config){var input=<span class="cstat-no" title="statement not covered" >config._i,</span>format=<span class="cstat-no" title="statement not covered" >config._f;<span class="cstat-no" title="statement not covered" ></span>config._locale=config._locale||getLocale(config._l);<span class="cstat-no" title="statement not covered" >i</span>f(input===null||format===undefined&amp;&amp;input===''){<span class="cstat-no" title="statement not covered" >return createInvalid({nullInput:true});}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof input==='string'){<span class="cstat-no" title="statement not covered" >config._i=input=config._locale.preparse(input);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isMoment(input)){<span class="cstat-no" title="statement not covered" >return new Moment(checkOverflow(input));}</span>else <span class="cstat-no" title="statement not covered" >if(isDate(input)){<span class="cstat-no" title="statement not covered" >config._d=input;}</span>else <span class="cstat-no" title="statement not covered" >if(isArray(format)){<span class="cstat-no" title="statement not covered" >configFromStringAndArray(config);}</span>else <span class="cstat-no" title="statement not covered" >if(format){<span class="cstat-no" title="statement not covered" >configFromStringAndFormat(config);}</span>else{<span class="cstat-no" title="statement not covered" >configFromInput(config);}<span class="cstat-no" title="statement not covered" ></span>i</span></span></span></span>f(!isValid(config)){<span class="cstat-no" title="statement not covered" >config._d=null;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn config;}</span>function <span class="fstat-no" title="function not covered" >configFromInput(</span>config){var input=<span class="cstat-no" title="statement not covered" >config._i;<span class="cstat-no" title="statement not covered" ></span>if(isUndefined(input)){<span class="cstat-no" title="statement not covered" >config._d=new Date(hooks.now());}</span>else <span class="cstat-no" title="statement not covered" >if(isDate(input)){<span class="cstat-no" title="statement not covered" >config._d=new Date(input.valueOf());}</span>else <span class="cstat-no" title="statement not covered" >if(typeof input==='string'){<span class="cstat-no" title="statement not covered" >configFromString(config);}</span>else <span class="cstat-no" title="statement not covered" >if(isArray(input)){<span class="cstat-no" title="statement not covered" >config._a=map(input.slice(0),<span class="fstat-no" title="function not covered" >fu</span>nction(obj){<span class="cstat-no" title="statement not covered" >return parseInt(obj,10);}</span>);<span class="cstat-no" title="statement not covered" >c</span>onfigFromArray(config);}</span>else <span class="cstat-no" title="statement not covered" >if(isObject(input)){<span class="cstat-no" title="statement not covered" >configFromObject(config);}</span>else <span class="cstat-no" title="statement not covered" >if(isNumber(input)){// from milliseconds</span></span></span></span></span></span>
<span class="cstat-no" title="statement not covered" >config._d=new Date(input);}</span>else{<span class="cstat-no" title="statement not covered" >hooks.createFromInputFallback(config);}</span>}function <span class="fstat-no" title="function not covered" >createLocalOrUTC(</span>input,format,locale,strict,isUTC){var c=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(format===true||format===false){<span class="cstat-no" title="statement not covered" >strict=format;<span class="cstat-no" title="statement not covered" >f</span>ormat=undefined;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(locale===true||locale===false){<span class="cstat-no" title="statement not covered" >strict=locale;<span class="cstat-no" title="statement not covered" >l</span>ocale=undefined;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isObject(input)&amp;&amp;isObjectEmpty(input)||isArray(input)&amp;&amp;input.length===0){<span class="cstat-no" title="statement not covered" >input=undefined;}</span>/</span>/ object construction must be done this way.
// https://github.com/moment/moment/issues/1423
<span class="cstat-no" title="statement not covered" >c._isAMomentObject=true;<span class="cstat-no" title="statement not covered" >c</span>._useUTC=c._isUTC=isUTC;<span class="cstat-no" title="statement not covered" >c</span>._l=locale;<span class="cstat-no" title="statement not covered" >c</span>._i=input;<span class="cstat-no" title="statement not covered" >c</span>._f=format;<span class="cstat-no" title="statement not covered" >c</span>._strict=strict;<span class="cstat-no" title="statement not covered" >r</span>eturn createFromConfig(c);}</span>function <span class="fstat-no" title="function not covered" >createLocal(</span>input,format,locale,strict){<span class="cstat-no" title="statement not covered" >return createLocalOrUTC(input,format,locale,strict,false);}</span>var prototypeMin=<span class="cstat-no" title="statement not covered" >deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',<span class="fstat-no" title="function not covered" >fu</span>nction(){var other=<span class="cstat-no" title="statement not covered" >createLocal.apply(null,arguments);<span class="cstat-no" title="statement not covered" ></span>if(this.isValid()&amp;&amp;other.isValid()){<span class="cstat-no" title="statement not covered" >return other&lt;this?this:other;}</span>else{<span class="cstat-no" title="statement not covered" >return createInvalid();}</span>}</span>),</span>prototypeMax=<span class="cstat-no" title="statement not covered" >deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',<span class="fstat-no" title="function not covered" >fu</span>nction(){var other=<span class="cstat-no" title="statement not covered" >createLocal.apply(null,arguments);<span class="cstat-no" title="statement not covered" ></span>if(this.isValid()&amp;&amp;other.isValid()){<span class="cstat-no" title="statement not covered" >return other&gt;this?this:other;}</span>else{<span class="cstat-no" title="statement not covered" >return createInvalid();}</span>}</span>);</span>// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function <span class="fstat-no" title="function not covered" >pickBy(</span>fn,moments){var res,i;<span class="cstat-no" title="statement not covered" >if(moments.length===1&amp;&amp;isArray(moments[0])){<span class="cstat-no" title="statement not covered" >moments=moments[0];}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!moments.length){<span class="cstat-no" title="statement not covered" >return createLocal();}<span class="cstat-no" title="statement not covered" ></span>r</span>es=moments[0];<span class="cstat-no" title="statement not covered" >f</span>or(i=1;i&lt;moments.length;++i){<span class="cstat-no" title="statement not covered" >if(!moments[i].isValid()||moments[i][fn](res)){<span class="cstat-no" title="statement not covered" >res=moments[i];}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn res;}</span>// TODO: Use [].sort instead?
function <span class="fstat-no" title="function not covered" >min(</span>){var args=<span class="cstat-no" title="statement not covered" >[].slice.call(arguments,0);<span class="cstat-no" title="statement not covered" ></span>return pickBy('isBefore',args);}</span>function <span class="fstat-no" title="function not covered" >max(</span>){var args=<span class="cstat-no" title="statement not covered" >[].slice.call(arguments,0);<span class="cstat-no" title="statement not covered" ></span>return pickBy('isAfter',args);}</span>var now=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Date.now?Date.now():+new Date();}</span>;</span>var ordering=<span class="cstat-no" title="statement not covered" >['year','quarter','month','week','day','hour','minute','second','millisecond'];</span>function <span class="fstat-no" title="function not covered" >isDurationValid(</span>m){var key,unitHasDecimal=<span class="cstat-no" title="statement not covered" >false,</span>i;<span class="cstat-no" title="statement not covered" >for(key in m){<span class="cstat-no" title="statement not covered" >if(hasOwnProp(m,key)&amp;&amp;!(indexOf.call(ordering,key)!==-1&amp;&amp;(m[key]==null||!isNaN(m[key])))){<span class="cstat-no" title="statement not covered" >return false;}</span>}<span class="cstat-no" title="statement not covered" ></span>f</span>or(i=0;i&lt;ordering.length;++i){<span class="cstat-no" title="statement not covered" >if(m[ordering[i]]){<span class="cstat-no" title="statement not covered" >if(unitHasDecimal){<span class="cstat-no" title="statement not covered" >return false;/</span>/ only allow non-integers for smallest unit</span></span></span>
}<span class="cstat-no" title="statement not covered" >if(parseFloat(m[ordering[i]])!==toInt(m[ordering[i]])){<span class="cstat-no" title="statement not covered" >unitHasDecimal=true;}</span>}</span>}<span class="cstat-no" title="statement not covered" >return true;}</span>function <span class="fstat-no" title="function not covered" >isValid$1(</span>){<span class="cstat-no" title="statement not covered" >return this._isValid;}</span>function <span class="fstat-no" title="function not covered" >createInvalid$1(</span>){<span class="cstat-no" title="statement not covered" >return createDuration(NaN);}</span>function <span class="fstat-no" title="function not covered" >Duration(</span>duration){var normalizedInput=<span class="cstat-no" title="statement not covered" >normalizeObjectUnits(duration),</span>years=<span class="cstat-no" title="statement not covered" >normalizedInput.year||0,</span>quarters=<span class="cstat-no" title="statement not covered" >normalizedInput.quarter||0,</span>months=<span class="cstat-no" title="statement not covered" >normalizedInput.month||0,</span>weeks=<span class="cstat-no" title="statement not covered" >normalizedInput.week||normalizedInput.isoWeek||0,</span>days=<span class="cstat-no" title="statement not covered" >normalizedInput.day||0,</span>hours=<span class="cstat-no" title="statement not covered" >normalizedInput.hour||0,</span>minutes=<span class="cstat-no" title="statement not covered" >normalizedInput.minute||0,</span>seconds=<span class="cstat-no" title="statement not covered" >normalizedInput.second||0,</span>milliseconds=<span class="cstat-no" title="statement not covered" >normalizedInput.millisecond||0;<span class="cstat-no" title="statement not covered" ></span>this._isValid=isDurationValid(normalizedInput);/</span>/ representation for dateAddRemove
<span class="cstat-no" title="statement not covered" >this._milliseconds=+milliseconds+seconds*1e3+// 1000</span>
minutes*6e4+// 1000 * 60
hours*1000*60*60;//using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
// Because of dateAddRemove treats 24 hours as different from a
// day when working around DST, we need to store them separately
<span class="cstat-no" title="statement not covered" >this._days=+days+weeks*7;/</span>/ It is impossible to translate months into days without knowing
// which months you are are talking about, so we have to store
// it separately.
<span class="cstat-no" title="statement not covered" >this._months=+months+quarters*3+years*12;<span class="cstat-no" title="statement not covered" >t</span>his._data={};<span class="cstat-no" title="statement not covered" >t</span>his._locale=getLocale();<span class="cstat-no" title="statement not covered" >t</span>his._bubble();}</span>function <span class="fstat-no" title="function not covered" >isDuration(</span>obj){<span class="cstat-no" title="statement not covered" >return obj instanceof Duration;}</span>function <span class="fstat-no" title="function not covered" >absRound(</span>number){<span class="cstat-no" title="statement not covered" >if(number&lt;0){<span class="cstat-no" title="statement not covered" >return Math.round(-1*number)*-1;}</span>else{<span class="cstat-no" title="statement not covered" >return Math.round(number);}</span>}</span>// compare two arrays, return the number of differences
function <span class="fstat-no" title="function not covered" >compareArrays(</span>array1,array2,dontConvert){var len=<span class="cstat-no" title="statement not covered" >Math.min(array1.length,array2.length),</span>lengthDiff=<span class="cstat-no" title="statement not covered" >Math.abs(array1.length-array2.length),</span>diffs=<span class="cstat-no" title="statement not covered" >0,</span>i;<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;len;i++){<span class="cstat-no" title="statement not covered" >if(dontConvert&amp;&amp;array1[i]!==array2[i]||!dontConvert&amp;&amp;toInt(array1[i])!==toInt(array2[i])){<span class="cstat-no" title="statement not covered" >diffs++;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn diffs+lengthDiff;}</span>// FORMATTING
function <span class="fstat-no" title="function not covered" >offset(</span>token,separator){<span class="cstat-no" title="statement not covered" >addFormatToken(token,0,0,<span class="fstat-no" title="function not covered" >fu</span>nction(){var offset=<span class="cstat-no" title="statement not covered" >this.utcOffset(),</span>sign=<span class="cstat-no" title="statement not covered" >'+';<span class="cstat-no" title="statement not covered" ></span>if(offset&lt;0){<span class="cstat-no" title="statement not covered" >offset=-offset;<span class="cstat-no" title="statement not covered" >s</span>ign='-';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn sign+zeroFill(~~(offset/60),2)+separator+zeroFill(~~offset%60,2);}</span>);}<span class="cstat-no" title="statement not covered" ></span>offset('Z',':');<span class="cstat-no" title="statement not covered" >o</span>ffset('ZZ','');/</span>/ PARSING
<span class="cstat-no" title="statement not covered" >addRegexToken('Z',matchShortOffset);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('ZZ',matchShortOffset);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken(['Z','ZZ'],<span class="fstat-no" title="function not covered" >fu</span>nction(input,array,config){<span class="cstat-no" title="statement not covered" >config._useUTC=true;<span class="cstat-no" title="statement not covered" >c</span>onfig._tzm=offsetFromString(matchShortOffset,input);}</span>);/</span>/ HELPERS
// timezone chunker
// '+10:00' &gt; ['10',  '00']
// '-1530'  &gt; ['-15', '30']
var chunkOffset=<span class="cstat-no" title="statement not covered" >/([\+\-]|\d\d)/gi;</span>function <span class="fstat-no" title="function not covered" >offsetFromString(</span>matcher,string){var matches=<span class="cstat-no" title="statement not covered" >(string||'').match(matcher),</span>chunk,parts,minutes;<span class="cstat-no" title="statement not covered" >if(matches===null){<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>c</span>hunk=matches[matches.length-1]||[];<span class="cstat-no" title="statement not covered" >p</span>arts=(chunk+'').match(chunkOffset)||['-',0,0];<span class="cstat-no" title="statement not covered" >m</span>inutes=+(parts[1]*60)+toInt(parts[2]);<span class="cstat-no" title="statement not covered" >r</span>eturn minutes===0?0:parts[0]==='+'?minutes:-minutes;}</span>// Return a moment from input, that is local/utc/zone equivalent to model.
function <span class="fstat-no" title="function not covered" >cloneWithOffset(</span>input,model){var res,diff;<span class="cstat-no" title="statement not covered" >if(model._isUTC){<span class="cstat-no" title="statement not covered" >res=model.clone();<span class="cstat-no" title="statement not covered" >d</span>iff=(isMoment(input)||isDate(input)?input.valueOf():createLocal(input).valueOf())-res.valueOf();/</span>/ Use low-level api, because this fn is low-level api.</span>
<span class="cstat-no" title="statement not covered" >res._d.setTime(res._d.valueOf()+diff);<span class="cstat-no" title="statement not covered" >h</span>ooks.updateOffset(res,false);<span class="cstat-no" title="statement not covered" >r</span>eturn res;}</span>else{<span class="cstat-no" title="statement not covered" >return createLocal(input).local();}</span>}function <span class="fstat-no" title="function not covered" >getDateOffset(</span>m){// On Firefox.24 Date#getTimezoneOffset returns a floating point.
// https://github.com/moment/moment/pull/1871
<span class="cstat-no" title="statement not covered" >return-Math.round(m._d.getTimezoneOffset());}</span>// HOOKS
// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
<span class="cstat-no" title="statement not covered" >hooks.updateOffset=<span class="fstat-no" title="function not covered" >fu</span>nction(){};/</span>/ MOMENTS
// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]--&gt;
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function <span class="fstat-no" title="function not covered" >getSetOffset(</span>input,keepLocalTime,keepMinutes){var offset=<span class="cstat-no" title="statement not covered" >this._offset||0,</span>localAdjust;<span class="cstat-no" title="statement not covered" >if(!this.isValid()){<span class="cstat-no" title="statement not covered" >return input!=null?this:NaN;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(input!=null){<span class="cstat-no" title="statement not covered" >if(typeof input==='string'){<span class="cstat-no" title="statement not covered" >input=offsetFromString(matchShortOffset,input);<span class="cstat-no" title="statement not covered" >i</span>f(input===null){<span class="cstat-no" title="statement not covered" >return this;}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(Math.abs(input)&lt;16&amp;&amp;!keepMinutes){<span class="cstat-no" title="statement not covered" >input=input*60;}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(!this._isUTC&amp;&amp;keepLocalTime){<span class="cstat-no" title="statement not covered" >localAdjust=getDateOffset(this);}<span class="cstat-no" title="statement not covered" ></span>t</span>his._offset=input;<span class="cstat-no" title="statement not covered" >t</span>his._isUTC=true;<span class="cstat-no" title="statement not covered" >i</span>f(localAdjust!=null){<span class="cstat-no" title="statement not covered" >this.add(localAdjust,'m');}<span class="cstat-no" title="statement not covered" ></span>i</span>f(offset!==input){<span class="cstat-no" title="statement not covered" >if(!keepLocalTime||this._changeInProgress){<span class="cstat-no" title="statement not covered" >addSubtract(this,createDuration(input-offset,'m'),1,false);}</span>else <span class="cstat-no" title="statement not covered" >if(!this._changeInProgress){<span class="cstat-no" title="statement not covered" >this._changeInProgress=true;<span class="cstat-no" title="statement not covered" >h</span>ooks.updateOffset(this,true);<span class="cstat-no" title="statement not covered" >t</span>his._changeInProgress=null;}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn this;}</span>else{<span class="cstat-no" title="statement not covered" >return this._isUTC?offset:getDateOffset(this);}</span>}</span>function <span class="fstat-no" title="function not covered" >getSetZone(</span>input,keepLocalTime){<span class="cstat-no" title="statement not covered" >if(input!=null){<span class="cstat-no" title="statement not covered" >if(typeof input!=='string'){<span class="cstat-no" title="statement not covered" >input=-input;}<span class="cstat-no" title="statement not covered" ></span>t</span>his.utcOffset(input,keepLocalTime);<span class="cstat-no" title="statement not covered" >r</span>eturn this;}</span>else{<span class="cstat-no" title="statement not covered" >return-this.utcOffset();}</span>}</span>function <span class="fstat-no" title="function not covered" >setOffsetToUTC(</span>keepLocalTime){<span class="cstat-no" title="statement not covered" >return this.utcOffset(0,keepLocalTime);}</span>function <span class="fstat-no" title="function not covered" >setOffsetToLocal(</span>keepLocalTime){<span class="cstat-no" title="statement not covered" >if(this._isUTC){<span class="cstat-no" title="statement not covered" >this.utcOffset(0,keepLocalTime);<span class="cstat-no" title="statement not covered" >t</span>his._isUTC=false;<span class="cstat-no" title="statement not covered" >i</span>f(keepLocalTime){<span class="cstat-no" title="statement not covered" >this.subtract(getDateOffset(this),'m');}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this;}</span>function <span class="fstat-no" title="function not covered" >setOffsetToParsedOffset(</span>){<span class="cstat-no" title="statement not covered" >if(this._tzm!=null){<span class="cstat-no" title="statement not covered" >this.utcOffset(this._tzm,false,true);}</span>else <span class="cstat-no" title="statement not covered" >if(typeof this._i==='string'){var tZone=<span class="cstat-no" title="statement not covered" >offsetFromString(matchOffset,this._i);<span class="cstat-no" title="statement not covered" ></span>if(tZone!=null){<span class="cstat-no" title="statement not covered" >this.utcOffset(tZone);}</span>else{<span class="cstat-no" title="statement not covered" >this.utcOffset(0,true);}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn this;}</span>function <span class="fstat-no" title="function not covered" >hasAlignedHourOffset(</span>input){<span class="cstat-no" title="statement not covered" >if(!this.isValid()){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>i</span>nput=input?createLocal(input).utcOffset():0;<span class="cstat-no" title="statement not covered" >r</span>eturn(this.utcOffset()-input)%60===0;}</span>function <span class="fstat-no" title="function not covered" >isDaylightSavingTime(</span>){<span class="cstat-no" title="statement not covered" >return this.utcOffset()&gt;this.clone().month(0).utcOffset()||this.utcOffset()&gt;this.clone().month(5).utcOffset();}</span>function <span class="fstat-no" title="function not covered" >isDaylightSavingTimeShifted(</span>){<span class="cstat-no" title="statement not covered" >if(!isUndefined(this._isDSTShifted)){<span class="cstat-no" title="statement not covered" >return this._isDSTShifted;}</span>v</span>ar c=<span class="cstat-no" title="statement not covered" >{},</span>other;<span class="cstat-no" title="statement not covered" >copyConfig(c,this);<span class="cstat-no" title="statement not covered" >c</span>=prepareConfig(c);<span class="cstat-no" title="statement not covered" >i</span>f(c._a){<span class="cstat-no" title="statement not covered" >other=c._isUTC?createUTC(c._a):createLocal(c._a);<span class="cstat-no" title="statement not covered" >t</span>his._isDSTShifted=this.isValid()&amp;&amp;compareArrays(c._a,other.toArray())&gt;0;}</span>else{<span class="cstat-no" title="statement not covered" >this._isDSTShifted=false;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._isDSTShifted;}</span>function <span class="fstat-no" title="function not covered" >isLocal(</span>){<span class="cstat-no" title="statement not covered" >return this.isValid()?!this._isUTC:false;}</span>function <span class="fstat-no" title="function not covered" >isUtcOffset(</span>){<span class="cstat-no" title="statement not covered" >return this.isValid()?this._isUTC:false;}</span>function <span class="fstat-no" title="function not covered" >isUtc(</span>){<span class="cstat-no" title="statement not covered" >return this.isValid()?this._isUTC&amp;&amp;this._offset===0:false;}</span>// ASP.NET json date format regex
var aspNetRegex=<span class="cstat-no" title="statement not covered" >/^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,</span>// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
isoRegex=<span class="cstat-no" title="statement not covered" >/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;</span>function <span class="fstat-no" title="function not covered" >createDuration(</span>input,key){var duration=<span class="cstat-no" title="statement not covered" >input,</span>// matching against regexp is expensive, do it on demand
match=<span class="cstat-no" title="statement not covered" >null,</span>sign,ret,diffRes;<span class="cstat-no" title="statement not covered" >if(isDuration(input)){<span class="cstat-no" title="statement not covered" >duration={ms:input._milliseconds,d:input._days,M:input._months};}</span>else <span class="cstat-no" title="statement not covered" >if(isNumber(input)||!isNaN(+input)){<span class="cstat-no" title="statement not covered" >duration={};<span class="cstat-no" title="statement not covered" >i</span>f(key){<span class="cstat-no" title="statement not covered" >duration[key]=+input;}</span>else{<span class="cstat-no" title="statement not covered" >duration.milliseconds=+input;}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(match=aspNetRegex.exec(input)){<span class="cstat-no" title="statement not covered" >sign=match[1]==='-'?-1:1;<span class="cstat-no" title="statement not covered" >d</span>uration={y:0,d:toInt(match[DATE])*sign,h:toInt(match[HOUR])*sign,m:toInt(match[MINUTE])*sign,s:toInt(match[SECOND])*sign,ms:toInt(absRound(match[MILLISECOND]*1000))*sign// the millisecond decimal point is included in the match</span></span></span></span>
};}else <span class="cstat-no" title="statement not covered" >if(match=isoRegex.exec(input)){<span class="cstat-no" title="statement not covered" >sign=match[1]==='-'?-1:1;<span class="cstat-no" title="statement not covered" >d</span>uration={y:parseIso(match[2],sign),M:parseIso(match[3],sign),w:parseIso(match[4],sign),d:parseIso(match[5],sign),h:parseIso(match[6],sign),m:parseIso(match[7],sign),s:parseIso(match[8],sign)};}</span>else <span class="cstat-no" title="statement not covered" >if(duration==null){// checks for null or undefined</span></span>
<span class="cstat-no" title="statement not covered" >duration={};}</span>else <span class="cstat-no" title="statement not covered" >if(typeof duration==='object'&amp;&amp;('from'in duration||'to'in duration)){<span class="cstat-no" title="statement not covered" >diffRes=momentsDifference(createLocal(duration.from),createLocal(duration.to));<span class="cstat-no" title="statement not covered" >d</span>uration={};<span class="cstat-no" title="statement not covered" >d</span>uration.ms=diffRes.milliseconds;<span class="cstat-no" title="statement not covered" >d</span>uration.M=diffRes.months;}<span class="cstat-no" title="statement not covered" ></span>r</span>et=new Duration(duration);<span class="cstat-no" title="statement not covered" >i</span>f(isDuration(input)&amp;&amp;hasOwnProp(input,'_locale')){<span class="cstat-no" title="statement not covered" >ret._locale=input._locale;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isDuration(input)&amp;&amp;hasOwnProp(input,'_isValid')){<span class="cstat-no" title="statement not covered" >ret._isValid=input._isValid;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn ret;}<span class="cstat-no" title="statement not covered" ></span>createDuration.fn=Duration.prototype;<span class="cstat-no" title="statement not covered" >c</span>reateDuration.invalid=createInvalid$1;f</span>unction <span class="fstat-no" title="function not covered" >parseIso(</span>inp,sign){// We'd normally use ~~inp for this, but unfortunately it also
// converts floats to ints.
// inp may be undefined, so careful calling replace on it.
var res=<span class="cstat-no" title="statement not covered" >inp&amp;&amp;parseFloat(inp.replace(',','.'));</span>// apply sign while we're at it
<span class="cstat-no" title="statement not covered" >return(isNaN(res)?0:res)*sign;}</span>function <span class="fstat-no" title="function not covered" >positiveMomentsDifference(</span>base,other){var res=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>res.months=other.month()-base.month()+(other.year()-base.year())*12;<span class="cstat-no" title="statement not covered" >i</span>f(base.clone().add(res.months,'M').isAfter(other)){<span class="cstat-no" title="statement not covered" >--res.months;}<span class="cstat-no" title="statement not covered" ></span>r</span>es.milliseconds=+other-+base.clone().add(res.months,'M');<span class="cstat-no" title="statement not covered" >r</span>eturn res;}</span>function <span class="fstat-no" title="function not covered" >momentsDifference(</span>base,other){var res;<span class="cstat-no" title="statement not covered" >if(!(base.isValid()&amp;&amp;other.isValid())){<span class="cstat-no" title="statement not covered" >return{milliseconds:0,months:0};}<span class="cstat-no" title="statement not covered" ></span>o</span>ther=cloneWithOffset(other,base);<span class="cstat-no" title="statement not covered" >i</span>f(base.isBefore(other)){<span class="cstat-no" title="statement not covered" >res=positiveMomentsDifference(base,other);}</span>else{<span class="cstat-no" title="statement not covered" >res=positiveMomentsDifference(other,base);<span class="cstat-no" title="statement not covered" >r</span>es.milliseconds=-res.milliseconds;<span class="cstat-no" title="statement not covered" >r</span>es.months=-res.months;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn res;}</span>// TODO: remove 'name' arg after deprecation is removed
function <span class="fstat-no" title="function not covered" >createAdder(</span>direction,name){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(val,period){var dur,tmp;//invert the arguments, but complain about it</span>
<span class="cstat-no" title="statement not covered" >if(period!==null&amp;&amp;!isNaN(+period)){<span class="cstat-no" title="statement not covered" >deprecateSimple(name,'moment().'+name+'(period, number) is deprecated. Please use moment().'+name+'(number, period). '+'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');<span class="cstat-no" title="statement not covered" >t</span>mp=val;<span class="cstat-no" title="statement not covered" >v</span>al=period;<span class="cstat-no" title="statement not covered" >p</span>eriod=tmp;}<span class="cstat-no" title="statement not covered" ></span>d</span>ur=createDuration(val,period);<span class="cstat-no" title="statement not covered" >a</span>ddSubtract(this,dur,direction);<span class="cstat-no" title="statement not covered" >r</span>eturn this;}</span>;}function <span class="fstat-no" title="function not covered" >addSubtract(</span>mom,duration,isAdding,updateOffset){var milliseconds=<span class="cstat-no" title="statement not covered" >duration._milliseconds,</span>days=<span class="cstat-no" title="statement not covered" >absRound(duration._days),</span>months=<span class="cstat-no" title="statement not covered" >absRound(duration._months);<span class="cstat-no" title="statement not covered" ></span>if(!mom.isValid()){// No op</span>
<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>updateOffset=updateOffset==null?true:updateOffset;<span class="cstat-no" title="statement not covered" >i</span>f(months){<span class="cstat-no" title="statement not covered" >setMonth(mom,get(mom,'Month')+months*isAdding);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(days){<span class="cstat-no" title="statement not covered" >set$1(mom,'Date',get(mom,'Date')+days*isAdding);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(milliseconds){<span class="cstat-no" title="statement not covered" >mom._d.setTime(mom._d.valueOf()+milliseconds*isAdding);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(updateOffset){<span class="cstat-no" title="statement not covered" >hooks.updateOffset(mom,days||months);}</span>}</span>var add=<span class="cstat-no" title="statement not covered" >createAdder(1,'add'),</span>subtract=<span class="cstat-no" title="statement not covered" >createAdder(-1,'subtract');</span>function <span class="fstat-no" title="function not covered" >isString(</span>input){<span class="cstat-no" title="statement not covered" >return typeof input==='string'||input instanceof String;}</span>// identifierDescription MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
function <span class="fstat-no" title="function not covered" >isMomentInput(</span>input){<span class="cstat-no" title="statement not covered" >return isMoment(input)||isDate(input)||isString(input)||isNumber(input)||isNumberOrStringArray(input)||isMomentInputObject(input)||input===null||input===undefined;}</span>function <span class="fstat-no" title="function not covered" >isMomentInputObject(</span>input){var objectTest=<span class="cstat-no" title="statement not covered" >isObject(input)&amp;&amp;!isObjectEmpty(input),</span>propertyTest=<span class="cstat-no" title="statement not covered" >false,</span>properties=<span class="cstat-no" title="statement not covered" >['years','year','y','months','month','M','days','day','d','dates','date','D','hours','hour','h','minutes','minute','m','seconds','second','s','milliseconds','millisecond','ms'],</span>i,property;<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;properties.length;i+=1){<span class="cstat-no" title="statement not covered" >property=properties[i];<span class="cstat-no" title="statement not covered" >p</span>ropertyTest=propertyTest||hasOwnProp(input,property);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn objectTest&amp;&amp;propertyTest;}</span>function <span class="fstat-no" title="function not covered" >isNumberOrStringArray(</span>input){var arrayTest=<span class="cstat-no" title="statement not covered" >isArray(input),</span>dataTypeTest=<span class="cstat-no" title="statement not covered" >false;<span class="cstat-no" title="statement not covered" ></span>if(arrayTest){<span class="cstat-no" title="statement not covered" >dataTypeTest=input.filter(<span class="fstat-no" title="function not covered" >fu</span>nction(item){<span class="cstat-no" title="statement not covered" >return!isNumber(item)&amp;&amp;isString(input);}</span>).length===0;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn arrayTest&amp;&amp;dataTypeTest;}</span>function <span class="fstat-no" title="function not covered" >isCalendarSpec(</span>input){var objectTest=<span class="cstat-no" title="statement not covered" >isObject(input)&amp;&amp;!isObjectEmpty(input),</span>propertyTest=<span class="cstat-no" title="statement not covered" >false,</span>properties=<span class="cstat-no" title="statement not covered" >['sameDay','nextDay','lastDay','nextWeek','lastWeek','sameElse'],</span>i,property;<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;properties.length;i+=1){<span class="cstat-no" title="statement not covered" >property=properties[i];<span class="cstat-no" title="statement not covered" >p</span>ropertyTest=propertyTest||hasOwnProp(input,property);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn objectTest&amp;&amp;propertyTest;}</span>function <span class="fstat-no" title="function not covered" >getCalendarFormat(</span>myMoment,now){var diff=<span class="cstat-no" title="statement not covered" >myMoment.diff(now,'days',true);<span class="cstat-no" title="statement not covered" ></span>return diff&lt;-6?'sameElse':diff&lt;-1?'lastWeek':diff&lt;0?'lastDay':diff&lt;1?'sameDay':diff&lt;2?'nextDay':diff&lt;7?'nextWeek':'sameElse';}</span>function <span class="fstat-no" title="function not covered" >calendar$1(</span>time,formats){// Support for single parameter, formats only overload to the calendar function
<span class="cstat-no" title="statement not covered" >if(arguments.length===1){<span class="cstat-no" title="statement not covered" >if(!arguments[0]){<span class="cstat-no" title="statement not covered" >time=undefined;<span class="cstat-no" title="statement not covered" >f</span>ormats=undefined;}</span>else <span class="cstat-no" title="statement not covered" >if(isMomentInput(arguments[0])){<span class="cstat-no" title="statement not covered" >time=arguments[0];<span class="cstat-no" title="statement not covered" >f</span>ormats=undefined;}</span>else <span class="cstat-no" title="statement not covered" >if(isCalendarSpec(arguments[0])){<span class="cstat-no" title="statement not covered" >formats=arguments[0];<span class="cstat-no" title="statement not covered" >t</span>ime=undefined;}</span>}</span></span></span>/</span>/ We want to compare the start of today, vs this.
// Getting start-of-today depends on whether we're local/utc/offset or not.
var now=<span class="cstat-no" title="statement not covered" >time||createLocal(),</span>sod=<span class="cstat-no" title="statement not covered" >cloneWithOffset(now,this).startOf('day'),</span>format=<span class="cstat-no" title="statement not covered" >hooks.calendarFormat(this,sod)||'sameElse',</span>output=<span class="cstat-no" title="statement not covered" >formats&amp;&amp;(isFunction(formats[format])?formats[format].call(this,now):formats[format]);<span class="cstat-no" title="statement not covered" ></span>return this.format(output||this.localeData().calendar(format,this,createLocal(now)));}</span>function <span class="fstat-no" title="function not covered" >clone(</span>){<span class="cstat-no" title="statement not covered" >return new Moment(this);}</span>function <span class="fstat-no" title="function not covered" >isAfter(</span>input,units){var localInput=<span class="cstat-no" title="statement not covered" >isMoment(input)?input:createLocal(input);<span class="cstat-no" title="statement not covered" ></span>if(!(this.isValid()&amp;&amp;localInput.isValid())){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>u</span>nits=normalizeUnits(units)||'millisecond';<span class="cstat-no" title="statement not covered" >i</span>f(units==='millisecond'){<span class="cstat-no" title="statement not covered" >return this.valueOf()&gt;localInput.valueOf();}</span>else{<span class="cstat-no" title="statement not covered" >return localInput.valueOf()&lt;this.clone().startOf(units).valueOf();}</span>}</span>function <span class="fstat-no" title="function not covered" >isBefore(</span>input,units){var localInput=<span class="cstat-no" title="statement not covered" >isMoment(input)?input:createLocal(input);<span class="cstat-no" title="statement not covered" ></span>if(!(this.isValid()&amp;&amp;localInput.isValid())){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>u</span>nits=normalizeUnits(units)||'millisecond';<span class="cstat-no" title="statement not covered" >i</span>f(units==='millisecond'){<span class="cstat-no" title="statement not covered" >return this.valueOf()&lt;localInput.valueOf();}</span>else{<span class="cstat-no" title="statement not covered" >return this.clone().endOf(units).valueOf()&lt;localInput.valueOf();}</span>}</span>function <span class="fstat-no" title="function not covered" >isBetween(</span>from,to,units,inclusivity){var localFrom=<span class="cstat-no" title="statement not covered" >isMoment(from)?from:createLocal(from),</span>localTo=<span class="cstat-no" title="statement not covered" >isMoment(to)?to:createLocal(to);<span class="cstat-no" title="statement not covered" ></span>if(!(this.isValid()&amp;&amp;localFrom.isValid()&amp;&amp;localTo.isValid())){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>i</span>nclusivity=inclusivity||'()';<span class="cstat-no" title="statement not covered" >r</span>eturn(inclusivity[0]==='('?this.isAfter(localFrom,units):!this.isBefore(localFrom,units))&amp;&amp;(inclusivity[1]===')'?this.isBefore(localTo,units):!this.isAfter(localTo,units));}</span>function <span class="fstat-no" title="function not covered" >isSame(</span>input,units){var localInput=<span class="cstat-no" title="statement not covered" >isMoment(input)?input:createLocal(input),</span>inputMs;<span class="cstat-no" title="statement not covered" >if(!(this.isValid()&amp;&amp;localInput.isValid())){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>u</span>nits=normalizeUnits(units)||'millisecond';<span class="cstat-no" title="statement not covered" >i</span>f(units==='millisecond'){<span class="cstat-no" title="statement not covered" >return this.valueOf()===localInput.valueOf();}</span>else{<span class="cstat-no" title="statement not covered" >inputMs=localInput.valueOf();<span class="cstat-no" title="statement not covered" >r</span>eturn this.clone().startOf(units).valueOf()&lt;=inputMs&amp;&amp;inputMs&lt;=this.clone().endOf(units).valueOf();}</span>}</span>function <span class="fstat-no" title="function not covered" >isSameOrAfter(</span>input,units){<span class="cstat-no" title="statement not covered" >return this.isSame(input,units)||this.isAfter(input,units);}</span>function <span class="fstat-no" title="function not covered" >isSameOrBefore(</span>input,units){<span class="cstat-no" title="statement not covered" >return this.isSame(input,units)||this.isBefore(input,units);}</span>function <span class="fstat-no" title="function not covered" >diff(</span>input,units,asFloat){var that,zoneDelta,output;<span class="cstat-no" title="statement not covered" >if(!this.isValid()){<span class="cstat-no" title="statement not covered" >return NaN;}<span class="cstat-no" title="statement not covered" ></span>t</span>hat=cloneWithOffset(input,this);<span class="cstat-no" title="statement not covered" >i</span>f(!that.isValid()){<span class="cstat-no" title="statement not covered" >return NaN;}<span class="cstat-no" title="statement not covered" ></span>z</span>oneDelta=(that.utcOffset()-this.utcOffset())*6e4;<span class="cstat-no" title="statement not covered" >u</span>nits=normalizeUnits(units);<span class="cstat-no" title="statement not covered" >s</span>witch(units){case'year':<span class="cstat-no" title="statement not covered" >output=monthDiff(this,that)/12;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'month':<span class="cstat-no" title="statement not covered" >output=monthDiff(this,that);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'quarter':<span class="cstat-no" title="statement not covered" >output=monthDiff(this,that)/3;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'second':<span class="cstat-no" title="statement not covered" >output=(this-that)/1e3;<span class="cstat-no" title="statement not covered" >b</span>reak;/</span>/ 1000</span>
case'minute':<span class="cstat-no" title="statement not covered" >output=(this-that)/6e4;<span class="cstat-no" title="statement not covered" >b</span>reak;/</span>/ 1000 * 60
case'hour':<span class="cstat-no" title="statement not covered" >output=(this-that)/36e5;<span class="cstat-no" title="statement not covered" >b</span>reak;/</span>/ 1000 * 60 * 60
case'day':<span class="cstat-no" title="statement not covered" >output=(this-that-zoneDelta)/864e5;<span class="cstat-no" title="statement not covered" >b</span>reak;/</span>/ 1000 * 60 * 60 * 24, negate dst
case'week':<span class="cstat-no" title="statement not covered" >output=(this-that-zoneDelta)/6048e5;<span class="cstat-no" title="statement not covered" >b</span>reak;/</span>/ 1000 * 60 * 60 * 24 * 7, negate dst
default:<span class="cstat-no" title="statement not covered" >output=this-that;}<span class="cstat-no" title="statement not covered" ></span>return asFloat?output:absFloor(output);}</span>function <span class="fstat-no" title="function not covered" >monthDiff(</span>a,b){<span class="cstat-no" title="statement not covered" >if(a.date()&lt;b.date()){// end-of-month calculations work correct when the start month has more</span>
// days than the end month.
<span class="cstat-no" title="statement not covered" >return-monthDiff(b,a);}</span>// difference in months
var wholeMonthDiff=<span class="cstat-no" title="statement not covered" >(b.year()-a.year())*12+(b.month()-a.month()),</span>// b is in (anchor - 1 month, anchor + 1 month)
anchor=<span class="cstat-no" title="statement not covered" >a.clone().add(wholeMonthDiff,'months'),</span>anchor2,adjust;<span class="cstat-no" title="statement not covered" >if(b-anchor&lt;0){<span class="cstat-no" title="statement not covered" >anchor2=a.clone().add(wholeMonthDiff-1,'months');/</span>/ linear across the month</span>
<span class="cstat-no" title="statement not covered" >adjust=(b-anchor)/(anchor-anchor2);}</span>else{<span class="cstat-no" title="statement not covered" >anchor2=a.clone().add(wholeMonthDiff+1,'months');/</span>/ linear across the month
<span class="cstat-no" title="statement not covered" >adjust=(b-anchor)/(anchor2-anchor);}</span>//check for negative zero, return zero if negative zero
<span class="cstat-no" title="statement not covered" >return-(wholeMonthDiff+adjust)||0;}<span class="cstat-no" title="statement not covered" ></span>hooks.defaultFormat='YYYY-MM-DDTHH:mm:ssZ';<span class="cstat-no" title="statement not covered" >h</span>ooks.defaultFormatUtc='YYYY-MM-DDTHH:mm:ss[Z]';f</span>unction <span class="fstat-no" title="function not covered" >toString(</span>){<span class="cstat-no" title="statement not covered" >return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');}</span>function <span class="fstat-no" title="function not covered" >toISOString(</span>keepOffset){<span class="cstat-no" title="statement not covered" >if(!this.isValid()){<span class="cstat-no" title="statement not covered" >return null;}</span>v</span>ar utc=<span class="cstat-no" title="statement not covered" >keepOffset!==true,</span>m=<span class="cstat-no" title="statement not covered" >utc?this.clone().utc():this;<span class="cstat-no" title="statement not covered" ></span>if(m.year()&lt;0||m.year()&gt;9999){<span class="cstat-no" title="statement not covered" >return formatMoment(m,utc?'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]':'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isFunction(Date.prototype.toISOString)){// native implementation is ~50x faster, use it when we can</span>
<span class="cstat-no" title="statement not covered" >if(utc){<span class="cstat-no" title="statement not covered" >return this.toDate().toISOString();}</span>else{<span class="cstat-no" title="statement not covered" >return new Date(this.valueOf()+this.utcOffset()*60*1000).toISOString().replace('Z',formatMoment(m,'Z'));}</span>}<span class="cstat-no" title="statement not covered" ></span>return formatMoment(m,utc?'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]':'YYYY-MM-DD[T]HH:mm:ss.SSSZ');}</span>/**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */function <span class="fstat-no" title="function not covered" >inspect(</span>){<span class="cstat-no" title="statement not covered" >if(!this.isValid()){<span class="cstat-no" title="statement not covered" >return'moment.invalid(/* '+this._i+' */)';}</span>v</span>ar func=<span class="cstat-no" title="statement not covered" >'moment',</span>zone=<span class="cstat-no" title="statement not covered" >'',</span>prefix,year,datetime,suffix;<span class="cstat-no" title="statement not covered" >if(!this.isLocal()){<span class="cstat-no" title="statement not covered" >func=this.utcOffset()===0?'moment.utc':'moment.parseZone';<span class="cstat-no" title="statement not covered" >z</span>one='Z';}<span class="cstat-no" title="statement not covered" ></span>p</span>refix='['+func+'("]';<span class="cstat-no" title="statement not covered" >y</span>ear=0&lt;=this.year()&amp;&amp;this.year()&lt;=9999?'YYYY':'YYYYYY';<span class="cstat-no" title="statement not covered" >d</span>atetime='-MM-DD[T]HH:mm:ss.SSS';<span class="cstat-no" title="statement not covered" >s</span>uffix=zone+'[")]';<span class="cstat-no" title="statement not covered" >r</span>eturn this.format(prefix+year+datetime+suffix);}</span>function <span class="fstat-no" title="function not covered" >format(</span>inputString){<span class="cstat-no" title="statement not covered" >if(!inputString){<span class="cstat-no" title="statement not covered" >inputString=this.isUtc()?hooks.defaultFormatUtc:hooks.defaultFormat;}</span>v</span>ar output=<span class="cstat-no" title="statement not covered" >formatMoment(this,inputString);<span class="cstat-no" title="statement not covered" ></span>return this.localeData().postformat(output);}</span>function <span class="fstat-no" title="function not covered" >from(</span>time,withoutSuffix){<span class="cstat-no" title="statement not covered" >if(this.isValid()&amp;&amp;(isMoment(time)&amp;&amp;time.isValid()||createLocal(time).isValid())){<span class="cstat-no" title="statement not covered" >return createDuration({to:this,from:time}).locale(this.locale()).humanize(!withoutSuffix);}</span>else{<span class="cstat-no" title="statement not covered" >return this.localeData().invalidDate();}</span>}</span>function <span class="fstat-no" title="function not covered" >fromNow(</span>withoutSuffix){<span class="cstat-no" title="statement not covered" >return this.from(createLocal(),withoutSuffix);}</span>function <span class="fstat-no" title="function not covered" >to(</span>time,withoutSuffix){<span class="cstat-no" title="statement not covered" >if(this.isValid()&amp;&amp;(isMoment(time)&amp;&amp;time.isValid()||createLocal(time).isValid())){<span class="cstat-no" title="statement not covered" >return createDuration({from:this,to:time}).locale(this.locale()).humanize(!withoutSuffix);}</span>else{<span class="cstat-no" title="statement not covered" >return this.localeData().invalidDate();}</span>}</span>function <span class="fstat-no" title="function not covered" >toNow(</span>withoutSuffix){<span class="cstat-no" title="statement not covered" >return this.to(createLocal(),withoutSuffix);}</span>// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function <span class="fstat-no" title="function not covered" >locale(</span>key){var newLocaleData;<span class="cstat-no" title="statement not covered" >if(key===undefined){<span class="cstat-no" title="statement not covered" >return this._locale._abbr;}</span>else{<span class="cstat-no" title="statement not covered" >newLocaleData=getLocale(key);<span class="cstat-no" title="statement not covered" >i</span>f(newLocaleData!=null){<span class="cstat-no" title="statement not covered" >this._locale=newLocaleData;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this;}</span>}</span>var lang=<span class="cstat-no" title="statement not covered" >deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',<span class="fstat-no" title="function not covered" >fu</span>nction(key){<span class="cstat-no" title="statement not covered" >if(key===undefined){<span class="cstat-no" title="statement not covered" >return this.localeData();}</span>else{<span class="cstat-no" title="statement not covered" >return this.locale(key);}</span>}</span>);</span>function <span class="fstat-no" title="function not covered" >localeData(</span>){<span class="cstat-no" title="statement not covered" >return this._locale;}</span>var MS_PER_SECOND=<span class="cstat-no" title="statement not covered" >1000,</span>MS_PER_MINUTE=<span class="cstat-no" title="statement not covered" >60*MS_PER_SECOND,</span>MS_PER_HOUR=<span class="cstat-no" title="statement not covered" >60*MS_PER_MINUTE,</span>MS_PER_400_YEARS=<span class="cstat-no" title="statement not covered" >(365*400+97)*24*MS_PER_HOUR;</span>// actual modulo - handles negative numbers (for dates before 1970):
function <span class="fstat-no" title="function not covered" >mod$1(</span>dividend,divisor){<span class="cstat-no" title="statement not covered" >return(dividend%divisor+divisor)%divisor;}</span>function <span class="fstat-no" title="function not covered" >localStartOfDate(</span>y,m,d){// the date constructor remaps years 0-99 to 1900-1999
<span class="cstat-no" title="statement not covered" >if(y&lt;100&amp;&amp;y&gt;=0){// preserve leap years using a full 400 year cycle, then reset</span>
<span class="cstat-no" title="statement not covered" >return new Date(y+400,m,d)-MS_PER_400_YEARS;}</span>else{<span class="cstat-no" title="statement not covered" >return new Date(y,m,d).valueOf();}</span>}function <span class="fstat-no" title="function not covered" >utcStartOfDate(</span>y,m,d){// Date.UTC remaps years 0-99 to 1900-1999
<span class="cstat-no" title="statement not covered" >if(y&lt;100&amp;&amp;y&gt;=0){// preserve leap years using a full 400 year cycle, then reset</span>
<span class="cstat-no" title="statement not covered" >return Date.UTC(y+400,m,d)-MS_PER_400_YEARS;}</span>else{<span class="cstat-no" title="statement not covered" >return Date.UTC(y,m,d);}</span>}function <span class="fstat-no" title="function not covered" >startOf(</span>units){var time,startOfDate;<span class="cstat-no" title="statement not covered" >units=normalizeUnits(units);<span class="cstat-no" title="statement not covered" >i</span>f(units===undefined||units==='millisecond'||!this.isValid()){<span class="cstat-no" title="statement not covered" >return this;}<span class="cstat-no" title="statement not covered" ></span>s</span>tartOfDate=this._isUTC?utcStartOfDate:localStartOfDate;<span class="cstat-no" title="statement not covered" >s</span>witch(units){case'year':<span class="cstat-no" title="statement not covered" >time=startOfDate(this.year(),0,1);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'quarter':<span class="cstat-no" title="statement not covered" >time=startOfDate(this.year(),this.month()-this.month()%3,1);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'month':<span class="cstat-no" title="statement not covered" >time=startOfDate(this.year(),this.month(),1);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'week':<span class="cstat-no" title="statement not covered" >time=startOfDate(this.year(),this.month(),this.date()-this.weekday());<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'isoWeek':<span class="cstat-no" title="statement not covered" >time=startOfDate(this.year(),this.month(),this.date()-(this.isoWeekday()-1));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'day':case'date':<span class="cstat-no" title="statement not covered" >time=startOfDate(this.year(),this.month(),this.date());<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'hour':<span class="cstat-no" title="statement not covered" >time=this._d.valueOf();<span class="cstat-no" title="statement not covered" >t</span>ime-=mod$1(time+(this._isUTC?0:this.utcOffset()*MS_PER_MINUTE),MS_PER_HOUR);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'minute':<span class="cstat-no" title="statement not covered" >time=this._d.valueOf();<span class="cstat-no" title="statement not covered" >t</span>ime-=mod$1(time,MS_PER_MINUTE);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'second':<span class="cstat-no" title="statement not covered" >time=this._d.valueOf();<span class="cstat-no" title="statement not covered" >t</span>ime-=mod$1(time,MS_PER_SECOND);<span class="cstat-no" title="statement not covered" >b</span>reak;}<span class="cstat-no" title="statement not covered" ></span>t</span>his._d.setTime(time);<span class="cstat-no" title="statement not covered" >h</span>ooks.updateOffset(this,true);<span class="cstat-no" title="statement not covered" >r</span>eturn this;}</span>function <span class="fstat-no" title="function not covered" >endOf(</span>units){var time,startOfDate;<span class="cstat-no" title="statement not covered" >units=normalizeUnits(units);<span class="cstat-no" title="statement not covered" >i</span>f(units===undefined||units==='millisecond'||!this.isValid()){<span class="cstat-no" title="statement not covered" >return this;}<span class="cstat-no" title="statement not covered" ></span>s</span>tartOfDate=this._isUTC?utcStartOfDate:localStartOfDate;<span class="cstat-no" title="statement not covered" >s</span>witch(units){case'year':<span class="cstat-no" title="statement not covered" >time=startOfDate(this.year()+1,0,1)-1;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'quarter':<span class="cstat-no" title="statement not covered" >time=startOfDate(this.year(),this.month()-this.month()%3+3,1)-1;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'month':<span class="cstat-no" title="statement not covered" >time=startOfDate(this.year(),this.month()+1,1)-1;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'week':<span class="cstat-no" title="statement not covered" >time=startOfDate(this.year(),this.month(),this.date()-this.weekday()+7)-1;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'isoWeek':<span class="cstat-no" title="statement not covered" >time=startOfDate(this.year(),this.month(),this.date()-(this.isoWeekday()-1)+7)-1;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'day':case'date':<span class="cstat-no" title="statement not covered" >time=startOfDate(this.year(),this.month(),this.date()+1)-1;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'hour':<span class="cstat-no" title="statement not covered" >time=this._d.valueOf();<span class="cstat-no" title="statement not covered" >t</span>ime+=MS_PER_HOUR-mod$1(time+(this._isUTC?0:this.utcOffset()*MS_PER_MINUTE),MS_PER_HOUR)-1;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'minute':<span class="cstat-no" title="statement not covered" >time=this._d.valueOf();<span class="cstat-no" title="statement not covered" >t</span>ime+=MS_PER_MINUTE-mod$1(time,MS_PER_MINUTE)-1;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'second':<span class="cstat-no" title="statement not covered" >time=this._d.valueOf();<span class="cstat-no" title="statement not covered" >t</span>ime+=MS_PER_SECOND-mod$1(time,MS_PER_SECOND)-1;<span class="cstat-no" title="statement not covered" >b</span>reak;}<span class="cstat-no" title="statement not covered" ></span>t</span>his._d.setTime(time);<span class="cstat-no" title="statement not covered" >h</span>ooks.updateOffset(this,true);<span class="cstat-no" title="statement not covered" >r</span>eturn this;}</span>function <span class="fstat-no" title="function not covered" >valueOf(</span>){<span class="cstat-no" title="statement not covered" >return this._d.valueOf()-(this._offset||0)*60000;}</span>function <span class="fstat-no" title="function not covered" >unix(</span>){<span class="cstat-no" title="statement not covered" >return Math.floor(this.valueOf()/1000);}</span>function <span class="fstat-no" title="function not covered" >toDate(</span>){<span class="cstat-no" title="statement not covered" >return new Date(this.valueOf());}</span>function <span class="fstat-no" title="function not covered" >toArray(</span>){var m=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return[m.year(),m.month(),m.date(),m.hour(),m.minute(),m.second(),m.millisecond()];}</span>function <span class="fstat-no" title="function not covered" >toObject(</span>){var m=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return{years:m.year(),months:m.month(),date:m.date(),hours:m.hours(),minutes:m.minutes(),seconds:m.seconds(),milliseconds:m.milliseconds()};}</span>function <span class="fstat-no" title="function not covered" >toJSON(</span>){// new Date(NaN).toJSON() === null
<span class="cstat-no" title="statement not covered" >return this.isValid()?this.toISOString():null;}</span>function <span class="fstat-no" title="function not covered" >isValid$2(</span>){<span class="cstat-no" title="statement not covered" >return isValid(this);}</span>function <span class="fstat-no" title="function not covered" >parsingFlags(</span>){<span class="cstat-no" title="statement not covered" >return extend({},getParsingFlags(this));}</span>function <span class="fstat-no" title="function not covered" >invalidAt(</span>){<span class="cstat-no" title="statement not covered" >return getParsingFlags(this).overflow;}</span>function <span class="fstat-no" title="function not covered" >creationData(</span>){<span class="cstat-no" title="statement not covered" >return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict};}<span class="cstat-no" title="statement not covered" ></span>addFormatToken('N',0,0,'eraAbbr');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('NN',0,0,'eraAbbr');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('NNN',0,0,'eraAbbr');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('NNNN',0,0,'eraName');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('NNNNN',0,0,'eraNarrow');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('y',['y',1],'yo','eraYear');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('y',['yy',2],0,'eraYear');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('y',['yyy',3],0,'eraYear');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('y',['yyyy',4],0,'eraYear');<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('N',matchEraAbbr);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('NN',matchEraAbbr);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('NNN',matchEraAbbr);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('NNNN',matchEraName);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('NNNNN',matchEraNarrow);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken(['N','NN','NNN','NNNN','NNNNN'],<span class="fstat-no" title="function not covered" >fu</span>nction(input,array,config,token){var era=<span class="cstat-no" title="statement not covered" >config._locale.erasParse(input,token,config._strict);<span class="cstat-no" title="statement not covered" ></span>if(era){<span class="cstat-no" title="statement not covered" >getParsingFlags(config).era=era;}</span>else{<span class="cstat-no" title="statement not covered" >getParsingFlags(config).invalidEra=input;}</span>}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('y',matchUnsigned);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('yy',matchUnsigned);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('yyy',matchUnsigned);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('yyyy',matchUnsigned);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('yo',matchEraYearOrdinal);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken(['y','yy','yyy','yyyy'],YEAR);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken(['yo'],<span class="fstat-no" title="function not covered" >fu</span>nction(input,array,config,token){var match;<span class="cstat-no" title="statement not covered" >if(config._locale._eraYearOrdinalRegex){<span class="cstat-no" title="statement not covered" >match=input.match(config._locale._eraYearOrdinalRegex);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(config._locale.eraYearOrdinalParse){<span class="cstat-no" title="statement not covered" >array[YEAR]=config._locale.eraYearOrdinalParse(input,match);}</span>else{<span class="cstat-no" title="statement not covered" >array[YEAR]=parseInt(input,10);}</span>}</span>);f</span>unction <span class="fstat-no" title="function not covered" >localeEras(</span>m,format){var i,l,date,eras=<span class="cstat-no" title="statement not covered" >this._eras||getLocale('en')._eras;<span class="cstat-no" title="statement not covered" ></span>for(i=0,l=eras.length;i&lt;l;++i){<span class="cstat-no" title="statement not covered" >switch(typeof eras[i].since){<span class="branch-0 cbranch-no" title="branch not covered" >case'string':// truncate time</span></span></span>
<span class="cstat-no" title="statement not covered" >date=hooks(eras[i].since).startOf('day');<span class="cstat-no" title="statement not covered" >e</span>ras[i].since=date.valueOf();<span class="cstat-no" title="statement not covered" >b</span>reak;}<span class="cstat-no" title="statement not covered" ></span>switch(typeof eras[i].until){case'undefined':<span class="cstat-no" title="statement not covered" >eras[i].until=+Infinity;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'string':// truncate time</span>
<span class="cstat-no" title="statement not covered" >date=hooks(eras[i].until).startOf('day').valueOf();<span class="cstat-no" title="statement not covered" >e</span>ras[i].until=date.valueOf();<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}<span class="cstat-no" title="statement not covered" >return eras;}</span>function <span class="fstat-no" title="function not covered" >localeErasParse(</span>eraName,format,strict){var i,l,eras=<span class="cstat-no" title="statement not covered" >this.eras(),</span>name,abbr,narrow;<span class="cstat-no" title="statement not covered" >eraName=eraName.toUpperCase();<span class="cstat-no" title="statement not covered" >f</span>or(i=0,l=eras.length;i&lt;l;++i){<span class="cstat-no" title="statement not covered" >name=eras[i].name.toUpperCase();<span class="cstat-no" title="statement not covered" >a</span>bbr=eras[i].abbr.toUpperCase();<span class="cstat-no" title="statement not covered" >n</span>arrow=eras[i].narrow.toUpperCase();<span class="cstat-no" title="statement not covered" >i</span>f(strict){<span class="cstat-no" title="statement not covered" >switch(format){case'N':case'NN':case'NNN':<span class="cstat-no" title="statement not covered" >if(abbr===eraName){<span class="cstat-no" title="statement not covered" >return eras[i];}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase'NNNN':<span class="cstat-no" title="statement not covered" >if(name===eraName){<span class="cstat-no" title="statement not covered" >return eras[i];}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase'NNNNN':<span class="cstat-no" title="statement not covered" >if(narrow===eraName){<span class="cstat-no" title="statement not covered" >return eras[i];}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;}</span>}</span>else <span class="cstat-no" title="statement not covered" >if([name,abbr,narrow].indexOf(eraName)&gt;=0){<span class="cstat-no" title="statement not covered" >return eras[i];}</span>}</span></span>}</span>function <span class="fstat-no" title="function not covered" >localeErasConvertYear(</span>era,year){var dir=<span class="cstat-no" title="statement not covered" >era.since&lt;=era.until?+1:-1;<span class="cstat-no" title="statement not covered" ></span>if(year===undefined){<span class="cstat-no" title="statement not covered" >return hooks(era.since).year();}</span>else{<span class="cstat-no" title="statement not covered" >return hooks(era.since).year()+(year-era.offset)*dir;}</span>}</span>function <span class="fstat-no" title="function not covered" >getEraName(</span>){var i,l,val,eras=<span class="cstat-no" title="statement not covered" >this.localeData().eras();<span class="cstat-no" title="statement not covered" ></span>for(i=0,l=eras.length;i&lt;l;++i){// truncate time</span>
<span class="cstat-no" title="statement not covered" >val=this.clone().startOf('day').valueOf();<span class="cstat-no" title="statement not covered" >i</span>f(eras[i].since&lt;=val&amp;&amp;val&lt;=eras[i].until){<span class="cstat-no" title="statement not covered" >return eras[i].name;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(eras[i].until&lt;=val&amp;&amp;val&lt;=eras[i].since){<span class="cstat-no" title="statement not covered" >return eras[i].name;}</span>}<span class="cstat-no" title="statement not covered" ></span>return'';}</span>function <span class="fstat-no" title="function not covered" >getEraNarrow(</span>){var i,l,val,eras=<span class="cstat-no" title="statement not covered" >this.localeData().eras();<span class="cstat-no" title="statement not covered" ></span>for(i=0,l=eras.length;i&lt;l;++i){// truncate time</span>
<span class="cstat-no" title="statement not covered" >val=this.clone().startOf('day').valueOf();<span class="cstat-no" title="statement not covered" >i</span>f(eras[i].since&lt;=val&amp;&amp;val&lt;=eras[i].until){<span class="cstat-no" title="statement not covered" >return eras[i].narrow;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(eras[i].until&lt;=val&amp;&amp;val&lt;=eras[i].since){<span class="cstat-no" title="statement not covered" >return eras[i].narrow;}</span>}<span class="cstat-no" title="statement not covered" ></span>return'';}</span>function <span class="fstat-no" title="function not covered" >getEraAbbr(</span>){var i,l,val,eras=<span class="cstat-no" title="statement not covered" >this.localeData().eras();<span class="cstat-no" title="statement not covered" ></span>for(i=0,l=eras.length;i&lt;l;++i){// truncate time</span>
<span class="cstat-no" title="statement not covered" >val=this.clone().startOf('day').valueOf();<span class="cstat-no" title="statement not covered" >i</span>f(eras[i].since&lt;=val&amp;&amp;val&lt;=eras[i].until){<span class="cstat-no" title="statement not covered" >return eras[i].abbr;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(eras[i].until&lt;=val&amp;&amp;val&lt;=eras[i].since){<span class="cstat-no" title="statement not covered" >return eras[i].abbr;}</span>}<span class="cstat-no" title="statement not covered" ></span>return'';}</span>function <span class="fstat-no" title="function not covered" >getEraYear(</span>){var i,l,dir,val,eras=<span class="cstat-no" title="statement not covered" >this.localeData().eras();<span class="cstat-no" title="statement not covered" ></span>for(i=0,l=eras.length;i&lt;l;++i){<span class="cstat-no" title="statement not covered" >dir=eras[i].since&lt;=eras[i].until?+1:-1;/</span>/ truncate time</span>
<span class="cstat-no" title="statement not covered" >val=this.clone().startOf('day').valueOf();<span class="cstat-no" title="statement not covered" >i</span>f(eras[i].since&lt;=val&amp;&amp;val&lt;=eras[i].until||eras[i].until&lt;=val&amp;&amp;val&lt;=eras[i].since){<span class="cstat-no" title="statement not covered" >return(this.year()-hooks(eras[i].since).year())*dir+eras[i].offset;}</span>}<span class="cstat-no" title="statement not covered" ></span>return this.year();}</span>function <span class="fstat-no" title="function not covered" >erasNameRegex(</span>isStrict){<span class="cstat-no" title="statement not covered" >if(!hasOwnProp(this,'_erasNameRegex')){<span class="cstat-no" title="statement not covered" >computeErasParse.call(this);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn isStrict?this._erasNameRegex:this._erasRegex;}</span>function <span class="fstat-no" title="function not covered" >erasAbbrRegex(</span>isStrict){<span class="cstat-no" title="statement not covered" >if(!hasOwnProp(this,'_erasAbbrRegex')){<span class="cstat-no" title="statement not covered" >computeErasParse.call(this);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn isStrict?this._erasAbbrRegex:this._erasRegex;}</span>function <span class="fstat-no" title="function not covered" >erasNarrowRegex(</span>isStrict){<span class="cstat-no" title="statement not covered" >if(!hasOwnProp(this,'_erasNarrowRegex')){<span class="cstat-no" title="statement not covered" >computeErasParse.call(this);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn isStrict?this._erasNarrowRegex:this._erasRegex;}</span>function <span class="fstat-no" title="function not covered" >matchEraAbbr(</span>isStrict,locale){<span class="cstat-no" title="statement not covered" >return locale.erasAbbrRegex(isStrict);}</span>function <span class="fstat-no" title="function not covered" >matchEraName(</span>isStrict,locale){<span class="cstat-no" title="statement not covered" >return locale.erasNameRegex(isStrict);}</span>function <span class="fstat-no" title="function not covered" >matchEraNarrow(</span>isStrict,locale){<span class="cstat-no" title="statement not covered" >return locale.erasNarrowRegex(isStrict);}</span>function <span class="fstat-no" title="function not covered" >matchEraYearOrdinal(</span>isStrict,locale){<span class="cstat-no" title="statement not covered" >return locale._eraYearOrdinalRegex||matchUnsigned;}</span>function <span class="fstat-no" title="function not covered" >computeErasParse(</span>){var abbrPieces=<span class="cstat-no" title="statement not covered" >[],</span>namePieces=<span class="cstat-no" title="statement not covered" >[],</span>narrowPieces=<span class="cstat-no" title="statement not covered" >[],</span>mixedPieces=<span class="cstat-no" title="statement not covered" >[],</span>i,l,eras=<span class="cstat-no" title="statement not covered" >this.eras();<span class="cstat-no" title="statement not covered" ></span>for(i=0,l=eras.length;i&lt;l;++i){<span class="cstat-no" title="statement not covered" >namePieces.push(regexEscape(eras[i].name));<span class="cstat-no" title="statement not covered" >a</span>bbrPieces.push(regexEscape(eras[i].abbr));<span class="cstat-no" title="statement not covered" >n</span>arrowPieces.push(regexEscape(eras[i].narrow));<span class="cstat-no" title="statement not covered" >m</span>ixedPieces.push(regexEscape(eras[i].name));<span class="cstat-no" title="statement not covered" >m</span>ixedPieces.push(regexEscape(eras[i].abbr));<span class="cstat-no" title="statement not covered" >m</span>ixedPieces.push(regexEscape(eras[i].narrow));}<span class="cstat-no" title="statement not covered" ></span>t</span>his._erasRegex=new RegExp('^('+mixedPieces.join('|')+')','i');<span class="cstat-no" title="statement not covered" >t</span>his._erasNameRegex=new RegExp('^('+namePieces.join('|')+')','i');<span class="cstat-no" title="statement not covered" >t</span>his._erasAbbrRegex=new RegExp('^('+abbrPieces.join('|')+')','i');<span class="cstat-no" title="statement not covered" >t</span>his._erasNarrowRegex=new RegExp('^('+narrowPieces.join('|')+')','i');}</span>// FORMATTING
<span class="cstat-no" title="statement not covered" >addFormatToken(0,['gg',2],0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.weekYear()%100;}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken(0,['GG',2],0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.isoWeekYear()%100;}</span>);f</span>unction <span class="fstat-no" title="function not covered" >addWeekYearFormatToken(</span>token,getter){<span class="cstat-no" title="statement not covered" >addFormatToken(0,[token,token.length],0,getter);}<span class="cstat-no" title="statement not covered" ></span>addWeekYearFormatToken('gggg','weekYear');<span class="cstat-no" title="statement not covered" >a</span>ddWeekYearFormatToken('ggggg','weekYear');<span class="cstat-no" title="statement not covered" >a</span>ddWeekYearFormatToken('GGGG','isoWeekYear');<span class="cstat-no" title="statement not covered" >a</span>ddWeekYearFormatToken('GGGGG','isoWeekYear');/</span>/ ALIASES
<span class="cstat-no" title="statement not covered" >addUnitAlias('weekYear','gg');<span class="cstat-no" title="statement not covered" >a</span>ddUnitAlias('isoWeekYear','GG');/</span>/ PRIORITY
<span class="cstat-no" title="statement not covered" >addUnitPriority('weekYear',1);<span class="cstat-no" title="statement not covered" >a</span>ddUnitPriority('isoWeekYear',1);/</span>/ PARSING
<span class="cstat-no" title="statement not covered" >addRegexToken('G',matchSigned);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('g',matchSigned);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('GG',match1to2,match2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('gg',match1to2,match2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('GGGG',match1to4,match4);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('gggg',match1to4,match4);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('GGGGG',match1to6,match6);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('ggggg',match1to6,match6);<span class="cstat-no" title="statement not covered" >a</span>ddWeekParseToken(['gggg','ggggg','GGGG','GGGGG'],<span class="fstat-no" title="function not covered" >fu</span>nction(input,week,config,token){<span class="cstat-no" title="statement not covered" >week[token.substr(0,2)]=toInt(input);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddWeekParseToken(['gg','GG'],<span class="fstat-no" title="function not covered" >fu</span>nction(input,week,config,token){<span class="cstat-no" title="statement not covered" >week[token]=hooks.parseTwoDigitYear(input);}</span>);/</span>/ MOMENTS
function <span class="fstat-no" title="function not covered" >getSetWeekYear(</span>input){<span class="cstat-no" title="statement not covered" >return getSetWeekYearHelper.call(this,input,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy);}</span>function <span class="fstat-no" title="function not covered" >getSetISOWeekYear(</span>input){<span class="cstat-no" title="statement not covered" >return getSetWeekYearHelper.call(this,input,this.isoWeek(),this.isoWeekday(),1,4);}</span>function <span class="fstat-no" title="function not covered" >getISOWeeksInYear(</span>){<span class="cstat-no" title="statement not covered" >return weeksInYear(this.year(),1,4);}</span>function <span class="fstat-no" title="function not covered" >getISOWeeksInISOWeekYear(</span>){<span class="cstat-no" title="statement not covered" >return weeksInYear(this.isoWeekYear(),1,4);}</span>function <span class="fstat-no" title="function not covered" >getWeeksInYear(</span>){var weekInfo=<span class="cstat-no" title="statement not covered" >this.localeData()._week;<span class="cstat-no" title="statement not covered" ></span>return weeksInYear(this.year(),weekInfo.dow,weekInfo.doy);}</span>function <span class="fstat-no" title="function not covered" >getWeeksInWeekYear(</span>){var weekInfo=<span class="cstat-no" title="statement not covered" >this.localeData()._week;<span class="cstat-no" title="statement not covered" ></span>return weeksInYear(this.weekYear(),weekInfo.dow,weekInfo.doy);}</span>function <span class="fstat-no" title="function not covered" >getSetWeekYearHelper(</span>input,week,weekday,dow,doy){var weeksTarget;<span class="cstat-no" title="statement not covered" >if(input==null){<span class="cstat-no" title="statement not covered" >return weekOfYear(this,dow,doy).year;}</span>else{<span class="cstat-no" title="statement not covered" >weeksTarget=weeksInYear(input,dow,doy);<span class="cstat-no" title="statement not covered" >i</span>f(week&gt;weeksTarget){<span class="cstat-no" title="statement not covered" >week=weeksTarget;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn setWeekAll.call(this,input,week,weekday,dow,doy);}</span>}</span>function <span class="fstat-no" title="function not covered" >setWeekAll(</span>weekYear,week,weekday,dow,doy){var dayOfYearData=<span class="cstat-no" title="statement not covered" >dayOfYearFromWeeks(weekYear,week,weekday,dow,doy),</span>date=<span class="cstat-no" title="statement not covered" >createUTCDate(dayOfYearData.year,0,dayOfYearData.dayOfYear);<span class="cstat-no" title="statement not covered" ></span>this.year(date.getUTCFullYear());<span class="cstat-no" title="statement not covered" >t</span>his.month(date.getUTCMonth());<span class="cstat-no" title="statement not covered" >t</span>his.date(date.getUTCDate());<span class="cstat-no" title="statement not covered" >r</span>eturn this;}</span>// FORMATTING
<span class="cstat-no" title="statement not covered" >addFormatToken('Q',0,'Qo','quarter');/</span>/ ALIASES
<span class="cstat-no" title="statement not covered" >addUnitAlias('quarter','Q');/</span>/ PRIORITY
<span class="cstat-no" title="statement not covered" >addUnitPriority('quarter',7);/</span>/ PARSING
<span class="cstat-no" title="statement not covered" >addRegexToken('Q',match1);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken('Q',<span class="fstat-no" title="function not covered" >fu</span>nction(input,array){<span class="cstat-no" title="statement not covered" >array[MONTH]=(toInt(input)-1)*3;}</span>);/</span>/ MOMENTS
function <span class="fstat-no" title="function not covered" >getSetQuarter(</span>input){<span class="cstat-no" title="statement not covered" >return input==null?Math.ceil((this.month()+1)/3):this.month((input-1)*3+this.month()%3);}</span>// FORMATTING
<span class="cstat-no" title="statement not covered" >addFormatToken('D',['DD',2],'Do','date');/</span>/ ALIASES
<span class="cstat-no" title="statement not covered" >addUnitAlias('date','D');/</span>/ PRIORITY
<span class="cstat-no" title="statement not covered" >addUnitPriority('date',9);/</span>/ PARSING
<span class="cstat-no" title="statement not covered" >addRegexToken('D',match1to2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('DD',match1to2,match2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('Do',<span class="fstat-no" title="function not covered" >fu</span>nction(isStrict,locale){// TODO: Remove "ordinalParse" fallback in next major release.</span>
<span class="cstat-no" title="statement not covered" >return isStrict?locale._dayOfMonthOrdinalParse||locale._ordinalParse:locale._dayOfMonthOrdinalParseLenient;}</span>);<span class="cstat-no" title="statement not covered" >addParseToken(['D','DD'],DATE);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken('Do',<span class="fstat-no" title="function not covered" >fu</span>nction(input,array){<span class="cstat-no" title="statement not covered" >array[DATE]=toInt(input.match(match1to2)[0]);}</span>);/</span>/ MOMENTS
var getSetDayOfMonth=<span class="cstat-no" title="statement not covered" >makeGetSet('Date',true);</span>// FORMATTING
<span class="cstat-no" title="statement not covered" >addFormatToken('DDD',['DDDD',3],'DDDo','dayOfYear');/</span>/ ALIASES
<span class="cstat-no" title="statement not covered" >addUnitAlias('dayOfYear','DDD');/</span>/ PRIORITY
<span class="cstat-no" title="statement not covered" >addUnitPriority('dayOfYear',4);/</span>/ PARSING
<span class="cstat-no" title="statement not covered" >addRegexToken('DDD',match1to3);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('DDDD',match3);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken(['DDD','DDDD'],<span class="fstat-no" title="function not covered" >fu</span>nction(input,array,config){<span class="cstat-no" title="statement not covered" >config._dayOfYear=toInt(input);}</span>);/</span>/ HELPERS
// MOMENTS
function <span class="fstat-no" title="function not covered" >getSetDayOfYear(</span>input){var dayOfYear=<span class="cstat-no" title="statement not covered" >Math.round((this.clone().startOf('day')-this.clone().startOf('year'))/864e5)+1;<span class="cstat-no" title="statement not covered" ></span>return input==null?dayOfYear:this.add(input-dayOfYear,'d');}</span>// FORMATTING
<span class="cstat-no" title="statement not covered" >addFormatToken('m',['mm',2],0,'minute');/</span>/ ALIASES
<span class="cstat-no" title="statement not covered" >addUnitAlias('minute','m');/</span>/ PRIORITY
<span class="cstat-no" title="statement not covered" >addUnitPriority('minute',14);/</span>/ PARSING
<span class="cstat-no" title="statement not covered" >addRegexToken('m',match1to2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('mm',match1to2,match2);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken(['m','mm'],MINUTE);/</span>/ MOMENTS
var getSetMinute=<span class="cstat-no" title="statement not covered" >makeGetSet('Minutes',false);</span>// FORMATTING
<span class="cstat-no" title="statement not covered" >addFormatToken('s',['ss',2],0,'second');/</span>/ ALIASES
<span class="cstat-no" title="statement not covered" >addUnitAlias('second','s');/</span>/ PRIORITY
<span class="cstat-no" title="statement not covered" >addUnitPriority('second',15);/</span>/ PARSING
<span class="cstat-no" title="statement not covered" >addRegexToken('s',match1to2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('ss',match1to2,match2);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken(['s','ss'],SECOND);/</span>/ MOMENTS
var getSetSecond=<span class="cstat-no" title="statement not covered" >makeGetSet('Seconds',false);</span>// FORMATTING
<span class="cstat-no" title="statement not covered" >addFormatToken('S',0,0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return~~(this.millisecond()/100);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken(0,['SS',2],0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return~~(this.millisecond()/10);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken(0,['SSS',3],0,'millisecond');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken(0,['SSSS',4],0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.millisecond()*10;}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken(0,['SSSSS',5],0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.millisecond()*100;}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken(0,['SSSSSS',6],0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.millisecond()*1000;}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken(0,['SSSSSSS',7],0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.millisecond()*10000;}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken(0,['SSSSSSSS',8],0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.millisecond()*100000;}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken(0,['SSSSSSSSS',9],0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.millisecond()*1000000;}</span>);/</span>/ ALIASES
<span class="cstat-no" title="statement not covered" >addUnitAlias('millisecond','ms');/</span>/ PRIORITY
<span class="cstat-no" title="statement not covered" >addUnitPriority('millisecond',16);/</span>/ PARSING
<span class="cstat-no" title="statement not covered" >addRegexToken('S',match1to3,match1);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('SS',match1to3,match2);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('SSS',match1to3,match3);v</span>ar token,getSetMillisecond;<span class="cstat-no" title="statement not covered" >for(token='SSSS';token.length&lt;=9;token+='S'){<span class="cstat-no" title="statement not covered" >addRegexToken(token,matchUnsigned);}</span>f</span>unction <span class="fstat-no" title="function not covered" >parseMs(</span>input,array){<span class="cstat-no" title="statement not covered" >array[MILLISECOND]=toInt(('0.'+input)*1000);}<span class="cstat-no" title="statement not covered" ></span>for(token='S';token.length&lt;=9;token+='S'){<span class="cstat-no" title="statement not covered" >addParseToken(token,parseMs);}<span class="cstat-no" title="statement not covered" ></span>g</span>etSetMillisecond=makeGetSet('Milliseconds',false);/</span>/ FORMATTING
<span class="cstat-no" title="statement not covered" >addFormatToken('z',0,0,'zoneAbbr');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('zz',0,0,'zoneName');/</span>/ MOMENTS
function <span class="fstat-no" title="function not covered" >getZoneAbbr(</span>){<span class="cstat-no" title="statement not covered" >return this._isUTC?'UTC':'';}</span>function <span class="fstat-no" title="function not covered" >getZoneName(</span>){<span class="cstat-no" title="statement not covered" >return this._isUTC?'Coordinated Universal Time':'';}</span>var proto=<span class="cstat-no" title="statement not covered" >Moment.prototype;<span class="cstat-no" title="statement not covered" ></span>proto.add=add;<span class="cstat-no" title="statement not covered" >p</span>roto.calendar=calendar$1;<span class="cstat-no" title="statement not covered" >p</span>roto.clone=clone;<span class="cstat-no" title="statement not covered" >p</span>roto.diff=diff;<span class="cstat-no" title="statement not covered" >p</span>roto.endOf=endOf;<span class="cstat-no" title="statement not covered" >p</span>roto.format=format;<span class="cstat-no" title="statement not covered" >p</span>roto.from=from;<span class="cstat-no" title="statement not covered" >p</span>roto.fromNow=fromNow;<span class="cstat-no" title="statement not covered" >p</span>roto.to=to;<span class="cstat-no" title="statement not covered" >p</span>roto.toNow=toNow;<span class="cstat-no" title="statement not covered" >p</span>roto.get=stringGet;<span class="cstat-no" title="statement not covered" >p</span>roto.invalidAt=invalidAt;<span class="cstat-no" title="statement not covered" >p</span>roto.isAfter=isAfter;<span class="cstat-no" title="statement not covered" >p</span>roto.isBefore=isBefore;<span class="cstat-no" title="statement not covered" >p</span>roto.isBetween=isBetween;<span class="cstat-no" title="statement not covered" >p</span>roto.isSame=isSame;<span class="cstat-no" title="statement not covered" >p</span>roto.isSameOrAfter=isSameOrAfter;<span class="cstat-no" title="statement not covered" >p</span>roto.isSameOrBefore=isSameOrBefore;<span class="cstat-no" title="statement not covered" >p</span>roto.isValid=isValid$2;<span class="cstat-no" title="statement not covered" >p</span>roto.lang=lang;<span class="cstat-no" title="statement not covered" >p</span>roto.locale=locale;<span class="cstat-no" title="statement not covered" >p</span>roto.localeData=localeData;<span class="cstat-no" title="statement not covered" >p</span>roto.max=prototypeMax;<span class="cstat-no" title="statement not covered" >p</span>roto.min=prototypeMin;<span class="cstat-no" title="statement not covered" >p</span>roto.parsingFlags=parsingFlags;<span class="cstat-no" title="statement not covered" >p</span>roto.set=stringSet;<span class="cstat-no" title="statement not covered" >p</span>roto.startOf=startOf;<span class="cstat-no" title="statement not covered" >p</span>roto.subtract=subtract;<span class="cstat-no" title="statement not covered" >p</span>roto.toArray=toArray;<span class="cstat-no" title="statement not covered" >p</span>roto.toObject=toObject;<span class="cstat-no" title="statement not covered" >p</span>roto.toDate=toDate;<span class="cstat-no" title="statement not covered" >p</span>roto.toISOString=toISOString;<span class="cstat-no" title="statement not covered" >p</span>roto.inspect=inspect;<span class="cstat-no" title="statement not covered" >i</span>f(typeof Symbol!=='undefined'&amp;&amp;Symbol.for!=null){<span class="cstat-no" title="statement not covered" >proto[Symbol.for('nodejs.util.inspect.custom')]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'Moment&lt;'+this.format()+'&gt;';}</span>;}<span class="cstat-no" title="statement not covered" ></span>p</span>roto.toJSON=toJSON;<span class="cstat-no" title="statement not covered" >p</span>roto.toString=toString;<span class="cstat-no" title="statement not covered" >p</span>roto.unix=unix;<span class="cstat-no" title="statement not covered" >p</span>roto.valueOf=valueOf;<span class="cstat-no" title="statement not covered" >p</span>roto.creationData=creationData;<span class="cstat-no" title="statement not covered" >p</span>roto.eraName=getEraName;<span class="cstat-no" title="statement not covered" >p</span>roto.eraNarrow=getEraNarrow;<span class="cstat-no" title="statement not covered" >p</span>roto.eraAbbr=getEraAbbr;<span class="cstat-no" title="statement not covered" >p</span>roto.eraYear=getEraYear;<span class="cstat-no" title="statement not covered" >p</span>roto.year=getSetYear;<span class="cstat-no" title="statement not covered" >p</span>roto.isLeapYear=getIsLeapYear;<span class="cstat-no" title="statement not covered" >p</span>roto.weekYear=getSetWeekYear;<span class="cstat-no" title="statement not covered" >p</span>roto.isoWeekYear=getSetISOWeekYear;<span class="cstat-no" title="statement not covered" >p</span>roto.quarter=proto.quarters=getSetQuarter;<span class="cstat-no" title="statement not covered" >p</span>roto.month=getSetMonth;<span class="cstat-no" title="statement not covered" >p</span>roto.daysInMonth=getDaysInMonth;<span class="cstat-no" title="statement not covered" >p</span>roto.week=proto.weeks=getSetWeek;<span class="cstat-no" title="statement not covered" >p</span>roto.isoWeek=proto.isoWeeks=getSetISOWeek;<span class="cstat-no" title="statement not covered" >p</span>roto.weeksInYear=getWeeksInYear;<span class="cstat-no" title="statement not covered" >p</span>roto.weeksInWeekYear=getWeeksInWeekYear;<span class="cstat-no" title="statement not covered" >p</span>roto.isoWeeksInYear=getISOWeeksInYear;<span class="cstat-no" title="statement not covered" >p</span>roto.isoWeeksInISOWeekYear=getISOWeeksInISOWeekYear;<span class="cstat-no" title="statement not covered" >p</span>roto.date=getSetDayOfMonth;<span class="cstat-no" title="statement not covered" >p</span>roto.day=proto.days=getSetDayOfWeek;<span class="cstat-no" title="statement not covered" >p</span>roto.weekday=getSetLocaleDayOfWeek;<span class="cstat-no" title="statement not covered" >p</span>roto.isoWeekday=getSetISODayOfWeek;<span class="cstat-no" title="statement not covered" >p</span>roto.dayOfYear=getSetDayOfYear;<span class="cstat-no" title="statement not covered" >p</span>roto.hour=proto.hours=getSetHour;<span class="cstat-no" title="statement not covered" >p</span>roto.minute=proto.minutes=getSetMinute;<span class="cstat-no" title="statement not covered" >p</span>roto.second=proto.seconds=getSetSecond;<span class="cstat-no" title="statement not covered" >p</span>roto.millisecond=proto.milliseconds=getSetMillisecond;<span class="cstat-no" title="statement not covered" >p</span>roto.utcOffset=getSetOffset;<span class="cstat-no" title="statement not covered" >p</span>roto.utc=setOffsetToUTC;<span class="cstat-no" title="statement not covered" >p</span>roto.local=setOffsetToLocal;<span class="cstat-no" title="statement not covered" >p</span>roto.parseZone=setOffsetToParsedOffset;<span class="cstat-no" title="statement not covered" >p</span>roto.hasAlignedHourOffset=hasAlignedHourOffset;<span class="cstat-no" title="statement not covered" >p</span>roto.isDST=isDaylightSavingTime;<span class="cstat-no" title="statement not covered" >p</span>roto.isLocal=isLocal;<span class="cstat-no" title="statement not covered" >p</span>roto.isUtcOffset=isUtcOffset;<span class="cstat-no" title="statement not covered" >p</span>roto.isUtc=isUtc;<span class="cstat-no" title="statement not covered" >p</span>roto.isUTC=isUtc;<span class="cstat-no" title="statement not covered" >p</span>roto.zoneAbbr=getZoneAbbr;<span class="cstat-no" title="statement not covered" >p</span>roto.zoneName=getZoneName;<span class="cstat-no" title="statement not covered" >p</span>roto.dates=deprecate('dates accessor is deprecated. Use date instead.',getSetDayOfMonth);<span class="cstat-no" title="statement not covered" >p</span>roto.months=deprecate('months accessor is deprecated. Use month instead',getSetMonth);<span class="cstat-no" title="statement not covered" >p</span>roto.years=deprecate('years accessor is deprecated. Use year instead',getSetYear);<span class="cstat-no" title="statement not covered" >p</span>roto.zone=deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',getSetZone);<span class="cstat-no" title="statement not covered" >p</span>roto.isDSTShifted=deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',isDaylightSavingTimeShifted);f</span>unction <span class="fstat-no" title="function not covered" >createUnix(</span>input){<span class="cstat-no" title="statement not covered" >return createLocal(input*1000);}</span>function <span class="fstat-no" title="function not covered" >createInZone(</span>){<span class="cstat-no" title="statement not covered" >return createLocal.apply(null,arguments).parseZone();}</span>function <span class="fstat-no" title="function not covered" >preParsePostFormat(</span>string){<span class="cstat-no" title="statement not covered" >return string;}</span>var proto$1=<span class="cstat-no" title="statement not covered" >Locale.prototype;<span class="cstat-no" title="statement not covered" ></span>proto$1.calendar=calendar;<span class="cstat-no" title="statement not covered" >p</span>roto$1.longDateFormat=longDateFormat;<span class="cstat-no" title="statement not covered" >p</span>roto$1.invalidDate=invalidDate;<span class="cstat-no" title="statement not covered" >p</span>roto$1.ordinal=ordinal;<span class="cstat-no" title="statement not covered" >p</span>roto$1.preparse=preParsePostFormat;<span class="cstat-no" title="statement not covered" >p</span>roto$1.postformat=preParsePostFormat;<span class="cstat-no" title="statement not covered" >p</span>roto$1.relativeTime=relativeTime;<span class="cstat-no" title="statement not covered" >p</span>roto$1.pastFuture=pastFuture;<span class="cstat-no" title="statement not covered" >p</span>roto$1.set=set;<span class="cstat-no" title="statement not covered" >p</span>roto$1.eras=localeEras;<span class="cstat-no" title="statement not covered" >p</span>roto$1.erasParse=localeErasParse;<span class="cstat-no" title="statement not covered" >p</span>roto$1.erasConvertYear=localeErasConvertYear;<span class="cstat-no" title="statement not covered" >p</span>roto$1.erasAbbrRegex=erasAbbrRegex;<span class="cstat-no" title="statement not covered" >p</span>roto$1.erasNameRegex=erasNameRegex;<span class="cstat-no" title="statement not covered" >p</span>roto$1.erasNarrowRegex=erasNarrowRegex;<span class="cstat-no" title="statement not covered" >p</span>roto$1.months=localeMonths;<span class="cstat-no" title="statement not covered" >p</span>roto$1.monthsShort=localeMonthsShort;<span class="cstat-no" title="statement not covered" >p</span>roto$1.monthsParse=localeMonthsParse;<span class="cstat-no" title="statement not covered" >p</span>roto$1.monthsRegex=monthsRegex;<span class="cstat-no" title="statement not covered" >p</span>roto$1.monthsShortRegex=monthsShortRegex;<span class="cstat-no" title="statement not covered" >p</span>roto$1.week=localeWeek;<span class="cstat-no" title="statement not covered" >p</span>roto$1.firstDayOfYear=localeFirstDayOfYear;<span class="cstat-no" title="statement not covered" >p</span>roto$1.firstDayOfWeek=localeFirstDayOfWeek;<span class="cstat-no" title="statement not covered" >p</span>roto$1.weekdays=localeWeekdays;<span class="cstat-no" title="statement not covered" >p</span>roto$1.weekdaysMin=localeWeekdaysMin;<span class="cstat-no" title="statement not covered" >p</span>roto$1.weekdaysShort=localeWeekdaysShort;<span class="cstat-no" title="statement not covered" >p</span>roto$1.weekdaysParse=localeWeekdaysParse;<span class="cstat-no" title="statement not covered" >p</span>roto$1.weekdaysRegex=weekdaysRegex;<span class="cstat-no" title="statement not covered" >p</span>roto$1.weekdaysShortRegex=weekdaysShortRegex;<span class="cstat-no" title="statement not covered" >p</span>roto$1.weekdaysMinRegex=weekdaysMinRegex;<span class="cstat-no" title="statement not covered" >p</span>roto$1.isPM=localeIsPM;<span class="cstat-no" title="statement not covered" >p</span>roto$1.meridiem=localeMeridiem;f</span>unction <span class="fstat-no" title="function not covered" >get$1(</span>format,index,field,setter){var locale=<span class="cstat-no" title="statement not covered" >getLocale(),</span>utc=<span class="cstat-no" title="statement not covered" >createUTC().set(setter,index);<span class="cstat-no" title="statement not covered" ></span>return locale[field](utc,format);}</span>function <span class="fstat-no" title="function not covered" >listMonthsImpl(</span>format,index,field){<span class="cstat-no" title="statement not covered" >if(isNumber(format)){<span class="cstat-no" title="statement not covered" >index=format;<span class="cstat-no" title="statement not covered" >f</span>ormat=undefined;}<span class="cstat-no" title="statement not covered" ></span>f</span>ormat=format||'';<span class="cstat-no" title="statement not covered" >i</span>f(index!=null){<span class="cstat-no" title="statement not covered" >return get$1(format,index,field,'month');}</span>v</span>ar i,out=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(i=0;i&lt;12;i++){<span class="cstat-no" title="statement not covered" >out[i]=get$1(format,i,field,'month');}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn out;}</span>// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function <span class="fstat-no" title="function not covered" >listWeekdaysImpl(</span>localeSorted,format,index,field){<span class="cstat-no" title="statement not covered" >if(typeof localeSorted==='boolean'){<span class="cstat-no" title="statement not covered" >if(isNumber(format)){<span class="cstat-no" title="statement not covered" >index=format;<span class="cstat-no" title="statement not covered" >f</span>ormat=undefined;}<span class="cstat-no" title="statement not covered" ></span>f</span>ormat=format||'';}</span>else{<span class="cstat-no" title="statement not covered" >format=localeSorted;<span class="cstat-no" title="statement not covered" >i</span>ndex=format;<span class="cstat-no" title="statement not covered" >l</span>ocaleSorted=false;<span class="cstat-no" title="statement not covered" >i</span>f(isNumber(format)){<span class="cstat-no" title="statement not covered" >index=format;<span class="cstat-no" title="statement not covered" >f</span>ormat=undefined;}<span class="cstat-no" title="statement not covered" ></span>f</span>ormat=format||'';}</span>v</span>ar locale=<span class="cstat-no" title="statement not covered" >getLocale(),</span>shift=<span class="cstat-no" title="statement not covered" >localeSorted?locale._week.dow:0,</span>i,out=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(index!=null){<span class="cstat-no" title="statement not covered" >return get$1(format,(index+shift)%7,field,'day');}<span class="cstat-no" title="statement not covered" ></span>f</span>or(i=0;i&lt;7;i++){<span class="cstat-no" title="statement not covered" >out[i]=get$1(format,(i+shift)%7,field,'day');}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn out;}</span>function <span class="fstat-no" title="function not covered" >listMonths(</span>format,index){<span class="cstat-no" title="statement not covered" >return listMonthsImpl(format,index,'months');}</span>function <span class="fstat-no" title="function not covered" >listMonthsShort(</span>format,index){<span class="cstat-no" title="statement not covered" >return listMonthsImpl(format,index,'monthsShort');}</span>function <span class="fstat-no" title="function not covered" >listWeekdays(</span>localeSorted,format,index){<span class="cstat-no" title="statement not covered" >return listWeekdaysImpl(localeSorted,format,index,'weekdays');}</span>function <span class="fstat-no" title="function not covered" >listWeekdaysShort(</span>localeSorted,format,index){<span class="cstat-no" title="statement not covered" >return listWeekdaysImpl(localeSorted,format,index,'weekdaysShort');}</span>function <span class="fstat-no" title="function not covered" >listWeekdaysMin(</span>localeSorted,format,index){<span class="cstat-no" title="statement not covered" >return listWeekdaysImpl(localeSorted,format,index,'weekdaysMin');}<span class="cstat-no" title="statement not covered" ></span>getSetGlobalLocale('en',{eras:[{since:'0001-01-01',until:+Infinity,offset:1,name:'Anno Domini',narrow:'AD',abbr:'AD'},{since:'0000-12-31',until:-Infinity,offset:1,name:'Before Christ',narrow:'BC',abbr:'BC'}],dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var b=<span class="cstat-no" title="statement not covered" >number%10,</span>output=<span class="cstat-no" title="statement not covered" >toInt(number%100/10)===1?'th':b===1?'st':b===2?'nd':b===3?'rd':'th';<span class="cstat-no" title="statement not covered" ></span>return number+output;}</span>});/</span>/ Side effect imports
<span class="cstat-no" title="statement not covered" >hooks.lang=deprecate('moment.lang is deprecated. Use moment.locale instead.',getSetGlobalLocale);<span class="cstat-no" title="statement not covered" >h</span>ooks.langData=deprecate('moment.langData is deprecated. Use moment.localeData instead.',getLocale);v</span>ar mathAbs=<span class="cstat-no" title="statement not covered" >Math.abs;</span>function <span class="fstat-no" title="function not covered" >abs(</span>){var data=<span class="cstat-no" title="statement not covered" >this._data;<span class="cstat-no" title="statement not covered" ></span>this._milliseconds=mathAbs(this._milliseconds);<span class="cstat-no" title="statement not covered" >t</span>his._days=mathAbs(this._days);<span class="cstat-no" title="statement not covered" >t</span>his._months=mathAbs(this._months);<span class="cstat-no" title="statement not covered" >d</span>ata.milliseconds=mathAbs(data.milliseconds);<span class="cstat-no" title="statement not covered" >d</span>ata.seconds=mathAbs(data.seconds);<span class="cstat-no" title="statement not covered" >d</span>ata.minutes=mathAbs(data.minutes);<span class="cstat-no" title="statement not covered" >d</span>ata.hours=mathAbs(data.hours);<span class="cstat-no" title="statement not covered" >d</span>ata.months=mathAbs(data.months);<span class="cstat-no" title="statement not covered" >d</span>ata.years=mathAbs(data.years);<span class="cstat-no" title="statement not covered" >r</span>eturn this;}</span>function <span class="fstat-no" title="function not covered" >addSubtract$1(</span>duration,input,value,direction){var other=<span class="cstat-no" title="statement not covered" >createDuration(input,value);<span class="cstat-no" title="statement not covered" ></span>duration._milliseconds+=direction*other._milliseconds;<span class="cstat-no" title="statement not covered" >d</span>uration._days+=direction*other._days;<span class="cstat-no" title="statement not covered" >d</span>uration._months+=direction*other._months;<span class="cstat-no" title="statement not covered" >r</span>eturn duration._bubble();}</span>// supports only 2.0-style add(1, 's') or add(duration)
function <span class="fstat-no" title="function not covered" >add$1(</span>input,value){<span class="cstat-no" title="statement not covered" >return addSubtract$1(this,input,value,1);}</span>// supports only 2.0-style subtract(1, 's') or subtract(duration)
function <span class="fstat-no" title="function not covered" >subtract$1(</span>input,value){<span class="cstat-no" title="statement not covered" >return addSubtract$1(this,input,value,-1);}</span>function <span class="fstat-no" title="function not covered" >absCeil(</span>number){<span class="cstat-no" title="statement not covered" >if(number&lt;0){<span class="cstat-no" title="statement not covered" >return Math.floor(number);}</span>else{<span class="cstat-no" title="statement not covered" >return Math.ceil(number);}</span>}</span>function <span class="fstat-no" title="function not covered" >bubble(</span>){var milliseconds=<span class="cstat-no" title="statement not covered" >this._milliseconds,</span>days=<span class="cstat-no" title="statement not covered" >this._days,</span>months=<span class="cstat-no" title="statement not covered" >this._months,</span>data=<span class="cstat-no" title="statement not covered" >this._data,</span>seconds,minutes,hours,years,monthsFromDays;// if we have a mix of positive and negative values, bubble down first
// check: https://github.com/moment/moment/issues/2166
<span class="cstat-no" title="statement not covered" >if(!(milliseconds&gt;=0&amp;&amp;days&gt;=0&amp;&amp;months&gt;=0||milliseconds&lt;=0&amp;&amp;days&lt;=0&amp;&amp;months&lt;=0)){<span class="cstat-no" title="statement not covered" >milliseconds+=absCeil(monthsToDays(months)+days)*864e5;<span class="cstat-no" title="statement not covered" >d</span>ays=0;<span class="cstat-no" title="statement not covered" >m</span>onths=0;}</span>/</span>/ The following code bubbles up values, see the tests for
// examples of what that means.
<span class="cstat-no" title="statement not covered" >data.milliseconds=milliseconds%1000;<span class="cstat-no" title="statement not covered" >s</span>econds=absFloor(milliseconds/1000);<span class="cstat-no" title="statement not covered" >d</span>ata.seconds=seconds%60;<span class="cstat-no" title="statement not covered" >m</span>inutes=absFloor(seconds/60);<span class="cstat-no" title="statement not covered" >d</span>ata.minutes=minutes%60;<span class="cstat-no" title="statement not covered" >h</span>ours=absFloor(minutes/60);<span class="cstat-no" title="statement not covered" >d</span>ata.hours=hours%24;<span class="cstat-no" title="statement not covered" >d</span>ays+=absFloor(hours/24);/</span>/ convert days to months
<span class="cstat-no" title="statement not covered" >monthsFromDays=absFloor(daysToMonths(days));<span class="cstat-no" title="statement not covered" >m</span>onths+=monthsFromDays;<span class="cstat-no" title="statement not covered" >d</span>ays-=absCeil(monthsToDays(monthsFromDays));/</span>/ 12 months -&gt; 1 year
<span class="cstat-no" title="statement not covered" >years=absFloor(months/12);<span class="cstat-no" title="statement not covered" >m</span>onths%=12;<span class="cstat-no" title="statement not covered" >d</span>ata.days=days;<span class="cstat-no" title="statement not covered" >d</span>ata.months=months;<span class="cstat-no" title="statement not covered" >d</span>ata.years=years;<span class="cstat-no" title="statement not covered" >r</span>eturn this;}</span>function <span class="fstat-no" title="function not covered" >daysToMonths(</span>days){// 400 years have 146097 days (taking into account leap year rules)
// 400 years have 12 months === 4800
<span class="cstat-no" title="statement not covered" >return days*4800/146097;}</span>function <span class="fstat-no" title="function not covered" >monthsToDays(</span>months){// the reverse of daysToMonths
<span class="cstat-no" title="statement not covered" >return months*146097/4800;}</span>function <span class="fstat-no" title="function not covered" >as(</span>units){<span class="cstat-no" title="statement not covered" >if(!this.isValid()){<span class="cstat-no" title="statement not covered" >return NaN;}</span>v</span>ar days,months,milliseconds=<span class="cstat-no" title="statement not covered" >this._milliseconds;<span class="cstat-no" title="statement not covered" ></span>units=normalizeUnits(units);<span class="cstat-no" title="statement not covered" >i</span>f(units==='month'||units==='quarter'||units==='year'){<span class="cstat-no" title="statement not covered" >days=this._days+milliseconds/864e5;<span class="cstat-no" title="statement not covered" >m</span>onths=this._months+daysToMonths(days);<span class="cstat-no" title="statement not covered" >s</span>witch(units){case'month':<span class="cstat-no" title="statement not covered" >return months;c</span>ase'quarter':<span class="cstat-no" title="statement not covered" >return months/3;c</span>ase'year':<span class="cstat-no" title="statement not covered" >return months/12;}</span>}</span>else{// handle milliseconds separately because of floating point math errors (issue #1867)</span>
<span class="cstat-no" title="statement not covered" >days=this._days+Math.round(monthsToDays(this._months));<span class="cstat-no" title="statement not covered" >s</span>witch(units){case'week':<span class="cstat-no" title="statement not covered" >return days/7+milliseconds/6048e5;c</span>ase'day':<span class="cstat-no" title="statement not covered" >return days+milliseconds/864e5;c</span>ase'hour':<span class="cstat-no" title="statement not covered" >return days*24+milliseconds/36e5;c</span>ase'minute':<span class="cstat-no" title="statement not covered" >return days*1440+milliseconds/6e4;c</span>ase'second':<span class="cstat-no" title="statement not covered" >return days*86400+milliseconds/1000;/</span>/ Math.floor prevents floating point math errors here</span>
case'millisecond':<span class="cstat-no" title="statement not covered" >return Math.floor(days*864e5)+milliseconds;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error('ANY unit '+units);}</span>}}// TODO: Use this.as('ms')?
function <span class="fstat-no" title="function not covered" >valueOf$1(</span>){<span class="cstat-no" title="statement not covered" >if(!this.isValid()){<span class="cstat-no" title="statement not covered" >return NaN;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._milliseconds+this._days*864e5+this._months%12*2592e6+toInt(this._months/12)*31536e6;}</span>function <span class="fstat-no" title="function not covered" >makeAs(</span>alias){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.as(alias);}</span>;}</span>var asMilliseconds=<span class="cstat-no" title="statement not covered" >makeAs('ms'),</span>asSeconds=<span class="cstat-no" title="statement not covered" >makeAs('s'),</span>asMinutes=<span class="cstat-no" title="statement not covered" >makeAs('m'),</span>asHours=<span class="cstat-no" title="statement not covered" >makeAs('h'),</span>asDays=<span class="cstat-no" title="statement not covered" >makeAs('d'),</span>asWeeks=<span class="cstat-no" title="statement not covered" >makeAs('w'),</span>asMonths=<span class="cstat-no" title="statement not covered" >makeAs('M'),</span>asQuarters=<span class="cstat-no" title="statement not covered" >makeAs('Q'),</span>asYears=<span class="cstat-no" title="statement not covered" >makeAs('y');</span>function <span class="fstat-no" title="function not covered" >clone$1(</span>){<span class="cstat-no" title="statement not covered" >return createDuration(this);}</span>function <span class="fstat-no" title="function not covered" >get$2(</span>units){<span class="cstat-no" title="statement not covered" >units=normalizeUnits(units);<span class="cstat-no" title="statement not covered" >r</span>eturn this.isValid()?this[units+'s']():NaN;}</span>function <span class="fstat-no" title="function not covered" >makeGetter(</span>name){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.isValid()?this._data[name]:NaN;}</span>;}</span>var milliseconds=<span class="cstat-no" title="statement not covered" >makeGetter('milliseconds'),</span>seconds=<span class="cstat-no" title="statement not covered" >makeGetter('seconds'),</span>minutes=<span class="cstat-no" title="statement not covered" >makeGetter('minutes'),</span>hours=<span class="cstat-no" title="statement not covered" >makeGetter('hours'),</span>days=<span class="cstat-no" title="statement not covered" >makeGetter('days'),</span>months=<span class="cstat-no" title="statement not covered" >makeGetter('months'),</span>years=<span class="cstat-no" title="statement not covered" >makeGetter('years');</span>function <span class="fstat-no" title="function not covered" >weeks(</span>){<span class="cstat-no" title="statement not covered" >return absFloor(this.days()/7);}</span>var round=<span class="cstat-no" title="statement not covered" >Math.round,</span>thresholds=<span class="cstat-no" title="statement not covered" >{ss:44,// a few seconds to seconds</span>
s:45,// seconds to minute
m:45,// minutes to hour
h:22,// hours to day
d:26,// days to month/week
w:null,// weeks to month
M:11// months to year
};// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function <span class="fstat-no" title="function not covered" >substituteTimeAgo(</span>string,number,withoutSuffix,isFuture,locale){<span class="cstat-no" title="statement not covered" >return locale.relativeTime(number||1,!!withoutSuffix,string,isFuture);}</span>function <span class="fstat-no" title="function not covered" >relativeTime$1(</span>posNegDuration,withoutSuffix,thresholds,locale){var duration=<span class="cstat-no" title="statement not covered" >createDuration(posNegDuration).abs(),</span>seconds=<span class="cstat-no" title="statement not covered" >round(duration.as('s')),</span>minutes=<span class="cstat-no" title="statement not covered" >round(duration.as('m')),</span>hours=<span class="cstat-no" title="statement not covered" >round(duration.as('h')),</span>days=<span class="cstat-no" title="statement not covered" >round(duration.as('d')),</span>months=<span class="cstat-no" title="statement not covered" >round(duration.as('M')),</span>weeks=<span class="cstat-no" title="statement not covered" >round(duration.as('w')),</span>years=<span class="cstat-no" title="statement not covered" >round(duration.as('y')),</span>a=<span class="cstat-no" title="statement not covered" >seconds&lt;=thresholds.ss&amp;&amp;['s',seconds]||seconds&lt;thresholds.s&amp;&amp;['ss',seconds]||minutes&lt;=1&amp;&amp;['m']||minutes&lt;thresholds.m&amp;&amp;['mm',minutes]||hours&lt;=1&amp;&amp;['h']||hours&lt;thresholds.h&amp;&amp;['hh',hours]||days&lt;=1&amp;&amp;['d']||days&lt;thresholds.d&amp;&amp;['dd',days];<span class="cstat-no" title="statement not covered" ></span>if(thresholds.w!=null){<span class="cstat-no" title="statement not covered" >a=a||weeks&lt;=1&amp;&amp;['w']||weeks&lt;thresholds.w&amp;&amp;['ww',weeks];}<span class="cstat-no" title="statement not covered" ></span>a</span>=a||months&lt;=1&amp;&amp;['M']||months&lt;thresholds.M&amp;&amp;['MM',months]||years&lt;=1&amp;&amp;['y']||['yy',years];<span class="cstat-no" title="statement not covered" >a</span>[2]=withoutSuffix;<span class="cstat-no" title="statement not covered" >a</span>[3]=+posNegDuration&gt;0;<span class="cstat-no" title="statement not covered" >a</span>[4]=locale;<span class="cstat-no" title="statement not covered" >r</span>eturn substituteTimeAgo.apply(null,a);}</span>// This function allows you to set the rounding function for relative time strings
function <span class="fstat-no" title="function not covered" >getSetRelativeTimeRounding(</span>roundingFunction){<span class="cstat-no" title="statement not covered" >if(roundingFunction===undefined){<span class="cstat-no" title="statement not covered" >return round;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof roundingFunction==='function'){<span class="cstat-no" title="statement not covered" >round=roundingFunction;<span class="cstat-no" title="statement not covered" >r</span>eturn true;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span>// This function allows you to set a threshold for relative time strings
function <span class="fstat-no" title="function not covered" >getSetRelativeTimeThreshold(</span>threshold,limit){<span class="cstat-no" title="statement not covered" >if(thresholds[threshold]===undefined){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(limit===undefined){<span class="cstat-no" title="statement not covered" >return thresholds[threshold];}<span class="cstat-no" title="statement not covered" ></span>t</span>hresholds[threshold]=limit;<span class="cstat-no" title="statement not covered" >i</span>f(threshold==='s'){<span class="cstat-no" title="statement not covered" >thresholds.ss=limit-1;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn true;}</span>function <span class="fstat-no" title="function not covered" >humanize(</span>argWithSuffix,argThresholds){<span class="cstat-no" title="statement not covered" >if(!this.isValid()){<span class="cstat-no" title="statement not covered" >return this.localeData().invalidDate();}</span>v</span>ar withSuffix=<span class="cstat-no" title="statement not covered" >false,</span>th=<span class="cstat-no" title="statement not covered" >thresholds,</span>locale,output;<span class="cstat-no" title="statement not covered" >if(typeof argWithSuffix==='object'){<span class="cstat-no" title="statement not covered" >argThresholds=argWithSuffix;<span class="cstat-no" title="statement not covered" >a</span>rgWithSuffix=false;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof argWithSuffix==='boolean'){<span class="cstat-no" title="statement not covered" >withSuffix=argWithSuffix;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof argThresholds==='object'){<span class="cstat-no" title="statement not covered" >th=Object.assign({},thresholds,argThresholds);<span class="cstat-no" title="statement not covered" >i</span>f(argThresholds.s!=null&amp;&amp;argThresholds.ss==null){<span class="cstat-no" title="statement not covered" >th.ss=argThresholds.s-1;}</span>}<span class="cstat-no" title="statement not covered" ></span>l</span>ocale=this.localeData();<span class="cstat-no" title="statement not covered" >o</span>utput=relativeTime$1(this,!withSuffix,th,locale);<span class="cstat-no" title="statement not covered" >i</span>f(withSuffix){<span class="cstat-no" title="statement not covered" >output=locale.pastFuture(+this,output);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn locale.postformat(output);}</span>var abs$1=<span class="cstat-no" title="statement not covered" >Math.abs;</span>function <span class="fstat-no" title="function not covered" >sign(</span>x){<span class="cstat-no" title="statement not covered" >return(x&gt;0)-(x&lt;0)||+x;}</span>function <span class="fstat-no" title="function not covered" >toISOString$1(</span>){// for ISO strings we do not use the normal bubbling rules:
//  * milliseconds bubble up until they become hours
//  * days do not bubble at all
//  * months bubble up until they become years
// This is because there is no context-free conversion between hours and days
// (think of clock changes)
// and also not between days and months (28-31 days per month)
<span class="cstat-no" title="statement not covered" >if(!this.isValid()){<span class="cstat-no" title="statement not covered" >return this.localeData().invalidDate();}</span>v</span>ar seconds=<span class="cstat-no" title="statement not covered" >abs$1(this._milliseconds)/1000,</span>days=<span class="cstat-no" title="statement not covered" >abs$1(this._days),</span>months=<span class="cstat-no" title="statement not covered" >abs$1(this._months),</span>minutes,hours,years,s,total=<span class="cstat-no" title="statement not covered" >this.asSeconds(),</span>totalSign,ymSign,daysSign,hmsSign;<span class="cstat-no" title="statement not covered" >if(!total){// this is the same as C#'s (Noda) and python (isodate)...</span>
// but not other JS (goog.date)
<span class="cstat-no" title="statement not covered" >return'P0D';}</span>// 3600 seconds -&gt; 60 minutes -&gt; 1 hour
<span class="cstat-no" title="statement not covered" >minutes=absFloor(seconds/60);<span class="cstat-no" title="statement not covered" >h</span>ours=absFloor(minutes/60);<span class="cstat-no" title="statement not covered" >s</span>econds%=60;<span class="cstat-no" title="statement not covered" >m</span>inutes%=60;/</span>/ 12 months -&gt; 1 year
<span class="cstat-no" title="statement not covered" >years=absFloor(months/12);<span class="cstat-no" title="statement not covered" >m</span>onths%=12;/</span>/ inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
<span class="cstat-no" title="statement not covered" >s=seconds?seconds.toFixed(3).replace(/\.?0+$/,''):'';<span class="cstat-no" title="statement not covered" >t</span>otalSign=total&lt;0?'-':'';<span class="cstat-no" title="statement not covered" >y</span>mSign=sign(this._months)!==sign(total)?'-':'';<span class="cstat-no" title="statement not covered" >d</span>aysSign=sign(this._days)!==sign(total)?'-':'';<span class="cstat-no" title="statement not covered" >h</span>msSign=sign(this._milliseconds)!==sign(total)?'-':'';<span class="cstat-no" title="statement not covered" >r</span>eturn totalSign+'P'+(years?ymSign+years+'Y':'')+(months?ymSign+months+'M':'')+(days?daysSign+days+'D':'')+(hours||minutes||seconds?'T':'')+(hours?hmsSign+hours+'H':'')+(minutes?hmsSign+minutes+'M':'')+(seconds?hmsSign+s+'S':'');}</span>var proto$2=<span class="cstat-no" title="statement not covered" >Duration.prototype;<span class="cstat-no" title="statement not covered" ></span>proto$2.isValid=isValid$1;<span class="cstat-no" title="statement not covered" >p</span>roto$2.abs=abs;<span class="cstat-no" title="statement not covered" >p</span>roto$2.add=add$1;<span class="cstat-no" title="statement not covered" >p</span>roto$2.subtract=subtract$1;<span class="cstat-no" title="statement not covered" >p</span>roto$2.as=as;<span class="cstat-no" title="statement not covered" >p</span>roto$2.asMilliseconds=asMilliseconds;<span class="cstat-no" title="statement not covered" >p</span>roto$2.asSeconds=asSeconds;<span class="cstat-no" title="statement not covered" >p</span>roto$2.asMinutes=asMinutes;<span class="cstat-no" title="statement not covered" >p</span>roto$2.asHours=asHours;<span class="cstat-no" title="statement not covered" >p</span>roto$2.asDays=asDays;<span class="cstat-no" title="statement not covered" >p</span>roto$2.asWeeks=asWeeks;<span class="cstat-no" title="statement not covered" >p</span>roto$2.asMonths=asMonths;<span class="cstat-no" title="statement not covered" >p</span>roto$2.asQuarters=asQuarters;<span class="cstat-no" title="statement not covered" >p</span>roto$2.asYears=asYears;<span class="cstat-no" title="statement not covered" >p</span>roto$2.valueOf=valueOf$1;<span class="cstat-no" title="statement not covered" >p</span>roto$2._bubble=bubble;<span class="cstat-no" title="statement not covered" >p</span>roto$2.clone=clone$1;<span class="cstat-no" title="statement not covered" >p</span>roto$2.get=get$2;<span class="cstat-no" title="statement not covered" >p</span>roto$2.milliseconds=milliseconds;<span class="cstat-no" title="statement not covered" >p</span>roto$2.seconds=seconds;<span class="cstat-no" title="statement not covered" >p</span>roto$2.minutes=minutes;<span class="cstat-no" title="statement not covered" >p</span>roto$2.hours=hours;<span class="cstat-no" title="statement not covered" >p</span>roto$2.days=days;<span class="cstat-no" title="statement not covered" >p</span>roto$2.weeks=weeks;<span class="cstat-no" title="statement not covered" >p</span>roto$2.months=months;<span class="cstat-no" title="statement not covered" >p</span>roto$2.years=years;<span class="cstat-no" title="statement not covered" >p</span>roto$2.humanize=humanize;<span class="cstat-no" title="statement not covered" >p</span>roto$2.toISOString=toISOString$1;<span class="cstat-no" title="statement not covered" >p</span>roto$2.toString=toISOString$1;<span class="cstat-no" title="statement not covered" >p</span>roto$2.toJSON=toISOString$1;<span class="cstat-no" title="statement not covered" >p</span>roto$2.locale=locale;<span class="cstat-no" title="statement not covered" >p</span>roto$2.localeData=localeData;<span class="cstat-no" title="statement not covered" >p</span>roto$2.toIsoString=deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',toISOString$1);<span class="cstat-no" title="statement not covered" >p</span>roto$2.lang=lang;/</span>/ FORMATTING
<span class="cstat-no" title="statement not covered" >addFormatToken('X',0,0,'unix');<span class="cstat-no" title="statement not covered" >a</span>ddFormatToken('x',0,0,'valueOf');/</span>/ PARSING
<span class="cstat-no" title="statement not covered" >addRegexToken('x',matchSigned);<span class="cstat-no" title="statement not covered" >a</span>ddRegexToken('X',matchTimestamp);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken('X',<span class="fstat-no" title="function not covered" >fu</span>nction(input,array,config){<span class="cstat-no" title="statement not covered" >config._d=new Date(parseFloat(input)*1000);}</span>);<span class="cstat-no" title="statement not covered" >a</span>ddParseToken('x',<span class="fstat-no" title="function not covered" >fu</span>nction(input,array,config){<span class="cstat-no" title="statement not covered" >config._d=new Date(toInt(input));}</span>);/</span>/! moment.js
<span class="cstat-no" title="statement not covered" >hooks.version='2.29.1';<span class="cstat-no" title="statement not covered" >s</span>etHookCallback(createLocal);<span class="cstat-no" title="statement not covered" >h</span>ooks.fn=proto;<span class="cstat-no" title="statement not covered" >h</span>ooks.min=min;<span class="cstat-no" title="statement not covered" >h</span>ooks.max=max;<span class="cstat-no" title="statement not covered" >h</span>ooks.now=now;<span class="cstat-no" title="statement not covered" >h</span>ooks.utc=createUTC;<span class="cstat-no" title="statement not covered" >h</span>ooks.unix=createUnix;<span class="cstat-no" title="statement not covered" >h</span>ooks.months=listMonths;<span class="cstat-no" title="statement not covered" >h</span>ooks.isDate=isDate;<span class="cstat-no" title="statement not covered" >h</span>ooks.locale=getSetGlobalLocale;<span class="cstat-no" title="statement not covered" >h</span>ooks.invalid=createInvalid;<span class="cstat-no" title="statement not covered" >h</span>ooks.duration=createDuration;<span class="cstat-no" title="statement not covered" >h</span>ooks.isMoment=isMoment;<span class="cstat-no" title="statement not covered" >h</span>ooks.weekdays=listWeekdays;<span class="cstat-no" title="statement not covered" >h</span>ooks.parseZone=createInZone;<span class="cstat-no" title="statement not covered" >h</span>ooks.localeData=getLocale;<span class="cstat-no" title="statement not covered" >h</span>ooks.isDuration=isDuration;<span class="cstat-no" title="statement not covered" >h</span>ooks.monthsShort=listMonthsShort;<span class="cstat-no" title="statement not covered" >h</span>ooks.weekdaysMin=listWeekdaysMin;<span class="cstat-no" title="statement not covered" >h</span>ooks.defineLocale=defineLocale;<span class="cstat-no" title="statement not covered" >h</span>ooks.updateLocale=updateLocale;<span class="cstat-no" title="statement not covered" >h</span>ooks.locales=listLocales;<span class="cstat-no" title="statement not covered" >h</span>ooks.weekdaysShort=listWeekdaysShort;<span class="cstat-no" title="statement not covered" >h</span>ooks.normalizeUnits=normalizeUnits;<span class="cstat-no" title="statement not covered" >h</span>ooks.relativeTimeRounding=getSetRelativeTimeRounding;<span class="cstat-no" title="statement not covered" >h</span>ooks.relativeTimeThreshold=getSetRelativeTimeThreshold;<span class="cstat-no" title="statement not covered" >h</span>ooks.calendarFormat=getCalendarFormat;<span class="cstat-no" title="statement not covered" >h</span>ooks.prototype=proto;/</span>/ currently HTML5 input identifierDescription only supports 24-hour formats
<span class="cstat-no" title="statement not covered" >hooks.HTML5_FMT={DATETIME_LOCAL:'YYYY-MM-DDTHH:mm',// &lt;input identifierDescription="datetime-local" /&gt;</span>
DATETIME_LOCAL_SECONDS:'YYYY-MM-DDTHH:mm:ss',// &lt;input identifierDescription="datetime-local" step="1" /&gt;
DATETIME_LOCAL_MS:'YYYY-MM-DDTHH:mm:ss.SSS',// &lt;input identifierDescription="datetime-local" step="0.001" /&gt;
DATE:'YYYY-MM-DD',// &lt;input identifierDescription="date" /&gt;
TIME:'HH:mm',// &lt;input identifierDescription="time" /&gt;
TIME_SECONDS:'HH:mm:ss',// &lt;input identifierDescription="time" step="1" /&gt;
TIME_MS:'HH:mm:ss.SSS',// &lt;input identifierDescription="time" step="0.001" /&gt;
WEEK:'GGGG-[W]WW',// &lt;input identifierDescription="week" /&gt;
MONTH:'YYYY-MM'// &lt;input identifierDescription="month" /&gt;
};//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('af',{months:'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),monthsShort:'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),weekdays:'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),weekdaysShort:'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),weekdaysMin:'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),meridiemParse:/vm|nm/i,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return /^nm$/i.test(input);}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hours,minutes,isLower){<span class="cstat-no" title="statement not covered" >if(hours&lt;12){<span class="cstat-no" title="statement not covered" >return isLower?'vm':'VM';}</span>else{<span class="cstat-no" title="statement not covered" >return isLower?'nm':'NM';}</span>}</span>,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[Vandag om] LT',nextDay:'[Mre om] LT',nextWeek:'dddd [om] LT',lastDay:'[Gister om] LT',lastWeek:'[Laas] dddd [om] LT',sameElse:'L'},relativeTime:{future:'oor %s',past:'%s gelede',s:"'n paar sekondes",ss:'%d sekondes',m:"'n minuut",mm:'%d minute',h:"'n uur",hh:'%d ure',d:"'n dag",dd:'%d dae',M:"'n maand",MM:'%d maande',y:"'n jaar",yy:'%d jaar'},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >return number+(number===1||number===8||number&gt;=20?'ste':'de');/</span>/ Thanks to Joris Rling : https://github.com/jjupiter</span>
},week:{dow:1,// Maandag is die eerste dag van die week.
doy:4// Die week wat die 4de Januarie bevat is die eerste week van die jaar.
}});//! moment.js locale configuration
var pluralForm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return n===0?0:n===1?1:n===2?2:n%100&gt;=3&amp;&amp;n%100&lt;=10?3:n%100&gt;=11?4:5;}</span>,</span>plurals=<span class="cstat-no" title="statement not covered" >{s:['  ',' ',['',''],'%d ','%d ','%d '],m:['  ',' ',['',''],'%d ','%d ','%d '],h:['  ',' ',['',''],'%d ','%d ','%d '],d:['  ',' ',['',''],'%d ','%d ','%d '],M:['  ',' ',['',''],'%d ','%d ','%d '],y:['  ',' ',['',''],'%d ','%d ','%d ']},</span>pluralize=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(u){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(number,withoutSuffix,string,isFuture){var f=<span class="cstat-no" title="statement not covered" >pluralForm(number),</span>str=<span class="cstat-no" title="statement not covered" >plurals[u][pluralForm(number)];<span class="cstat-no" title="statement not covered" ></span>if(f===2){<span class="cstat-no" title="statement not covered" >str=str[withoutSuffix?0:1];}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn str.replace(/%d/i,number);}</span>;}</span>,</span>months$1=<span class="cstat-no" title="statement not covered" >['','','','','','','','','','','',''];<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('ar-dz',{months:months$1,monthsShort:months$1,weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'D/\u200FM/\u200FYYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},meridiemParse:/|/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return''===input;}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span>,calendar:{sameDay:'[  ] LT',nextDay:'[  ] LT',nextWeek:'dddd [ ] LT',lastDay:'[  ] LT',lastWeek:'dddd [ ] LT',sameElse:'L'},relativeTime:{future:' %s',past:' %s',s:pluralize('s'),ss:pluralize('s'),m:pluralize('m'),mm:pluralize('m'),h:pluralize('h'),hh:pluralize('h'),d:pluralize('d'),dd:pluralize('d'),M:pluralize('M'),MM:pluralize('M'),y:pluralize('y'),yy:pluralize('y')},postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/,/g,'');}</span>,week:{dow:0,// Sunday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('ar-kw',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},calendar:{sameDay:'[  ] LT',nextDay:'[  ] LT',nextWeek:'dddd [ ] LT',lastDay:'[  ] LT',lastWeek:'dddd [ ] LT',sameElse:'L'},relativeTime:{future:' %s',past:' %s',s:'',ss:'%d ',m:'',mm:'%d ',h:'',hh:'%d ',d:'',dd:'%d ',M:'',MM:'%d ',y:'',yy:'%d '},week:{dow:0,// Sunday is the first day of the week.</span>
doy:12// The week that contains Jan 12th is the first week of the year.
}});//! moment.js locale configuration
var symbolMap=<span class="cstat-no" title="statement not covered" >{1:'1',2:'2',3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',0:'0'},</span>pluralForm$1=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return n===0?0:n===1?1:n===2?2:n%100&gt;=3&amp;&amp;n%100&lt;=10?3:n%100&gt;=11?4:5;}</span>,</span>plurals$1=<span class="cstat-no" title="statement not covered" >{s:['  ',' ',['',''],'%d ','%d ','%d '],m:['  ',' ',['',''],'%d ','%d ','%d '],h:['  ',' ',['',''],'%d ','%d ','%d '],d:['  ',' ',['',''],'%d ','%d ','%d '],M:['  ',' ',['',''],'%d ','%d ','%d '],y:['  ',' ',['',''],'%d ','%d ','%d ']},</span>pluralize$1=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(u){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(number,withoutSuffix,string,isFuture){var f=<span class="cstat-no" title="statement not covered" >pluralForm$1(number),</span>str=<span class="cstat-no" title="statement not covered" >plurals$1[u][pluralForm$1(number)];<span class="cstat-no" title="statement not covered" ></span>if(f===2){<span class="cstat-no" title="statement not covered" >str=str[withoutSuffix?0:1];}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn str.replace(/%d/i,number);}</span>;}</span>,</span>months$2=<span class="cstat-no" title="statement not covered" >['','','','','','','','','','','',''];<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('ar-ly',{months:months$2,monthsShort:months$2,weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'D/\u200FM/\u200FYYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},meridiemParse:/|/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return''===input;}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span>,calendar:{sameDay:'[  ] LT',nextDay:'[  ] LT',nextWeek:'dddd [ ] LT',lastDay:'[  ] LT',lastWeek:'dddd [ ] LT',sameElse:'L'},relativeTime:{future:' %s',past:' %s',s:pluralize$1('s'),ss:pluralize$1('s'),m:pluralize$1('m'),mm:pluralize$1('m'),h:pluralize$1('h'),hh:pluralize$1('h'),d:pluralize$1('d'),dd:pluralize$1('d'),M:pluralize$1('M'),MM:pluralize$1('M'),y:pluralize$1('y'),yy:pluralize$1('y')},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(//g,',');}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap[match];}</span>).replace(/,/g,'');}</span>,week:{dow:6,// Saturday is the first day of the week.</span>
doy:12// The week that contains Jan 12th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('ar-ma',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},calendar:{sameDay:'[  ] LT',nextDay:'[  ] LT',nextWeek:'dddd [ ] LT',lastDay:'[  ] LT',lastWeek:'dddd [ ] LT',sameElse:'L'},relativeTime:{future:' %s',past:' %s',s:'',ss:'%d ',m:'',mm:'%d ',h:'',hh:'%d ',d:'',dd:'%d ',M:'',MM:'%d ',y:'',yy:'%d '},week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var symbolMap$1=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('ar-sa',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},meridiemParse:/|/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return''===input;}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span>,calendar:{sameDay:'[  ] LT',nextDay:'[  ] LT',nextWeek:'dddd [ ] LT',lastDay:'[  ] LT',lastWeek:'dddd [ ] LT',sameElse:'L'},relativeTime:{future:' %s',past:' %s',s:'',ss:'%d ',m:'',mm:'%d ',h:'',hh:'%d ',d:'',dd:'%d ',M:'',MM:'%d ',y:'',yy:'%d '},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap[match];}</span>).replace(//g,',');}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$1[match];}</span>).replace(/,/g,'');}</span>,week:{dow:0,// Sunday is the first day of the week.</span>
doy:6// The week that contains Jan 6th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('ar-tn',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},calendar:{sameDay:'[  ] LT',nextDay:'[  ] LT',nextWeek:'dddd [ ] LT',lastDay:'[  ] LT',lastWeek:'dddd [ ] LT',sameElse:'L'},relativeTime:{future:' %s',past:' %s',s:'',ss:'%d ',m:'',mm:'%d ',h:'',hh:'%d ',d:'',dd:'%d ',M:'',MM:'%d ',y:'',yy:'%d '},week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var symbolMap$2=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap$1=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'},</span>pluralForm$2=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return n===0?0:n===1?1:n===2?2:n%100&gt;=3&amp;&amp;n%100&lt;=10?3:n%100&gt;=11?4:5;}</span>,</span>plurals$2=<span class="cstat-no" title="statement not covered" >{s:['  ',' ',['',''],'%d ','%d ','%d '],m:['  ',' ',['',''],'%d ','%d ','%d '],h:['  ',' ',['',''],'%d ','%d ','%d '],d:['  ',' ',['',''],'%d ','%d ','%d '],M:['  ',' ',['',''],'%d ','%d ','%d '],y:['  ',' ',['',''],'%d ','%d ','%d ']},</span>pluralize$2=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(u){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(number,withoutSuffix,string,isFuture){var f=<span class="cstat-no" title="statement not covered" >pluralForm$2(number),</span>str=<span class="cstat-no" title="statement not covered" >plurals$2[u][pluralForm$2(number)];<span class="cstat-no" title="statement not covered" ></span>if(f===2){<span class="cstat-no" title="statement not covered" >str=str[withoutSuffix?0:1];}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn str.replace(/%d/i,number);}</span>;}</span>,</span>months$3=<span class="cstat-no" title="statement not covered" >['','','','','','','','','','','',''];<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('ar',{months:months$3,monthsShort:months$3,weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'D/\u200FM/\u200FYYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},meridiemParse:/|/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return''===input;}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span>,calendar:{sameDay:'[  ] LT',nextDay:'[  ] LT',nextWeek:'dddd [ ] LT',lastDay:'[  ] LT',lastWeek:'dddd [ ] LT',sameElse:'L'},relativeTime:{future:' %s',past:' %s',s:pluralize$2('s'),ss:pluralize$2('s'),m:pluralize$2('m'),mm:pluralize$2('m'),h:pluralize$2('h'),hh:pluralize$2('h'),d:pluralize$2('d'),dd:pluralize$2('d'),M:pluralize$2('M'),MM:pluralize$2('M'),y:pluralize$2('y'),yy:pluralize$2('y')},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap$1[match];}</span>).replace(//g,',');}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$2[match];}</span>).replace(/,/g,'');}</span>,week:{dow:6,// Saturday is the first day of the week.</span>
doy:12// The week that contains Jan 12th is the first week of the year.
}});//! moment.js locale configuration
var suffixes=<span class="cstat-no" title="statement not covered" >{1:'-inci',5:'-inci',8:'-inci',70:'-inci',80:'-inci',2:'-nci',7:'-nci',20:'-nci',50:'-nci',3:'-nc',4:'-nc',100:'-nc',6:'-nc',9:'-uncu',10:'-uncu',30:'-uncu',60:'-nc',90:'-nc'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('az',{months:'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),monthsShort:'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),weekdays:'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),weekdaysShort:'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),weekdaysMin:'Bz_BE_A__CA_C_'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[bugn saat] LT',nextDay:'[sabah saat] LT',nextWeek:'[gln hft] dddd [saat] LT',lastDay:'[dnn] LT',lastWeek:'[ken hft] dddd [saat] LT',sameElse:'L'},relativeTime:{future:'%s sonra',past:'%s vvl',s:'bir ne saniy',ss:'%d saniy',m:'bir dqiq',mm:'%d dqiq',h:'bir saat',hh:'%d saat',d:'bir gn',dd:'%d gn',M:'bir ay',MM:'%d ay',y:'bir il',yy:'%d il'},meridiemParse:/gec|shr|gndz|axam/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return /^(gndz|axam)$/.test(input);}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'gec';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'shr';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;17){<span class="cstat-no" title="statement not covered" >return'gndz';}</span>else{<span class="cstat-no" title="statement not covered" >return'axam';}</span>}</span></span></span>,dayOfMonthOrdinalParse:/\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >if(number===0){// special case for zero</span></span>
<span class="cstat-no" title="statement not covered" >return number+'-nc';}</span>var a=<span class="cstat-no" title="statement not covered" >number%10,</span>b=<span class="cstat-no" title="statement not covered" >number%100-a,</span>c=<span class="cstat-no" title="statement not covered" >number&gt;=100?100:null;<span class="cstat-no" title="statement not covered" ></span>return number+(suffixes[a]||suffixes[b]||suffixes[c]);}</span>,week:{dow:1,// Monday is the first day of the week.
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >plural(</span>word,num){var forms=<span class="cstat-no" title="statement not covered" >word.split('_');<span class="cstat-no" title="statement not covered" ></span>return num%10===1&amp;&amp;num%100!==11?forms[0]:num%10&gt;=2&amp;&amp;num%10&lt;=4&amp;&amp;(num%100&lt;10||num%100&gt;=20)?forms[1]:forms[2];}</span>function <span class="fstat-no" title="function not covered" >relativeTimeWithPlural(</span>number,withoutSuffix,key){var format=<span class="cstat-no" title="statement not covered" >{ss:withoutSuffix?'__':'__',mm:withoutSuffix?'__':'__',hh:withoutSuffix?'__':'__',dd:'__',MM:'__',yy:'__'};<span class="cstat-no" title="statement not covered" ></span>if(key==='m'){<span class="cstat-no" title="statement not covered" >return withoutSuffix?'':'';}</span>else <span class="cstat-no" title="statement not covered" >if(key==='h'){<span class="cstat-no" title="statement not covered" >return withoutSuffix?'':'';}</span>else{<span class="cstat-no" title="statement not covered" >return number+' '+plural(format[key],+number);}</span>}<span class="cstat-no" title="statement not covered" ></span></span>hooks.defineLocale('be',{months:{format:'___________'.split('_'),standalone:'___________'.split('_')},monthsShort:'___________'.split('_'),weekdays:{format:'______'.split('_'),standalone:'______'.split('_'),isFormat:/\[ ?[] ?(?:|)? ?\] ?dddd/},weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY .',LLL:'D MMMM YYYY ., HH:mm',LLLL:'dddd, D MMMM YYYY ., HH:mm'},calendar:{sameDay:'[ ] LT',nextDay:'[ ] LT',lastDay:'[ ] LT',nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[] dddd [] LT';}</span>,lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:case 3:case 5:case 6:<span class="cstat-no" title="statement not covered" >return'[ ] dddd [] LT';c</span>ase 1:case 2:case 4:<span class="cstat-no" title="statement not covered" >return'[ ] dddd [] LT';}</span>}</span>,sameElse:'L'},relativeTime:{future:' %s',past:'%s ',s:' ',m:relativeTimeWithPlural,mm:relativeTimeWithPlural,h:relativeTimeWithPlural,hh:relativeTimeWithPlural,d:'',dd:relativeTimeWithPlural,M:'',MM:relativeTimeWithPlural,y:'',yy:relativeTimeWithPlural},meridiemParse:/|||/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return /^(|)$/.test(input);}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;17){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span>,dayOfMonthOrdinalParse:/\d{1,2}-(||)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){case'M':case'd':case'DDD':case'w':case'W':<span class="cstat-no" title="statement not covered" >return(number%10===2||number%10===3)&amp;&amp;number%100!==12&amp;&amp;number%100!==13?number+'-':number+'-';c</span>ase'D':<span class="cstat-no" title="statement not covered" >return number+'-';d</span>efault:<span class="cstat-no" title="statement not covered" >return number;}</span>}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('bg',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'D.MM.YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY H:mm',LLLL:'dddd, D MMMM YYYY H:mm'},calendar:{sameDay:'[ ] LT',nextDay:'[ ] LT',nextWeek:'dddd [] LT',lastDay:'[ ] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:case 3:case 6:<span class="cstat-no" title="statement not covered" >return'[] dddd [] LT';c</span>ase 1:case 2:case 4:case 5:<span class="cstat-no" title="statement not covered" >return'[] dddd [] LT';}</span>}</span>,sameElse:'L'},relativeTime:{future:' %s',past:' %s',s:' ',ss:'%d ',m:'',mm:'%d ',h:'',hh:'%d ',d:'',dd:'%d ',w:'',ww:'%d ',M:'',MM:'%d ',y:'',yy:'%d '},dayOfMonthOrdinalParse:/\d{1,2}-(|||||)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var lastDigit=<span class="cstat-no" title="statement not covered" >number%10,</span>last2Digits=<span class="cstat-no" title="statement not covered" >number%100;<span class="cstat-no" title="statement not covered" ></span>if(number===0){<span class="cstat-no" title="statement not covered" >return number+'-';}</span>else <span class="cstat-no" title="statement not covered" >if(last2Digits===0){<span class="cstat-no" title="statement not covered" >return number+'-';}</span>else <span class="cstat-no" title="statement not covered" >if(last2Digits&gt;10&amp;&amp;last2Digits&lt;20){<span class="cstat-no" title="statement not covered" >return number+'-';}</span>else <span class="cstat-no" title="statement not covered" >if(lastDigit===1){<span class="cstat-no" title="statement not covered" >return number+'-';}</span>else <span class="cstat-no" title="statement not covered" >if(lastDigit===2){<span class="cstat-no" title="statement not covered" >return number+'-';}</span>else <span class="cstat-no" title="statement not covered" >if(lastDigit===7||lastDigit===8){<span class="cstat-no" title="statement not covered" >return number+'-';}</span>else{<span class="cstat-no" title="statement not covered" >return number+'-';}</span>}</span></span></span></span></span></span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('bm',{months:'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo'.split('_'),monthsShort:'Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des'.split('_'),weekdays:'Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),weekdaysShort:'Kar_Nt_Tar_Ara_Ala_Jum_Sib'.split('_'),weekdaysMin:'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'MMMM [tile] D [san] YYYY',LLL:'MMMM [tile] D [san] YYYY [lr] HH:mm',LLLL:'dddd MMMM [tile] D [san] YYYY [lr] HH:mm'},calendar:{sameDay:'[Bi lr] LT',nextDay:'[Sini lr] LT',nextWeek:'dddd [don lr] LT',lastDay:'[Kunu lr] LT',lastWeek:'dddd [tmnen lr] LT',sameElse:'L'},relativeTime:{future:'%s kn',past:'a b %s b',s:'sanga dama dama',ss:'sekondi %d',m:'miniti kelen',mm:'miniti %d',h:'lr kelen',hh:'lr %d',d:'tile kelen',dd:'tile %d',M:'kalo kelen',MM:'kalo %d',y:'san kelen',yy:'san %d'},week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var symbolMap$3=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap$2=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('bn-bd',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'A h:mm ',LTS:'A h:mm:ss ',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY, A h:mm ',LLLL:'dddd, D MMMM YYYY, A h:mm '},calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'dddd, LT',lastDay:'[] LT',lastWeek:'[] dddd, LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap$2[match];}</span>);}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$3[match];}</span>);}</span>,meridiemParse:/||||||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&lt;4?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&gt;=3?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span></span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;6){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;15){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;18){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;20){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span></span></span>,week:{dow:0,// Sunday is the first day of the week.</span>
doy:6// The week that contains Jan 6th is the first week of the year.
}});//! moment.js locale configuration
var symbolMap$4=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap$3=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('bn',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'A h:mm ',LTS:'A h:mm:ss ',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY, A h:mm ',LLLL:'dddd, D MMMM YYYY, A h:mm '},calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'dddd, LT',lastDay:'[] LT',lastWeek:'[] dddd, LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap$3[match];}</span>);}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$4[match];}</span>);}</span>,meridiemParse:/||||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''&amp;&amp;hour&gt;=4||meridiem===''&amp;&amp;hour&lt;5||meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>else{<span class="cstat-no" title="statement not covered" >return hour;}</span>}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;10){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;17){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;20){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span>,week:{dow:0,// Sunday is the first day of the week.</span>
doy:6// The week that contains Jan 6th is the first week of the year.
}});//! moment.js locale configuration
var symbolMap$5=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap$4=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('bo',{months:'___________'.split('_'),monthsShort:'1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),monthsShortRegex:/^(\d{1,2})/,monthsParseExact:true,weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'A h:mm',LTS:'A h:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY, A h:mm',LLLL:'dddd, D MMMM YYYY, A h:mm'},calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'[], LT',lastDay:'[] LT',lastWeek:'[] dddd, LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:'',ss:'%d ',m:'',mm:'%d ',h:'',hh:'%d ',d:'',dd:'%d ',M:'',MM:'%d ',y:'',yy:'%d '},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap$4[match];}</span>);}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$5[match];}</span>);}</span>,meridiemParse:/||||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''&amp;&amp;hour&gt;=4||meridiem===''&amp;&amp;hour&lt;5||meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>else{<span class="cstat-no" title="statement not covered" >return hour;}</span>}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;10){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;17){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;20){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span>,week:{dow:0,// Sunday is the first day of the week.</span>
doy:6// The week that contains Jan 6th is the first week of the year.
}});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >relativeTimeWithMutation(</span>number,withoutSuffix,key){var format=<span class="cstat-no" title="statement not covered" >{mm:'munutenn',MM:'miz',dd:'devezh'};<span class="cstat-no" title="statement not covered" ></span>return number+' '+mutation(format[key],number);}</span>function <span class="fstat-no" title="function not covered" >specialMutationForYears(</span>number){<span class="cstat-no" title="statement not covered" >switch(lastNumber(number)){case 1:case 3:case 4:case 5:case 9:<span class="cstat-no" title="statement not covered" >return number+' bloaz';d</span>efault:<span class="cstat-no" title="statement not covered" >return number+' vloaz';}</span>}</span>function <span class="fstat-no" title="function not covered" >lastNumber(</span>number){<span class="cstat-no" title="statement not covered" >if(number&gt;9){<span class="cstat-no" title="statement not covered" >return lastNumber(number%10);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn number;}</span>function <span class="fstat-no" title="function not covered" >mutation(</span>text,number){<span class="cstat-no" title="statement not covered" >if(number===2){<span class="cstat-no" title="statement not covered" >return softMutation(text);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn text;}</span>function <span class="fstat-no" title="function not covered" >softMutation(</span>text){var mutationTable=<span class="cstat-no" title="statement not covered" >{m:'v',b:'v',d:'z'};<span class="cstat-no" title="statement not covered" ></span>if(mutationTable[text.charAt(0)]===undefined){<span class="cstat-no" title="statement not covered" >return text;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn mutationTable[text.charAt(0)]+text.substring(1);}</span>var monthsParse=<span class="cstat-no" title="statement not covered" >[/^gen/i,/^c[\']hwe/i,/^meu/i,/^ebr/i,/^mae/i,/^(mez|eve)/i,/^gou/i,/^eos/i,/^gwe/i,/^her/i,/^du/i,/^ker/i],</span>monthsRegex$1=<span class="cstat-no" title="statement not covered" >/^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,</span>monthsStrictRegex=<span class="cstat-no" title="statement not covered" >/^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i,</span>monthsShortStrictRegex=<span class="cstat-no" title="statement not covered" >/^(gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,</span>fullWeekdaysParse=<span class="cstat-no" title="statement not covered" >[/^sul/i,/^lun/i,/^meurzh/i,/^merc[\']her/i,/^yaou/i,/^gwener/i,/^sadorn/i],</span>shortWeekdaysParse=<span class="cstat-no" title="statement not covered" >[/^Sul/i,/^Lun/i,/^Meu/i,/^Mer/i,/^Yao/i,/^Gwe/i,/^Sad/i],</span>minWeekdaysParse=<span class="cstat-no" title="statement not covered" >[/^Su/i,/^Lu/i,/^Me([^r]|$)/i,/^Mer/i,/^Ya/i,/^Gw/i,/^Sa/i];<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('br',{months:'Genver_Chwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),monthsShort:'Gen_Chwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),weekdays:'Sul_Lun_Meurzh_Mercher_Yaou_Gwener_Sadorn'.split('_'),weekdaysShort:'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),weekdaysMin:'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),weekdaysParse:minWeekdaysParse,fullWeekdaysParse:fullWeekdaysParse,shortWeekdaysParse:shortWeekdaysParse,minWeekdaysParse:minWeekdaysParse,monthsRegex:monthsRegex$1,monthsShortRegex:monthsRegex$1,monthsStrictRegex:monthsStrictRegex,monthsShortStrictRegex:monthsShortStrictRegex,monthsParse:monthsParse,longMonthsParse:monthsParse,shortMonthsParse:monthsParse,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D [a viz] MMMM YYYY',LLL:'D [a viz] MMMM YYYY HH:mm',LLLL:'dddd, D [a viz] MMMM YYYY HH:mm'},calendar:{sameDay:'[Hiziv da] LT',nextDay:'[Warchoazh da] LT',nextWeek:'dddd [da] LT',lastDay:'[Dech da] LT',lastWeek:'dddd [paset da] LT',sameElse:'L'},relativeTime:{future:'a-benn %s',past:'%s zo',s:'un nebeud segondenno',ss:'%d eilenn',m:'ur vunutenn',mm:relativeTimeWithMutation,h:'un eur',hh:'%d eur',d:'un devezh',dd:relativeTimeWithMutation,M:'ur miz',MM:relativeTimeWithMutation,y:'ur bloaz',yy:specialMutationForYears},dayOfMonthOrdinalParse:/\d{1,2}(a|vet)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var output=<span class="cstat-no" title="statement not covered" >number===1?'a':'vet';<span class="cstat-no" title="statement not covered" ></span>return number+output;}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
},meridiemParse:/a.m.|g.m./,// goude merenn | a-raok merenn
isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(token){<span class="cstat-no" title="statement not covered" >return token==='g.m.';}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >return hour&lt;12?'a.m.':'g.m.';}</span>});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >translate(</span>number,withoutSuffix,key){var result=<span class="cstat-no" title="statement not covered" >number+' ';<span class="cstat-no" title="statement not covered" ></span>switch(key){case'ss':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+='sekunda';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2||number===3||number===4){<span class="cstat-no" title="statement not covered" >result+='sekunde';}</span>else{<span class="cstat-no" title="statement not covered" >result+='sekundi';}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn result;c</span>ase'm':<span class="cstat-no" title="statement not covered" >return withoutSuffix?'jedna minuta':'jedne minute';c</span>ase'mm':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+='minuta';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2||number===3||number===4){<span class="cstat-no" title="statement not covered" >result+='minute';}</span>else{<span class="cstat-no" title="statement not covered" >result+='minuta';}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn result;c</span>ase'h':<span class="cstat-no" title="statement not covered" >return withoutSuffix?'jedan sat':'jednog sata';c</span>ase'hh':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+='sat';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2||number===3||number===4){<span class="cstat-no" title="statement not covered" >result+='sata';}</span>else{<span class="cstat-no" title="statement not covered" >result+='sati';}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn result;c</span>ase'dd':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+='dan';}</span>else{<span class="cstat-no" title="statement not covered" >result+='dana';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn result;c</span>ase'MM':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+='mjesec';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2||number===3||number===4){<span class="cstat-no" title="statement not covered" >result+='mjeseca';}</span>else{<span class="cstat-no" title="statement not covered" >result+='mjeseci';}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn result;c</span>ase'yy':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+='godina';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2||number===3||number===4){<span class="cstat-no" title="statement not covered" >result+='godine';}</span>else{<span class="cstat-no" title="statement not covered" >result+='godina';}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn result;}</span>}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('bs',{months:'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),monthsShort:'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),monthsParseExact:true,weekdays:'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),weekdaysShort:'ned._pon._uto._sri._et._pet._sub.'.split('_'),weekdaysMin:'ne_po_ut_sr_e_pe_su'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD.MM.YYYY',LL:'D. MMMM YYYY',LLL:'D. MMMM YYYY H:mm',LLLL:'dddd, D. MMMM YYYY H:mm'},calendar:{sameDay:'[danas u] LT',nextDay:'[sutra u] LT',nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[u] [nedjelju] [u] LT';c</span>ase 3:<span class="cstat-no" title="statement not covered" >return'[u] [srijedu] [u] LT';c</span>ase 6:<span class="cstat-no" title="statement not covered" >return'[u] [subotu] [u] LT';c</span>ase 1:case 2:case 4:case 5:<span class="cstat-no" title="statement not covered" >return'[u] dddd [u] LT';}</span>}</span>,lastDay:'[juer u] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:case 3:<span class="cstat-no" title="statement not covered" >return'[prolu] dddd [u] LT';c</span>ase 6:<span class="cstat-no" title="statement not covered" >return'[prole] [subote] [u] LT';c</span>ase 1:case 2:case 4:case 5:<span class="cstat-no" title="statement not covered" >return'[proli] dddd [u] LT';}</span>}</span>,sameElse:'L'},relativeTime:{future:'za %s',past:'prije %s',s:'par sekundi',ss:translate,m:translate,mm:translate,h:translate,hh:translate,d:'dan',dd:translate,M:'mjesec',MM:translate,y:'godinu',yy:translate},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('ca',{months:{standalone:'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),format:"de gener_de febrer_de mar_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split('_'),isFormat:/D[oD]?(\s)+MMMM/},monthsShort:'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),monthsParseExact:true,weekdays:'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),weekdaysShort:'dg._dl._dt._dc._dj._dv._ds.'.split('_'),weekdaysMin:'dg_dl_dt_dc_dj_dv_ds'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM [de] YYYY',ll:'D MMM YYYY',LLL:'D MMMM [de] YYYY [a les] H:mm',lll:'D MMM YYYY, H:mm',LLLL:'dddd D MMMM [de] YYYY [a les] H:mm',llll:'ddd D MMM YYYY, H:mm'},calendar:{sameDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[avui a '+(this.hours()!==1?'les':'la')+'] LT';}</span>,nextDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[dem a '+(this.hours()!==1?'les':'la')+'] LT';}</span>,nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'dddd [a '+(this.hours()!==1?'les':'la')+'] LT';}</span>,lastDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[ahir a '+(this.hours()!==1?'les':'la')+'] LT';}</span>,lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[el] dddd [passat a '+(this.hours()!==1?'les':'la')+'] LT';}</span>,sameElse:'L'},relativeTime:{future:"d'aqu %s",past:'fa %s',s:'uns segons',ss:'%d segons',m:'un minut',mm:'%d minuts',h:'una hora',hh:'%d hores',d:'un dia',dd:'%d dies',M:'un mes',MM:'%d mesos',y:'un any',yy:'%d anys'},dayOfMonthOrdinalParse:/\d{1,2}(r|n|t||a)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){var output=<span class="cstat-no" title="statement not covered" >number===1?'r':number===2?'n':number===3?'r':number===4?'t':'';<span class="cstat-no" title="statement not covered" ></span>if(period==='w'||period==='W'){<span class="cstat-no" title="statement not covered" >output='a';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn number+output;}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var months$4=<span class="cstat-no" title="statement not covered" >'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),</span>monthsShort=<span class="cstat-no" title="statement not covered" >'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_'),</span>monthsParse$1=<span class="cstat-no" title="statement not covered" >[/^led/i,/^no/i,/^be/i,/^dub/i,/^kv/i,/^(vn|erven$|ervna)/i,/^(vc|ervenec|ervence)/i,/^srp/i,/^z/i,/^j/i,/^lis/i,/^pro/i],</span>// NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
// Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
monthsRegex$2=<span class="cstat-no" title="statement not covered" >/^(leden|nor|bezen|duben|kvten|ervenec|ervence|erven|ervna|srpen|z|jen|listopad|prosinec|led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i;</span>function <span class="fstat-no" title="function not covered" >plural$1(</span>n){<span class="cstat-no" title="statement not covered" >return n&gt;1&amp;&amp;n&lt;5&amp;&amp;~~(n/10)!==1;}</span>function <span class="fstat-no" title="function not covered" >translate$1(</span>number,withoutSuffix,key,isFuture){var result=<span class="cstat-no" title="statement not covered" >number+' ';<span class="cstat-no" title="statement not covered" ></span>switch(key){case's':// a few seconds / in a few seconds / a few seconds ago</span>
<span class="cstat-no" title="statement not covered" >return withoutSuffix||isFuture?'pr sekund':'pr sekundami';c</span>ase'ss':// 9 seconds / in 9 seconds / 9 seconds ago
<span class="cstat-no" title="statement not covered" >if(withoutSuffix||isFuture){<span class="cstat-no" title="statement not covered" >return result+(plural$1(number)?'sekundy':'sekund');}</span>else{<span class="cstat-no" title="statement not covered" >return result+'sekundami';}</span>c</span>ase'm':// a minute / in a minute / a minute ago
<span class="cstat-no" title="statement not covered" >return withoutSuffix?'minuta':isFuture?'minutu':'minutou';c</span>ase'mm':// 9 minutes / in 9 minutes / 9 minutes ago
<span class="cstat-no" title="statement not covered" >if(withoutSuffix||isFuture){<span class="cstat-no" title="statement not covered" >return result+(plural$1(number)?'minuty':'minut');}</span>else{<span class="cstat-no" title="statement not covered" >return result+'minutami';}</span>c</span>ase'h':// an hour / in an hour / an hour ago
<span class="cstat-no" title="statement not covered" >return withoutSuffix?'hodina':isFuture?'hodinu':'hodinou';c</span>ase'hh':// 9 hours / in 9 hours / 9 hours ago
<span class="cstat-no" title="statement not covered" >if(withoutSuffix||isFuture){<span class="cstat-no" title="statement not covered" >return result+(plural$1(number)?'hodiny':'hodin');}</span>else{<span class="cstat-no" title="statement not covered" >return result+'hodinami';}</span>c</span>ase'd':// a day / in a day / a day ago
<span class="cstat-no" title="statement not covered" >return withoutSuffix||isFuture?'den':'dnem';c</span>ase'dd':// 9 days / in 9 days / 9 days ago
<span class="cstat-no" title="statement not covered" >if(withoutSuffix||isFuture){<span class="cstat-no" title="statement not covered" >return result+(plural$1(number)?'dny':'dn');}</span>else{<span class="cstat-no" title="statement not covered" >return result+'dny';}</span>c</span>ase'M':// a month / in a month / a month ago
<span class="cstat-no" title="statement not covered" >return withoutSuffix||isFuture?'msc':'mscem';c</span>ase'MM':// 9 months / in 9 months / 9 months ago
<span class="cstat-no" title="statement not covered" >if(withoutSuffix||isFuture){<span class="cstat-no" title="statement not covered" >return result+(plural$1(number)?'msce':'msc');}</span>else{<span class="cstat-no" title="statement not covered" >return result+'msci';}</span>c</span>ase'y':// a year / in a year / a year ago
<span class="cstat-no" title="statement not covered" >return withoutSuffix||isFuture?'rok':'rokem';c</span>ase'yy':// 9 years / in 9 years / 9 years ago
<span class="cstat-no" title="statement not covered" >if(withoutSuffix||isFuture){<span class="cstat-no" title="statement not covered" >return result+(plural$1(number)?'roky':'let');}</span>else{<span class="cstat-no" title="statement not covered" >return result+'lety';}</span>}</span>}<span class="cstat-no" title="statement not covered" >hooks.defineLocale('cs',{months:months$4,monthsShort:monthsShort,monthsRegex:monthsRegex$2,monthsShortRegex:monthsRegex$2,// NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.</span>
// Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
monthsStrictRegex:/^(leden|ledna|nora|nor|bezen|bezna|duben|dubna|kvten|kvtna|ervenec|ervence|erven|ervna|srpen|srpna|z|jen|jna|listopadu|listopad|prosinec|prosince)/i,monthsShortStrictRegex:/^(led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i,monthsParse:monthsParse$1,longMonthsParse:monthsParse$1,shortMonthsParse:monthsParse$1,weekdays:'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),weekdaysShort:'ne_po_t_st_t_p_so'.split('_'),weekdaysMin:'ne_po_t_st_t_p_so'.split('_'),longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD.MM.YYYY',LL:'D. MMMM YYYY',LLL:'D. MMMM YYYY H:mm',LLLL:'dddd D. MMMM YYYY H:mm',l:'D. M. YYYY'},calendar:{sameDay:'[dnes v] LT',nextDay:'[ztra v] LT',nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[v nedli v] LT';c</span>ase 1:case 2:<span class="cstat-no" title="statement not covered" >return'[v] dddd [v] LT';c</span>ase 3:<span class="cstat-no" title="statement not covered" >return'[ve stedu v] LT';c</span>ase 4:<span class="cstat-no" title="statement not covered" >return'[ve tvrtek v] LT';c</span>ase 5:<span class="cstat-no" title="statement not covered" >return'[v ptek v] LT';c</span>ase 6:<span class="cstat-no" title="statement not covered" >return'[v sobotu v] LT';}</span>}</span>,lastDay:'[vera v] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[minulou nedli v] LT';c</span>ase 1:case 2:<span class="cstat-no" title="statement not covered" >return'[minul] dddd [v] LT';c</span>ase 3:<span class="cstat-no" title="statement not covered" >return'[minulou stedu v] LT';c</span>ase 4:case 5:<span class="cstat-no" title="statement not covered" >return'[minul] dddd [v] LT';c</span>ase 6:<span class="cstat-no" title="statement not covered" >return'[minulou sobotu v] LT';}</span>}</span>,sameElse:'L'},relativeTime:{future:'za %s',past:'ped %s',s:translate$1,ss:translate$1,m:translate$1,mm:translate$1,h:translate$1,hh:translate$1,d:translate$1,dd:translate$1,M:translate$1,MM:translate$1,y:translate$1,yy:translate$1},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('cv',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD-MM-YYYY',LL:'YYYY [] MMMM [] D[-]',LLL:'YYYY [] MMMM [] D[-], HH:mm',LLLL:'dddd, YYYY [] MMMM [] D[-], HH:mm'},calendar:{sameDay:'[] LT []',nextDay:'[] LT []',lastDay:'[] LT []',nextWeek:'[] dddd LT []',lastWeek:'[] dddd LT []',sameElse:'L'},relativeTime:{future:<span class="fstat-no" title="function not covered" >fu</span>nction(output){var affix=<span class="cstat-no" title="statement not covered" >/$/i.exec(output)?'':/$/i.exec(output)?'':'';<span class="cstat-no" title="statement not covered" ></span>return output+affix;}</span>,past:'%s ',s:'- ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},dayOfMonthOrdinalParse:/\d{1,2}-/,ordinal:'%d-',week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('cy',{months:'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),monthsShort:'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),weekdays:'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),weekdaysShort:'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),weekdaysMin:'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),weekdaysParseExact:true,// time formats are the same as en-gb</span>
longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[Heddiw am] LT',nextDay:'[Yfory am] LT',nextWeek:'dddd [am] LT',lastDay:'[Ddoe am] LT',lastWeek:'dddd [diwethaf am] LT',sameElse:'L'},relativeTime:{future:'mewn %s',past:'%s yn l',s:'ychydig eiliadau',ss:'%d eiliad',m:'munud',mm:'%d munud',h:'awr',hh:'%d awr',d:'diwrnod',dd:'%d diwrnod',M:'mis',MM:'%d mis',y:'blwyddyn',yy:'%d flynedd'},dayOfMonthOrdinalParse:/\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,// traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var b=<span class="cstat-no" title="statement not covered" >number,</span>output=<span class="cstat-no" title="statement not covered" >'',</span>lookup=<span class="cstat-no" title="statement not covered" >['','af','il','ydd','ydd','ed','ed','ed','fed','fed','fed',// 1af to 10fed</span>
'eg','fed','eg','eg','fed','eg','eg','fed','eg','fed'// 11eg to 20fed
];<span class="cstat-no" title="statement not covered" >if(b&gt;20){<span class="cstat-no" title="statement not covered" >if(b===40||b===50||b===60||b===80||b===100){<span class="cstat-no" title="statement not covered" >output='fed';/</span>/ not 30ain, 70ain or 90ain</span></span>
}else{<span class="cstat-no" title="statement not covered" >output='ain';}</span>}else <span class="cstat-no" title="statement not covered" >if(b&gt;0){<span class="cstat-no" title="statement not covered" >output=lookup[b];}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn number+output;}</span>,week:{dow:1,// Monday is the first day of the week.
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('da',{months:'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),monthsShort:'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),weekdays:'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),weekdaysShort:'sn_man_tir_ons_tor_fre_lr'.split('_'),weekdaysMin:'s_ma_ti_on_to_fr_l'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D. MMMM YYYY',LLL:'D. MMMM YYYY HH:mm',LLLL:'dddd [d.] D. MMMM YYYY [kl.] HH:mm'},calendar:{sameDay:'[i dag kl.] LT',nextDay:'[i morgen kl.] LT',nextWeek:'p dddd [kl.] LT',lastDay:'[i gr kl.] LT',lastWeek:'[i] dddd[s kl.] LT',sameElse:'L'},relativeTime:{future:'om %s',past:'%s siden',s:'f sekunder',ss:'%d sekunder',m:'et minut',mm:'%d minutter',h:'en time',hh:'%d timer',d:'en dag',dd:'%d dage',M:'en mned',MM:'%d mneder',y:'et r',yy:'%d r'},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >processRelativeTime(</span>number,withoutSuffix,key,isFuture){var format=<span class="cstat-no" title="statement not covered" >{m:['eine Minute','einer Minute'],h:['eine Stunde','einer Stunde'],d:['ein Tag','einem Tag'],dd:[number+' Tage',number+' Tagen'],w:['eine Woche','einer Woche'],M:['ein Monat','einem Monat'],MM:[number+' Monate',number+' Monaten'],y:['ein Jahr','einem Jahr'],yy:[number+' Jahre',number+' Jahren']};<span class="cstat-no" title="statement not covered" ></span>return withoutSuffix?format[key][0]:format[key][1];}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('de-at',{months:'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),monthsShort:'Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),monthsParseExact:true,weekdays:'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),weekdaysShort:'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),weekdaysMin:'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D. MMMM YYYY',LLL:'D. MMMM YYYY HH:mm',LLLL:'dddd, D. MMMM YYYY HH:mm'},calendar:{sameDay:'[heute um] LT [Uhr]',sameElse:'L',nextDay:'[morgen um] LT [Uhr]',nextWeek:'dddd [um] LT [Uhr]',lastDay:'[gestern um] LT [Uhr]',lastWeek:'[letzten] dddd [um] LT [Uhr]'},relativeTime:{future:'in %s',past:'vor %s',s:'ein paar Sekunden',ss:'%d Sekunden',m:processRelativeTime,mm:'%d Minuten',h:processRelativeTime,hh:'%d Stunden',d:processRelativeTime,dd:processRelativeTime,w:processRelativeTime,ww:'%d Wochen',M:processRelativeTime,MM:processRelativeTime,y:processRelativeTime,yy:processRelativeTime},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >processRelativeTime$1(</span>number,withoutSuffix,key,isFuture){var format=<span class="cstat-no" title="statement not covered" >{m:['eine Minute','einer Minute'],h:['eine Stunde','einer Stunde'],d:['ein Tag','einem Tag'],dd:[number+' Tage',number+' Tagen'],w:['eine Woche','einer Woche'],M:['ein Monat','einem Monat'],MM:[number+' Monate',number+' Monaten'],y:['ein Jahr','einem Jahr'],yy:[number+' Jahre',number+' Jahren']};<span class="cstat-no" title="statement not covered" ></span>return withoutSuffix?format[key][0]:format[key][1];}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('de-ch',{months:'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),monthsShort:'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),monthsParseExact:true,weekdays:'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),weekdaysShort:'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),weekdaysMin:'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D. MMMM YYYY',LLL:'D. MMMM YYYY HH:mm',LLLL:'dddd, D. MMMM YYYY HH:mm'},calendar:{sameDay:'[heute um] LT [Uhr]',sameElse:'L',nextDay:'[morgen um] LT [Uhr]',nextWeek:'dddd [um] LT [Uhr]',lastDay:'[gestern um] LT [Uhr]',lastWeek:'[letzten] dddd [um] LT [Uhr]'},relativeTime:{future:'in %s',past:'vor %s',s:'ein paar Sekunden',ss:'%d Sekunden',m:processRelativeTime$1,mm:'%d Minuten',h:processRelativeTime$1,hh:'%d Stunden',d:processRelativeTime$1,dd:processRelativeTime$1,w:processRelativeTime$1,ww:'%d Wochen',M:processRelativeTime$1,MM:processRelativeTime$1,y:processRelativeTime$1,yy:processRelativeTime$1},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >processRelativeTime$2(</span>number,withoutSuffix,key,isFuture){var format=<span class="cstat-no" title="statement not covered" >{m:['eine Minute','einer Minute'],h:['eine Stunde','einer Stunde'],d:['ein Tag','einem Tag'],dd:[number+' Tage',number+' Tagen'],w:['eine Woche','einer Woche'],M:['ein Monat','einem Monat'],MM:[number+' Monate',number+' Monaten'],y:['ein Jahr','einem Jahr'],yy:[number+' Jahre',number+' Jahren']};<span class="cstat-no" title="statement not covered" ></span>return withoutSuffix?format[key][0]:format[key][1];}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('de',{months:'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),monthsShort:'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),monthsParseExact:true,weekdays:'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),weekdaysShort:'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),weekdaysMin:'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D. MMMM YYYY',LLL:'D. MMMM YYYY HH:mm',LLLL:'dddd, D. MMMM YYYY HH:mm'},calendar:{sameDay:'[heute um] LT [Uhr]',sameElse:'L',nextDay:'[morgen um] LT [Uhr]',nextWeek:'dddd [um] LT [Uhr]',lastDay:'[gestern um] LT [Uhr]',lastWeek:'[letzten] dddd [um] LT [Uhr]'},relativeTime:{future:'in %s',past:'vor %s',s:'ein paar Sekunden',ss:'%d Sekunden',m:processRelativeTime$2,mm:'%d Minuten',h:processRelativeTime$2,hh:'%d Stunden',d:processRelativeTime$2,dd:processRelativeTime$2,w:processRelativeTime$2,ww:'%d Wochen',M:processRelativeTime$2,MM:processRelativeTime$2,y:processRelativeTime$2,yy:processRelativeTime$2},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var months$5=<span class="cstat-no" title="statement not covered" >['','','','','','','','','','','',''],</span>weekdays=<span class="cstat-no" title="statement not covered" >['','','','','','',''];<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('dv',{months:months$5,monthsShort:months$5,weekdays:weekdays,weekdaysShort:weekdays,weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'D/M/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},meridiemParse:/|/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return''===input;}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span>,calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'dddd LT',lastDay:'[] LT',lastWeek:'[] dddd LT',sameElse:'L'},relativeTime:{future:' %s',past:' %s',s:'',ss:'d% ',m:'',mm:' %d',h:'',hh:' %d',d:'',dd:' %d',M:'',MM:' %d',y:'',yy:' %d'},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(//g,',');}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/,/g,'');}</span>,week:{dow:7,// Sunday is the first day of the week.</span>
doy:12// The week that contains Jan 12th is the first week of the year.
}});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >isFunction$1(</span>input){<span class="cstat-no" title="statement not covered" >return typeof Function!=='undefined'&amp;&amp;input instanceof Function||Object.prototype.toString.call(input)==='[object Function]';}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('el',{monthsNominativeEl:'___________'.split('_'),monthsGenitiveEl:'___________'.split('_'),months:<span class="fstat-no" title="function not covered" >fu</span>nction(momentToFormat,format){<span class="cstat-no" title="statement not covered" >if(!momentToFormat){<span class="cstat-no" title="statement not covered" >return this._monthsNominativeEl;}</span>else <span class="cstat-no" title="statement not covered" >if(typeof format==='string'&amp;&amp;/D/.test(format.substring(0,format.indexOf('MMMM')))){// if there is a day number before 'MMMM'</span></span></span>
<span class="cstat-no" title="statement not covered" >return this._monthsGenitiveEl[momentToFormat.month()];}</span>else{<span class="cstat-no" title="statement not covered" >return this._monthsNominativeEl[momentToFormat.month()];}</span>},monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hours,minutes,isLower){<span class="cstat-no" title="statement not covered" >if(hours&gt;11){<span class="cstat-no" title="statement not covered" >return isLower?'':'';}</span>else{<span class="cstat-no" title="statement not covered" >return isLower?'':'';}</span>}</span>,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return(input+'').toLowerCase()[0]==='';}</span>,meridiemParse:/[]\.??\.?/i,longDateFormat:{LT:'h:mm A',LTS:'h:mm:ss A',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY h:mm A',LLLL:'dddd, D MMMM YYYY h:mm A'},calendarEl:{sameDay:'[ {}] LT',nextDay:'[ {}] LT',nextWeek:'dddd [{}] LT',lastDay:'[ {}] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 6:<span class="cstat-no" title="statement not covered" >return'[ ] dddd [{}] LT';d</span>efault:<span class="cstat-no" title="statement not covered" >return'[ ] dddd [{}] LT';}</span>}</span>,sameElse:'L'},calendar:<span class="fstat-no" title="function not covered" >fu</span>nction(key,mom){var output=<span class="cstat-no" title="statement not covered" >this._calendarEl[key],</span>hours=<span class="cstat-no" title="statement not covered" >mom&amp;&amp;mom.hours();<span class="cstat-no" title="statement not covered" ></span>if(isFunction$1(output)){<span class="cstat-no" title="statement not covered" >output=output.apply(mom);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn output.replace('{}',hours%12===1?'':'');}</span>,relativeTime:{future:' %s',past:'%s ',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',week:{dow:1,// Monday is the first day of the week.
doy:4// The week that contains Jan 4st is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('en-au',{months:'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),monthsShort:'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),weekdays:'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),weekdaysShort:'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),weekdaysMin:'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),longDateFormat:{LT:'h:mm A',LTS:'h:mm:ss A',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY h:mm A',LLLL:'dddd, D MMMM YYYY h:mm A'},calendar:{sameDay:'[Today at] LT',nextDay:'[Tomorrow at] LT',nextWeek:'dddd [at] LT',lastDay:'[Yesterday at] LT',lastWeek:'[Last] dddd [at] LT',sameElse:'L'},relativeTime:{future:'in %s',past:'%s ago',s:'a few seconds',ss:'%d seconds',m:'a minute',mm:'%d minutes',h:'an hour',hh:'%d hours',d:'a day',dd:'%d days',M:'a month',MM:'%d months',y:'a year',yy:'%d years'},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var b=<span class="cstat-no" title="statement not covered" >number%10,</span>output=<span class="cstat-no" title="statement not covered" >~~(number%100/10)===1?'th':b===1?'st':b===2?'nd':b===3?'rd':'th';<span class="cstat-no" title="statement not covered" ></span>return number+output;}</span>,week:{dow:0,// Sunday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('en-ca',{months:'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),monthsShort:'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),weekdays:'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),weekdaysShort:'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),weekdaysMin:'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),longDateFormat:{LT:'h:mm A',LTS:'h:mm:ss A',L:'YYYY-MM-DD',LL:'MMMM D, YYYY',LLL:'MMMM D, YYYY h:mm A',LLLL:'dddd, MMMM D, YYYY h:mm A'},calendar:{sameDay:'[Today at] LT',nextDay:'[Tomorrow at] LT',nextWeek:'dddd [at] LT',lastDay:'[Yesterday at] LT',lastWeek:'[Last] dddd [at] LT',sameElse:'L'},relativeTime:{future:'in %s',past:'%s ago',s:'a few seconds',ss:'%d seconds',m:'a minute',mm:'%d minutes',h:'an hour',hh:'%d hours',d:'a day',dd:'%d days',M:'a month',MM:'%d months',y:'a year',yy:'%d years'},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var b=<span class="cstat-no" title="statement not covered" >number%10,</span>output=<span class="cstat-no" title="statement not covered" >~~(number%100/10)===1?'th':b===1?'st':b===2?'nd':b===3?'rd':'th';<span class="cstat-no" title="statement not covered" ></span>return number+output;}</span>});/</span>/! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('en-gb',{months:'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),monthsShort:'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),weekdays:'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),weekdaysShort:'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),weekdaysMin:'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[Today at] LT',nextDay:'[Tomorrow at] LT',nextWeek:'dddd [at] LT',lastDay:'[Yesterday at] LT',lastWeek:'[Last] dddd [at] LT',sameElse:'L'},relativeTime:{future:'in %s',past:'%s ago',s:'a few seconds',ss:'%d seconds',m:'a minute',mm:'%d minutes',h:'an hour',hh:'%d hours',d:'a day',dd:'%d days',M:'a month',MM:'%d months',y:'a year',yy:'%d years'},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var b=<span class="cstat-no" title="statement not covered" >number%10,</span>output=<span class="cstat-no" title="statement not covered" >~~(number%100/10)===1?'th':b===1?'st':b===2?'nd':b===3?'rd':'th';<span class="cstat-no" title="statement not covered" ></span>return number+output;}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('en-ie',{months:'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),monthsShort:'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),weekdays:'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),weekdaysShort:'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),weekdaysMin:'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},calendar:{sameDay:'[Today at] LT',nextDay:'[Tomorrow at] LT',nextWeek:'dddd [at] LT',lastDay:'[Yesterday at] LT',lastWeek:'[Last] dddd [at] LT',sameElse:'L'},relativeTime:{future:'in %s',past:'%s ago',s:'a few seconds',ss:'%d seconds',m:'a minute',mm:'%d minutes',h:'an hour',hh:'%d hours',d:'a day',dd:'%d days',M:'a month',MM:'%d months',y:'a year',yy:'%d years'},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var b=<span class="cstat-no" title="statement not covered" >number%10,</span>output=<span class="cstat-no" title="statement not covered" >~~(number%100/10)===1?'th':b===1?'st':b===2?'nd':b===3?'rd':'th';<span class="cstat-no" title="statement not covered" ></span>return number+output;}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('en-il',{months:'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),monthsShort:'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),weekdays:'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),weekdaysShort:'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),weekdaysMin:'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[Today at] LT',nextDay:'[Tomorrow at] LT',nextWeek:'dddd [at] LT',lastDay:'[Yesterday at] LT',lastWeek:'[Last] dddd [at] LT',sameElse:'L'},relativeTime:{future:'in %s',past:'%s ago',s:'a few seconds',ss:'%d seconds',m:'a minute',mm:'%d minutes',h:'an hour',hh:'%d hours',d:'a day',dd:'%d days',M:'a month',MM:'%d months',y:'a year',yy:'%d years'},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var b=<span class="cstat-no" title="statement not covered" >number%10,</span>output=<span class="cstat-no" title="statement not covered" >~~(number%100/10)===1?'th':b===1?'st':b===2?'nd':b===3?'rd':'th';<span class="cstat-no" title="statement not covered" ></span>return number+output;}</span>});/</span>/! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('en-in',{months:'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),monthsShort:'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),weekdays:'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),weekdaysShort:'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),weekdaysMin:'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),longDateFormat:{LT:'h:mm A',LTS:'h:mm:ss A',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY h:mm A',LLLL:'dddd, D MMMM YYYY h:mm A'},calendar:{sameDay:'[Today at] LT',nextDay:'[Tomorrow at] LT',nextWeek:'dddd [at] LT',lastDay:'[Yesterday at] LT',lastWeek:'[Last] dddd [at] LT',sameElse:'L'},relativeTime:{future:'in %s',past:'%s ago',s:'a few seconds',ss:'%d seconds',m:'a minute',mm:'%d minutes',h:'an hour',hh:'%d hours',d:'a day',dd:'%d days',M:'a month',MM:'%d months',y:'a year',yy:'%d years'},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var b=<span class="cstat-no" title="statement not covered" >number%10,</span>output=<span class="cstat-no" title="statement not covered" >~~(number%100/10)===1?'th':b===1?'st':b===2?'nd':b===3?'rd':'th';<span class="cstat-no" title="statement not covered" ></span>return number+output;}</span>,week:{dow:0,// Sunday is the first day of the week.</span>
doy:6// The week that contains Jan 1st is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('en-nz',{months:'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),monthsShort:'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),weekdays:'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),weekdaysShort:'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),weekdaysMin:'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),longDateFormat:{LT:'h:mm A',LTS:'h:mm:ss A',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY h:mm A',LLLL:'dddd, D MMMM YYYY h:mm A'},calendar:{sameDay:'[Today at] LT',nextDay:'[Tomorrow at] LT',nextWeek:'dddd [at] LT',lastDay:'[Yesterday at] LT',lastWeek:'[Last] dddd [at] LT',sameElse:'L'},relativeTime:{future:'in %s',past:'%s ago',s:'a few seconds',ss:'%d seconds',m:'a minute',mm:'%d minutes',h:'an hour',hh:'%d hours',d:'a day',dd:'%d days',M:'a month',MM:'%d months',y:'a year',yy:'%d years'},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var b=<span class="cstat-no" title="statement not covered" >number%10,</span>output=<span class="cstat-no" title="statement not covered" >~~(number%100/10)===1?'th':b===1?'st':b===2?'nd':b===3?'rd':'th';<span class="cstat-no" title="statement not covered" ></span>return number+output;}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('en-sg',{months:'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),monthsShort:'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),weekdays:'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),weekdaysShort:'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),weekdaysMin:'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[Today at] LT',nextDay:'[Tomorrow at] LT',nextWeek:'dddd [at] LT',lastDay:'[Yesterday at] LT',lastWeek:'[Last] dddd [at] LT',sameElse:'L'},relativeTime:{future:'in %s',past:'%s ago',s:'a few seconds',ss:'%d seconds',m:'a minute',mm:'%d minutes',h:'an hour',hh:'%d hours',d:'a day',dd:'%d days',M:'a month',MM:'%d months',y:'a year',yy:'%d years'},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var b=<span class="cstat-no" title="statement not covered" >number%10,</span>output=<span class="cstat-no" title="statement not covered" >~~(number%100/10)===1?'th':b===1?'st':b===2?'nd':b===3?'rd':'th';<span class="cstat-no" title="statement not covered" ></span>return number+output;}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('eo',{months:'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),monthsShort:'jan_feb_mart_apr_maj_jun_jul_ag_sept_okt_nov_dec'.split('_'),weekdays:'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),weekdaysShort:'dim_lun_mard_merk_a_ven_sab'.split('_'),weekdaysMin:'di_lu_ma_me_a_ve_sa'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'YYYY-MM-DD',LL:'[la] D[-an de] MMMM, YYYY',LLL:'[la] D[-an de] MMMM, YYYY HH:mm',LLLL:'dddd[n], [la] D[-an de] MMMM, YYYY HH:mm',llll:'ddd, [la] D[-an de] MMM, YYYY HH:mm'},meridiemParse:/[ap]\.t\.m/i,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return input.charAt(0).toLowerCase()==='p';}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hours,minutes,isLower){<span class="cstat-no" title="statement not covered" >if(hours&gt;11){<span class="cstat-no" title="statement not covered" >return isLower?'p.t.m.':'P.T.M.';}</span>else{<span class="cstat-no" title="statement not covered" >return isLower?'a.t.m.':'A.T.M.';}</span>}</span>,calendar:{sameDay:'[Hodia je] LT',nextDay:'[Morga je] LT',nextWeek:'dddd[n je] LT',lastDay:'[Hiera je] LT',lastWeek:'[pasintan] dddd[n je] LT',sameElse:'L'},relativeTime:{future:'post %s',past:'anta %s',s:'kelkaj sekundoj',ss:'%d sekundoj',m:'unu minuto',mm:'%d minutoj',h:'unu horo',hh:'%d horoj',d:'unu tago',//ne 'diurno', ar estas uzita por proksimumo</span>
dd:'%d tagoj',M:'unu monato',MM:'%d monatoj',y:'unu jaro',yy:'%d jaroj'},dayOfMonthOrdinalParse:/\d{1,2}a/,ordinal:'%da',week:{dow:1,// Monday is the first day of the week.
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
var monthsShortDot=<span class="cstat-no" title="statement not covered" >'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),</span>monthsShort$1=<span class="cstat-no" title="statement not covered" >'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),</span>monthsParse$2=<span class="cstat-no" title="statement not covered" >[/^ene/i,/^feb/i,/^mar/i,/^abr/i,/^may/i,/^jun/i,/^jul/i,/^ago/i,/^sep/i,/^oct/i,/^nov/i,/^dic/i],</span>monthsRegex$3=<span class="cstat-no" title="statement not covered" >/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('es-do',{months:'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),monthsShort:<span class="fstat-no" title="function not covered" >fu</span>nction(m,format){<span class="cstat-no" title="statement not covered" >if(!m){<span class="cstat-no" title="statement not covered" >return monthsShortDot;}</span>else <span class="cstat-no" title="statement not covered" >if(/-MMM-/.test(format)){<span class="cstat-no" title="statement not covered" >return monthsShort$1[m.month()];}</span>else{<span class="cstat-no" title="statement not covered" >return monthsShortDot[m.month()];}</span>}</span></span>,monthsRegex:monthsRegex$3,monthsShortRegex:monthsRegex$3,monthsStrictRegex:/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,monthsShortStrictRegex:/^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,monthsParse:monthsParse$2,longMonthsParse:monthsParse$2,shortMonthsParse:monthsParse$2,weekdays:'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),weekdaysShort:'dom._lun._mar._mi._jue._vie._sb.'.split('_'),weekdaysMin:'do_lu_ma_mi_ju_vi_s'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'h:mm A',LTS:'h:mm:ss A',L:'DD/MM/YYYY',LL:'D [de] MMMM [de] YYYY',LLL:'D [de] MMMM [de] YYYY h:mm A',LLLL:'dddd, D [de] MMMM [de] YYYY h:mm A'},calendar:{sameDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[hoy a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,nextDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[maana a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'dddd [a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,lastDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[ayer a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[el] dddd [pasado a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,sameElse:'L'},relativeTime:{future:'en %s',past:'hace %s',s:'unos segundos',ss:'%d segundos',m:'un minuto',mm:'%d minutos',h:'una hora',hh:'%d horas',d:'un da',dd:'%d das',w:'una semana',ww:'%d semanas',M:'un mes',MM:'%d meses',y:'un ao',yy:'%d aos'},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var monthsShortDot$1=<span class="cstat-no" title="statement not covered" >'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),</span>monthsShort$2=<span class="cstat-no" title="statement not covered" >'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),</span>monthsParse$3=<span class="cstat-no" title="statement not covered" >[/^ene/i,/^feb/i,/^mar/i,/^abr/i,/^may/i,/^jun/i,/^jul/i,/^ago/i,/^sep/i,/^oct/i,/^nov/i,/^dic/i],</span>monthsRegex$4=<span class="cstat-no" title="statement not covered" >/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('es-mx',{months:'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),monthsShort:<span class="fstat-no" title="function not covered" >fu</span>nction(m,format){<span class="cstat-no" title="statement not covered" >if(!m){<span class="cstat-no" title="statement not covered" >return monthsShortDot$1;}</span>else <span class="cstat-no" title="statement not covered" >if(/-MMM-/.test(format)){<span class="cstat-no" title="statement not covered" >return monthsShort$2[m.month()];}</span>else{<span class="cstat-no" title="statement not covered" >return monthsShortDot$1[m.month()];}</span>}</span></span>,monthsRegex:monthsRegex$4,monthsShortRegex:monthsRegex$4,monthsStrictRegex:/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,monthsShortStrictRegex:/^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,monthsParse:monthsParse$3,longMonthsParse:monthsParse$3,shortMonthsParse:monthsParse$3,weekdays:'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),weekdaysShort:'dom._lun._mar._mi._jue._vie._sb.'.split('_'),weekdaysMin:'do_lu_ma_mi_ju_vi_s'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD/MM/YYYY',LL:'D [de] MMMM [de] YYYY',LLL:'D [de] MMMM [de] YYYY H:mm',LLLL:'dddd, D [de] MMMM [de] YYYY H:mm'},calendar:{sameDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[hoy a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,nextDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[maana a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'dddd [a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,lastDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[ayer a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[el] dddd [pasado a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,sameElse:'L'},relativeTime:{future:'en %s',past:'hace %s',s:'unos segundos',ss:'%d segundos',m:'un minuto',mm:'%d minutos',h:'una hora',hh:'%d horas',d:'un da',dd:'%d das',w:'una semana',ww:'%d semanas',M:'un mes',MM:'%d meses',y:'un ao',yy:'%d aos'},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',week:{dow:0,// Sunday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
},invalidDate:'Fecha invlida'});//! moment.js locale configuration
var monthsShortDot$2=<span class="cstat-no" title="statement not covered" >'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),</span>monthsShort$3=<span class="cstat-no" title="statement not covered" >'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),</span>monthsParse$4=<span class="cstat-no" title="statement not covered" >[/^ene/i,/^feb/i,/^mar/i,/^abr/i,/^may/i,/^jun/i,/^jul/i,/^ago/i,/^sep/i,/^oct/i,/^nov/i,/^dic/i],</span>monthsRegex$5=<span class="cstat-no" title="statement not covered" >/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('es-us',{months:'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),monthsShort:<span class="fstat-no" title="function not covered" >fu</span>nction(m,format){<span class="cstat-no" title="statement not covered" >if(!m){<span class="cstat-no" title="statement not covered" >return monthsShortDot$2;}</span>else <span class="cstat-no" title="statement not covered" >if(/-MMM-/.test(format)){<span class="cstat-no" title="statement not covered" >return monthsShort$3[m.month()];}</span>else{<span class="cstat-no" title="statement not covered" >return monthsShortDot$2[m.month()];}</span>}</span></span>,monthsRegex:monthsRegex$5,monthsShortRegex:monthsRegex$5,monthsStrictRegex:/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,monthsShortStrictRegex:/^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,monthsParse:monthsParse$4,longMonthsParse:monthsParse$4,shortMonthsParse:monthsParse$4,weekdays:'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),weekdaysShort:'dom._lun._mar._mi._jue._vie._sb.'.split('_'),weekdaysMin:'do_lu_ma_mi_ju_vi_s'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'h:mm A',LTS:'h:mm:ss A',L:'MM/DD/YYYY',LL:'D [de] MMMM [de] YYYY',LLL:'D [de] MMMM [de] YYYY h:mm A',LLLL:'dddd, D [de] MMMM [de] YYYY h:mm A'},calendar:{sameDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[hoy a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,nextDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[maana a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'dddd [a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,lastDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[ayer a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[el] dddd [pasado a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,sameElse:'L'},relativeTime:{future:'en %s',past:'hace %s',s:'unos segundos',ss:'%d segundos',m:'un minuto',mm:'%d minutos',h:'una hora',hh:'%d horas',d:'un da',dd:'%d das',w:'una semana',ww:'%d semanas',M:'un mes',MM:'%d meses',y:'un ao',yy:'%d aos'},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',week:{dow:0,// Sunday is the first day of the week.</span>
doy:6// The week that contains Jan 6th is the first week of the year.
}});//! moment.js locale configuration
var monthsShortDot$3=<span class="cstat-no" title="statement not covered" >'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),</span>monthsShort$4=<span class="cstat-no" title="statement not covered" >'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),</span>monthsParse$5=<span class="cstat-no" title="statement not covered" >[/^ene/i,/^feb/i,/^mar/i,/^abr/i,/^may/i,/^jun/i,/^jul/i,/^ago/i,/^sep/i,/^oct/i,/^nov/i,/^dic/i],</span>monthsRegex$6=<span class="cstat-no" title="statement not covered" >/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('es',{months:'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),monthsShort:<span class="fstat-no" title="function not covered" >fu</span>nction(m,format){<span class="cstat-no" title="statement not covered" >if(!m){<span class="cstat-no" title="statement not covered" >return monthsShortDot$3;}</span>else <span class="cstat-no" title="statement not covered" >if(/-MMM-/.test(format)){<span class="cstat-no" title="statement not covered" >return monthsShort$4[m.month()];}</span>else{<span class="cstat-no" title="statement not covered" >return monthsShortDot$3[m.month()];}</span>}</span></span>,monthsRegex:monthsRegex$6,monthsShortRegex:monthsRegex$6,monthsStrictRegex:/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,monthsShortStrictRegex:/^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,monthsParse:monthsParse$5,longMonthsParse:monthsParse$5,shortMonthsParse:monthsParse$5,weekdays:'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),weekdaysShort:'dom._lun._mar._mi._jue._vie._sb.'.split('_'),weekdaysMin:'do_lu_ma_mi_ju_vi_s'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD/MM/YYYY',LL:'D [de] MMMM [de] YYYY',LLL:'D [de] MMMM [de] YYYY H:mm',LLLL:'dddd, D [de] MMMM [de] YYYY H:mm'},calendar:{sameDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[hoy a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,nextDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[maana a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'dddd [a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,lastDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[ayer a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[el] dddd [pasado a la'+(this.hours()!==1?'s':'')+'] LT';}</span>,sameElse:'L'},relativeTime:{future:'en %s',past:'hace %s',s:'unos segundos',ss:'%d segundos',m:'un minuto',mm:'%d minutos',h:'una hora',hh:'%d horas',d:'un da',dd:'%d das',w:'una semana',ww:'%d semanas',M:'un mes',MM:'%d meses',y:'un ao',yy:'%d aos'},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
},invalidDate:'Fecha invlida'});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >processRelativeTime$3(</span>number,withoutSuffix,key,isFuture){var format=<span class="cstat-no" title="statement not covered" >{s:['mne sekundi','mni sekund','paar sekundit'],ss:[number+'sekundi',number+'sekundit'],m:['he minuti','ks minut'],mm:[number+' minuti',number+' minutit'],h:['he tunni','tund aega','ks tund'],hh:[number+' tunni',number+' tundi'],d:['he peva','ks pev'],M:['kuu aja','kuu aega','ks kuu'],MM:[number+' kuu',number+' kuud'],y:['he aasta','aasta','ks aasta'],yy:[number+' aasta',number+' aastat']};<span class="cstat-no" title="statement not covered" ></span>if(withoutSuffix){<span class="cstat-no" title="statement not covered" >return format[key][2]?format[key][2]:format[key][1];}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn isFuture?format[key][0]:format[key][1];}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('et',{months:'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),monthsShort:'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),weekdays:'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),weekdaysShort:'P_E_T_K_N_R_L'.split('_'),weekdaysMin:'P_E_T_K_N_R_L'.split('_'),longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD.MM.YYYY',LL:'D. MMMM YYYY',LLL:'D. MMMM YYYY H:mm',LLLL:'dddd, D. MMMM YYYY H:mm'},calendar:{sameDay:'[Tna,] LT',nextDay:'[Homme,] LT',nextWeek:'[Jrgmine] dddd LT',lastDay:'[Eile,] LT',lastWeek:'[Eelmine] dddd LT',sameElse:'L'},relativeTime:{future:'%s prast',past:'%s tagasi',s:processRelativeTime$3,ss:processRelativeTime$3,m:processRelativeTime$3,mm:processRelativeTime$3,h:processRelativeTime$3,hh:processRelativeTime$3,d:processRelativeTime$3,dd:'%d peva',M:processRelativeTime$3,MM:processRelativeTime$3,y:processRelativeTime$3,yy:processRelativeTime$3},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('eu',{months:'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),monthsShort:'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),monthsParseExact:true,weekdays:'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),weekdaysShort:'ig._al._ar._az._og._ol._lr.'.split('_'),weekdaysMin:'ig_al_ar_az_og_ol_lr'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'YYYY-MM-DD',LL:'YYYY[ko] MMMM[ren] D[a]',LLL:'YYYY[ko] MMMM[ren] D[a] HH:mm',LLLL:'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',l:'YYYY-M-D',ll:'YYYY[ko] MMM D[a]',lll:'YYYY[ko] MMM D[a] HH:mm',llll:'ddd, YYYY[ko] MMM D[a] HH:mm'},calendar:{sameDay:'[gaur] LT[etan]',nextDay:'[bihar] LT[etan]',nextWeek:'dddd LT[etan]',lastDay:'[atzo] LT[etan]',lastWeek:'[aurreko] dddd LT[etan]',sameElse:'L'},relativeTime:{future:'%s barru',past:'duela %s',s:'segundo batzuk',ss:'%d segundo',m:'minutu bat',mm:'%d minutu',h:'ordu bat',hh:'%d ordu',d:'egun bat',dd:'%d egun',M:'hilabete bat',MM:'%d hilabete',y:'urte bat',yy:'%d urte'},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
var symbolMap$6=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap$5=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('fa',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'\u200c__\u200c__\u200c__'.split('_'),weekdaysShort:'\u200c__\u200c__\u200c__'.split('_'),weekdaysMin:'______'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},meridiemParse:/  |  /,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return /  /.test(input);}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'  ';}</span>else{<span class="cstat-no" title="statement not covered" >return'  ';}</span>}</span>,calendar:{sameDay:'[ ] LT',nextDay:'[ ] LT',nextWeek:'dddd [] LT',lastDay:'[ ] LT',lastWeek:'dddd [] [] LT',sameElse:'L'},relativeTime:{future:' %s',past:'%s ',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[-]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap$5[match];}</span>).replace(//g,',');}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$6[match];}</span>).replace(/,/g,'');}</span>,dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',week:{dow:6,// Saturday is the first day of the week.</span>
doy:12// The week that contains Jan 12th is the first week of the year.
}});//! moment.js locale configuration
var numbersPast=<span class="cstat-no" title="statement not covered" >'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),</span>numbersFuture=<span class="cstat-no" title="statement not covered" >['nolla','yhden','kahden','kolmen','neljn','viiden','kuuden',numbersPast[7],numbersPast[8],numbersPast[9]];</span>function <span class="fstat-no" title="function not covered" >translate$2(</span>number,withoutSuffix,key,isFuture){var result=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>switch(key){case's':<span class="cstat-no" title="statement not covered" >return isFuture?'muutaman sekunnin':'muutama sekunti';c</span>ase'ss':<span class="cstat-no" title="statement not covered" >result=isFuture?'sekunnin':'sekuntia';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'm':<span class="cstat-no" title="statement not covered" >return isFuture?'minuutin':'minuutti';c</span>ase'mm':<span class="cstat-no" title="statement not covered" >result=isFuture?'minuutin':'minuuttia';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'h':<span class="cstat-no" title="statement not covered" >return isFuture?'tunnin':'tunti';c</span>ase'hh':<span class="cstat-no" title="statement not covered" >result=isFuture?'tunnin':'tuntia';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'd':<span class="cstat-no" title="statement not covered" >return isFuture?'pivn':'piv';c</span>ase'dd':<span class="cstat-no" title="statement not covered" >result=isFuture?'pivn':'piv';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'M':<span class="cstat-no" title="statement not covered" >return isFuture?'kuukauden':'kuukausi';c</span>ase'MM':<span class="cstat-no" title="statement not covered" >result=isFuture?'kuukauden':'kuukautta';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'y':<span class="cstat-no" title="statement not covered" >return isFuture?'vuoden':'vuosi';c</span>ase'yy':<span class="cstat-no" title="statement not covered" >result=isFuture?'vuoden':'vuotta';<span class="cstat-no" title="statement not covered" >b</span>reak;}<span class="cstat-no" title="statement not covered" ></span>r</span>esult=verbalNumber(number,isFuture)+' '+result;<span class="cstat-no" title="statement not covered" >r</span>eturn result;}</span>function <span class="fstat-no" title="function not covered" >verbalNumber(</span>number,isFuture){<span class="cstat-no" title="statement not covered" >return number&lt;10?isFuture?numbersFuture[number]:numbersPast[number]:number;}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('fi',{months:'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),monthsShort:'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),weekdays:'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),weekdaysShort:'su_ma_ti_ke_to_pe_la'.split('_'),weekdaysMin:'su_ma_ti_ke_to_pe_la'.split('_'),longDateFormat:{LT:'HH.mm',LTS:'HH.mm.ss',L:'DD.MM.YYYY',LL:'Do MMMM[ta] YYYY',LLL:'Do MMMM[ta] YYYY, [klo] HH.mm',LLLL:'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',l:'D.M.YYYY',ll:'Do MMM YYYY',lll:'Do MMM YYYY, [klo] HH.mm',llll:'ddd, Do MMM YYYY, [klo] HH.mm'},calendar:{sameDay:'[tnn] [klo] LT',nextDay:'[huomenna] [klo] LT',nextWeek:'dddd [klo] LT',lastDay:'[eilen] [klo] LT',lastWeek:'[viime] dddd[na] [klo] LT',sameElse:'L'},relativeTime:{future:'%s pst',past:'%s sitten',s:translate$2,ss:translate$2,m:translate$2,mm:translate$2,h:translate$2,hh:translate$2,d:translate$2,dd:translate$2,M:translate$2,MM:translate$2,y:translate$2,yy:translate$2},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('fil',{months:'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),monthsShort:'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),weekdays:'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),weekdaysShort:'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),weekdaysMin:'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'MM/D/YYYY',LL:'MMMM D, YYYY',LLL:'MMMM D, YYYY HH:mm',LLLL:'dddd, MMMM DD, YYYY HH:mm'},calendar:{sameDay:'LT [ngayong araw]',nextDay:'[Bukas ng] LT',nextWeek:'LT [sa susunod na] dddd',lastDay:'LT [kahapon]',lastWeek:'LT [noong nakaraang] dddd',sameElse:'L'},relativeTime:{future:'sa loob ng %s',past:'%s ang nakalipas',s:'ilang segundo',ss:'%d segundo',m:'isang minuto',mm:'%d minuto',h:'isang oras',hh:'%d oras',d:'isang araw',dd:'%d araw',M:'isang buwan',MM:'%d buwan',y:'isang taon',yy:'%d taon'},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >return number;}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('fo',{months:'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),monthsShort:'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),weekdays:'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),weekdaysShort:'sun_mn_ts_mik_hs_fr_ley'.split('_'),weekdaysMin:'su_m_t_mi_h_fr_le'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D. MMMM, YYYY HH:mm'},calendar:{sameDay:'[ dag kl.] LT',nextDay:'[ morgin kl.] LT',nextWeek:'dddd [kl.] LT',lastDay:'[ gjr kl.] LT',lastWeek:'[sstu] dddd [kl] LT',sameElse:'L'},relativeTime:{future:'um %s',past:'%s sani',s:'f sekund',ss:'%d sekundir',m:'ein minuttur',mm:'%d minuttir',h:'ein tmi',hh:'%d tmar',d:'ein dagur',dd:'%d dagar',M:'ein mnaur',MM:'%d mnair',y:'eitt r',yy:'%d r'},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('fr-ca',{months:'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),monthsShort:'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),monthsParseExact:true,weekdays:'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),weekdaysShort:'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),weekdaysMin:'di_lu_ma_me_je_ve_sa'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'YYYY-MM-DD',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},calendar:{sameDay:'[Aujourdhui ] LT',nextDay:'[Demain ] LT',nextWeek:'dddd [] LT',lastDay:'[Hier ] LT',lastWeek:'dddd [dernier ] LT',sameElse:'L'},relativeTime:{future:'dans %s',past:'il y a %s',s:'quelques secondes',ss:'%d secondes',m:'une minute',mm:'%d minutes',h:'une heure',hh:'%d heures',d:'un jour',dd:'%d jours',M:'un mois',MM:'%d mois',y:'un an',yy:'%d ans'},dayOfMonthOrdinalParse:/\d{1,2}(er|e)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){// Words with masculine grammatical gender: mois, trimestre, jour</span></span>
default:case'M':case'Q':case'D':case'DDD':case'd':<span class="cstat-no" title="statement not covered" >return number+(number===1?'er':'e');/</span>/ Words with feminine grammatical gender: semaine
case'w':case'W':<span class="cstat-no" title="statement not covered" >return number+(number===1?'re':'e');}</span>}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('fr-ch',{months:'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),monthsShort:'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),monthsParseExact:true,weekdays:'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),weekdaysShort:'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),weekdaysMin:'di_lu_ma_me_je_ve_sa'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},calendar:{sameDay:'[Aujourdhui ] LT',nextDay:'[Demain ] LT',nextWeek:'dddd [] LT',lastDay:'[Hier ] LT',lastWeek:'dddd [dernier ] LT',sameElse:'L'},relativeTime:{future:'dans %s',past:'il y a %s',s:'quelques secondes',ss:'%d secondes',m:'une minute',mm:'%d minutes',h:'une heure',hh:'%d heures',d:'un jour',dd:'%d jours',M:'un mois',MM:'%d mois',y:'un an',yy:'%d ans'},dayOfMonthOrdinalParse:/\d{1,2}(er|e)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){// Words with masculine grammatical gender: mois, trimestre, jour</span></span>
default:case'M':case'Q':case'D':case'DDD':case'd':<span class="cstat-no" title="statement not covered" >return number+(number===1?'er':'e');/</span>/ Words with feminine grammatical gender: semaine
case'w':case'W':<span class="cstat-no" title="statement not covered" >return number+(number===1?'re':'e');}</span>},week:{dow:1,// Monday is the first day of the week.
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var monthsStrictRegex$1=<span class="cstat-no" title="statement not covered" >/^(janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i,</span>monthsShortStrictRegex$1=<span class="cstat-no" title="statement not covered" >/(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?)/i,</span>monthsRegex$7=<span class="cstat-no" title="statement not covered" >/(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?|janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i,</span>monthsParse$6=<span class="cstat-no" title="statement not covered" >[/^janv/i,/^fvr/i,/^mars/i,/^avr/i,/^mai/i,/^juin/i,/^juil/i,/^aot/i,/^sept/i,/^oct/i,/^nov/i,/^dc/i];<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('fr',{months:'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),monthsShort:'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),monthsRegex:monthsRegex$7,monthsShortRegex:monthsRegex$7,monthsStrictRegex:monthsStrictRegex$1,monthsShortStrictRegex:monthsShortStrictRegex$1,monthsParse:monthsParse$6,longMonthsParse:monthsParse$6,shortMonthsParse:monthsParse$6,weekdays:'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),weekdaysShort:'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),weekdaysMin:'di_lu_ma_me_je_ve_sa'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},calendar:{sameDay:'[Aujourdhui ] LT',nextDay:'[Demain ] LT',nextWeek:'dddd [] LT',lastDay:'[Hier ] LT',lastWeek:'dddd [dernier ] LT',sameElse:'L'},relativeTime:{future:'dans %s',past:'il y a %s',s:'quelques secondes',ss:'%d secondes',m:'une minute',mm:'%d minutes',h:'une heure',hh:'%d heures',d:'un jour',dd:'%d jours',w:'une semaine',ww:'%d semaines',M:'un mois',MM:'%d mois',y:'un an',yy:'%d ans'},dayOfMonthOrdinalParse:/\d{1,2}(er|)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){// TODO: Return 'e' when day of month &gt; 1. Move this case inside</span></span>
// block for masculine words below.
// See https://github.com/moment/moment/issues/3375
case'D':<span class="cstat-no" title="statement not covered" >return number+(number===1?'er':'');/</span>/ Words with masculine grammatical gender: mois, trimestre, jour
default:case'M':case'Q':case'DDD':case'd':<span class="cstat-no" title="statement not covered" >return number+(number===1?'er':'e');/</span>/ Words with feminine grammatical gender: semaine
case'w':case'W':<span class="cstat-no" title="statement not covered" >return number+(number===1?'re':'e');}</span>},week:{dow:1,// Monday is the first day of the week.
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var monthsShortWithDots=<span class="cstat-no" title="statement not covered" >'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),</span>monthsShortWithoutDots=<span class="cstat-no" title="statement not covered" >'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('fy',{months:'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),monthsShort:<span class="fstat-no" title="function not covered" >fu</span>nction(m,format){<span class="cstat-no" title="statement not covered" >if(!m){<span class="cstat-no" title="statement not covered" >return monthsShortWithDots;}</span>else <span class="cstat-no" title="statement not covered" >if(/-MMM-/.test(format)){<span class="cstat-no" title="statement not covered" >return monthsShortWithoutDots[m.month()];}</span>else{<span class="cstat-no" title="statement not covered" >return monthsShortWithDots[m.month()];}</span>}</span></span>,monthsParseExact:true,weekdays:'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),weekdaysShort:'si._mo._ti._wo._to._fr._so.'.split('_'),weekdaysMin:'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD-MM-YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},calendar:{sameDay:'[hjoed om] LT',nextDay:'[moarn om] LT',nextWeek:'dddd [om] LT',lastDay:'[juster om] LT',lastWeek:'[frne] dddd [om] LT',sameElse:'L'},relativeTime:{future:'oer %s',past:'%s lyn',s:'in pear sekonden',ss:'%d sekonden',m:'ien mint',mm:'%d minuten',h:'ien oere',hh:'%d oeren',d:'ien dei',dd:'%d dagen',M:'ien moanne',MM:'%d moannen',y:'ien jier',yy:'%d jierren'},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >return number+(number===1||number===8||number&gt;=20?'ste':'de');}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var months$6=<span class="cstat-no" title="statement not covered" >['Eanir','Feabhra','Mrta','Aibren','Bealtaine','Meitheamh','Iil','Lnasa','Men Fmhair','Deireadh Fmhair','Samhain','Nollaig'],</span>monthsShort$5=<span class="cstat-no" title="statement not covered" >['Ean','Feabh','Mrt','Aib','Beal','Meith','Iil','Ln','M.F.','D.F.','Samh','Noll'],</span>weekdays$1=<span class="cstat-no" title="statement not covered" >['D Domhnaigh','D Luain','D Mirt','D Cadaoin','Dardaoin','D hAoine','D Sathairn'],</span>weekdaysShort=<span class="cstat-no" title="statement not covered" >['Domh','Luan','Mirt','Cad','Dar','Aoine','Sath'],</span>weekdaysMin=<span class="cstat-no" title="statement not covered" >['Do','Lu','M','C','D','A','Sa'];<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('ga',{months:months$6,monthsShort:monthsShort$5,monthsParseExact:true,weekdays:weekdays$1,weekdaysShort:weekdaysShort,weekdaysMin:weekdaysMin,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[Inniu ag] LT',nextDay:'[Amrach ag] LT',nextWeek:'dddd [ag] LT',lastDay:'[Inn ag] LT',lastWeek:'dddd [seo caite] [ag] LT',sameElse:'L'},relativeTime:{future:'i %s',past:'%s  shin',s:'cpla soicind',ss:'%d soicind',m:'nimad',mm:'%d nimad',h:'uair an chloig',hh:'%d uair an chloig',d:'l',dd:'%d l',M:'m',MM:'%d monna',y:'bliain',yy:'%d bliain'},dayOfMonthOrdinalParse:/\d{1,2}(d|na|mh)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var output=<span class="cstat-no" title="statement not covered" >number===1?'d':number%10===2?'na':'mh';<span class="cstat-no" title="statement not covered" ></span>return number+output;}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var months$7=<span class="cstat-no" title="statement not covered" >['Am Faoilleach','An Gearran','Am Mrt','An Giblean','An Citean','An t-gmhios','An t-Iuchar','An Lnastal','An t-Sultain','An Dmhair','An t-Samhain','An Dbhlachd'],</span>monthsShort$6=<span class="cstat-no" title="statement not covered" >['Faoi','Gear','Mrt','Gibl','Cit','gmh','Iuch','Ln','Sult','Dmh','Samh','Dbh'],</span>weekdays$2=<span class="cstat-no" title="statement not covered" >['Didmhnaich','Diluain','Dimirt','Diciadain','Diardaoin','Dihaoine','Disathairne'],</span>weekdaysShort$1=<span class="cstat-no" title="statement not covered" >['Did','Dil','Dim','Dic','Dia','Dih','Dis'],</span>weekdaysMin$1=<span class="cstat-no" title="statement not covered" >['D','Lu','M','Ci','Ar','Ha','Sa'];<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('gd',{months:months$7,monthsShort:monthsShort$6,monthsParseExact:true,weekdays:weekdays$2,weekdaysShort:weekdaysShort$1,weekdaysMin:weekdaysMin$1,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[An-diugh aig] LT',nextDay:'[A-mireach aig] LT',nextWeek:'dddd [aig] LT',lastDay:'[An-d aig] LT',lastWeek:'dddd [seo chaidh] [aig] LT',sameElse:'L'},relativeTime:{future:'ann an %s',past:'bho chionn %s',s:'beagan diogan',ss:'%d diogan',m:'mionaid',mm:'%d mionaidean',h:'uair',hh:'%d uairean',d:'latha',dd:'%d latha',M:'mos',MM:'%d mosan',y:'bliadhna',yy:'%d bliadhna'},dayOfMonthOrdinalParse:/\d{1,2}(d|na|mh)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var output=<span class="cstat-no" title="statement not covered" >number===1?'d':number%10===2?'na':'mh';<span class="cstat-no" title="statement not covered" ></span>return number+output;}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('gl',{months:'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),monthsShort:'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),monthsParseExact:true,weekdays:'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),weekdaysShort:'dom._lun._mar._mr._xov._ven._sb.'.split('_'),weekdaysMin:'do_lu_ma_m_xo_ve_s'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD/MM/YYYY',LL:'D [de] MMMM [de] YYYY',LLL:'D [de] MMMM [de] YYYY H:mm',LLLL:'dddd, D [de] MMMM [de] YYYY H:mm'},calendar:{sameDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[hoxe '+(this.hours()!==1?'s':'')+'] LT';}</span>,nextDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[ma '+(this.hours()!==1?'s':'')+'] LT';}</span>,nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'dddd ['+(this.hours()!==1?'s':'a')+'] LT';}</span>,lastDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[onte '+(this.hours()!==1?'':'a')+'] LT';}</span>,lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[o] dddd [pasado '+(this.hours()!==1?'s':'a')+'] LT';}</span>,sameElse:'L'},relativeTime:{future:<span class="fstat-no" title="function not covered" >fu</span>nction(str){<span class="cstat-no" title="statement not covered" >if(str.indexOf('un')===0){<span class="cstat-no" title="statement not covered" >return'n'+str;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn'en '+str;}</span>,past:'hai %s',s:'uns segundos',ss:'%d segundos',m:'un minuto',mm:'%d minutos',h:'unha hora',hh:'%d horas',d:'un da',dd:'%d das',M:'un mes',MM:'%d meses',y:'un ano',yy:'%d anos'},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >processRelativeTime$4(</span>number,withoutSuffix,key,isFuture){var format=<span class="cstat-no" title="statement not covered" >{s:[' ',' '],ss:[number+' ',number+' '],m:[' ',' '],mm:[number+' ',number+' '],h:[' ',' '],hh:[number+' ',number+' '],d:[' ',' '],dd:[number+' ',number+' '],M:[' ',' '],MM:[number+' ',number+' '],y:[' ',' '],yy:[number+' ',number+' ']};<span class="cstat-no" title="statement not covered" ></span>return isFuture?format[key][0]:format[key][1];}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('gom-deva',{months:{standalone:'___________'.split('_'),format:'___________'.split('_'),isFormat:/MMMM(\s)+D[oD]?/},monthsShort:'._.__.___._._._._._.'.split('_'),monthsParseExact:true,weekdays:'______'.split('_'),weekdaysShort:'._._._._._._.'.split('_'),weekdaysMin:'______'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'A h:mm []',LTS:'A h:mm:ss []',L:'DD-MM-YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY A h:mm []',LLLL:'dddd, MMMM Do, YYYY, A h:mm []',llll:'ddd, D MMM YYYY, A h:mm []'},calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'[] dddd[,] LT',lastDay:'[] LT',lastWeek:'[] dddd[,] LT',sameElse:'L'},relativeTime:{future:'%s',past:'%s ',s:processRelativeTime$4,ss:processRelativeTime$4,m:processRelativeTime$4,mm:processRelativeTime$4,h:processRelativeTime$4,hh:processRelativeTime$4,d:processRelativeTime$4,dd:processRelativeTime$4,M:processRelativeTime$4,MM:processRelativeTime$4,y:processRelativeTime$4,yy:processRelativeTime$4},dayOfMonthOrdinalParse:/\d{1,2}()/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){// the ordinal '' only applies to day of the month</span></span>
case'D':<span class="cstat-no" title="statement not covered" >return number+'';d</span>efault:case'M':case'Q':case'DDD':case'd':case'w':case'W':<span class="cstat-no" title="statement not covered" >return number;}</span>},week:{dow:0,// Sunday is the first day of the week
doy:3// The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
},meridiemParse:/|||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&lt;4?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&gt;12?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;16){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;20){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span>});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >processRelativeTime$5(</span>number,withoutSuffix,key,isFuture){var format=<span class="cstat-no" title="statement not covered" >{s:['thoddea sekondamni','thodde sekond'],ss:[number+' sekondamni',number+' sekond'],m:['eka mintan','ek minut'],mm:[number+' mintamni',number+' mintam'],h:['eka voran','ek vor'],hh:[number+' voramni',number+' voram'],d:['eka disan','ek dis'],dd:[number+' disamni',number+' dis'],M:['eka mhoinean','ek mhoino'],MM:[number+' mhoineamni',number+' mhoine'],y:['eka vorsan','ek voros'],yy:[number+' vorsamni',number+' vorsam']};<span class="cstat-no" title="statement not covered" ></span>return isFuture?format[key][0]:format[key][1];}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('gom-latn',{months:{standalone:'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),format:'Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea'.split('_'),isFormat:/MMMM(\s)+D[oD]?/},monthsShort:'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),monthsParseExact:true,weekdays:"Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split('_'),weekdaysShort:'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),weekdaysMin:'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'A h:mm [vazta]',LTS:'A h:mm:ss [vazta]',L:'DD-MM-YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY A h:mm [vazta]',LLLL:'dddd, MMMM Do, YYYY, A h:mm [vazta]',llll:'ddd, D MMM YYYY, A h:mm [vazta]'},calendar:{sameDay:'[Aiz] LT',nextDay:'[Faleam] LT',nextWeek:'[Fuddlo] dddd[,] LT',lastDay:'[Kal] LT',lastWeek:'[Fattlo] dddd[,] LT',sameElse:'L'},relativeTime:{future:'%s',past:'%s adim',s:processRelativeTime$5,ss:processRelativeTime$5,m:processRelativeTime$5,mm:processRelativeTime$5,h:processRelativeTime$5,hh:processRelativeTime$5,d:processRelativeTime$5,dd:processRelativeTime$5,M:processRelativeTime$5,MM:processRelativeTime$5,y:processRelativeTime$5,yy:processRelativeTime$5},dayOfMonthOrdinalParse:/\d{1,2}(er)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){// the ordinal 'er' only applies to day of the month</span></span>
case'D':<span class="cstat-no" title="statement not covered" >return number+'er';d</span>efault:case'M':case'Q':case'DDD':case'd':case'w':case'W':<span class="cstat-no" title="statement not covered" >return number;}</span>},week:{dow:0,// Sunday is the first day of the week
doy:3// The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
},meridiemParse:/rati|sokallim|donparam|sanje/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem==='rati'){<span class="cstat-no" title="statement not covered" >return hour&lt;4?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem==='sokallim'){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem==='donparam'){<span class="cstat-no" title="statement not covered" >return hour&gt;12?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem==='sanje'){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'rati';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'sokallim';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;16){<span class="cstat-no" title="statement not covered" >return'donparam';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;20){<span class="cstat-no" title="statement not covered" >return'sanje';}</span>else{<span class="cstat-no" title="statement not covered" >return'rati';}</span>}</span></span></span></span>});//! moment.js locale configuration
var symbolMap$7=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap$6=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('gu',{months:'___________'.split('_'),monthsShort:'._.__.___._._._._._.'.split('_'),monthsParseExact:true,weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'A h:mm ',LTS:'A h:mm:ss ',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY, A h:mm ',LLLL:'dddd, D MMMM YYYY, A h:mm '},calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'dddd, LT',lastDay:'[] LT',lastWeek:'[] dddd, LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap$6[match];}</span>);}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$7[match];}</span>);}</span>,// Gujarati notation for meridiems are quite fuzzy in practice. While there exists</span>
// a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
meridiemParse:/|||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&lt;4?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&gt;=10?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;10){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;17){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;20){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span>,week:{dow:0,// Sunday is the first day of the week.
doy:6// The week that contains Jan 6th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('he',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D []MMMM YYYY',LLL:'D []MMMM YYYY HH:mm',LLLL:'dddd, D []MMMM YYYY HH:mm',l:'D/M/YYYY',ll:'D MMM YYYY',lll:'D MMM YYYY HH:mm',llll:'ddd, D MMM YYYY HH:mm'},calendar:{sameDay:'[ ]LT',nextDay:'[ ]LT',nextWeek:'dddd [] LT',lastDay:'[ ]LT',lastWeek:'[] dddd [ ] LT',sameElse:'L'},relativeTime:{future:' %s',past:' %s',s:' ',ss:'%d ',m:'',mm:'%d ',h:'',hh:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >if(number===2){<span class="cstat-no" title="statement not covered" >return'';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn number+' ';}</span>,d:'',dd:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >if(number===2){<span class="cstat-no" title="statement not covered" >return'';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn number+' ';}</span>,M:'',MM:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >if(number===2){<span class="cstat-no" title="statement not covered" >return'';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn number+' ';}</span>,y:'',yy:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >if(number===2){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(number%10===0&amp;&amp;number!==10){<span class="cstat-no" title="statement not covered" >return number+' ';}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn number+' ';}</span>},meridiemParse:/"|"| | | ||/i,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return /^("| |)$/.test(input);}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;5){<span class="cstat-no" title="statement not covered" >return' ';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;10){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return isLower?'"':' ';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;18){<span class="cstat-no" title="statement not covered" >return isLower?'"':' ';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span>});/</span>/! moment.js locale configuration
var symbolMap$8=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap$7=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'},</span>monthsParse$7=<span class="cstat-no" title="statement not covered" >[/^/i,/^|/i,/^/i,/^/i,/^/i,/^/i,/^/i,/^/i,/^|/i,/^/i,/^|/i,/^|/i],</span>shortMonthsParse=<span class="cstat-no" title="statement not covered" >[/^/i,/^/i,/^/i,/^/i,/^/i,/^/i,/^/i,/^/i,/^/i,/^/i,/^/i,/^/i];<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('hi',{months:{format:'___________'.split('_'),standalone:'___________'.split('_')},monthsShort:'._.__.___._._._._._.'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'A h:mm ',LTS:'A h:mm:ss ',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY, A h:mm ',LLLL:'dddd, D MMMM YYYY, A h:mm '},monthsParse:monthsParse$7,longMonthsParse:monthsParse$7,shortMonthsParse:shortMonthsParse,monthsRegex:/^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,monthsShortRegex:/^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,monthsStrictRegex:/^(?||?|?|?|?|?|?|?|||?\.?||\.?||?||?)/i,monthsShortStrictRegex:/^(\.?|\.?|?|\.?|?|?|\.?|\.?|\.?|\.?|\.?|\.?)/i,calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'dddd, LT',lastDay:'[] LT',lastWeek:'[] dddd, LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:'  ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap$7[match];}</span>);}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$8[match];}</span>);}</span>,// Hindi notation for meridiems are quite fuzzy in practice. While there exists</span>
// a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
meridiemParse:/|||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&lt;4?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&gt;=10?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;10){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;17){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;20){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span>,week:{dow:0,// Sunday is the first day of the week.
doy:6// The week that contains Jan 6th is the first week of the year.
}});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >translate$3(</span>number,withoutSuffix,key){var result=<span class="cstat-no" title="statement not covered" >number+' ';<span class="cstat-no" title="statement not covered" ></span>switch(key){case'ss':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+='sekunda';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2||number===3||number===4){<span class="cstat-no" title="statement not covered" >result+='sekunde';}</span>else{<span class="cstat-no" title="statement not covered" >result+='sekundi';}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn result;c</span>ase'm':<span class="cstat-no" title="statement not covered" >return withoutSuffix?'jedna minuta':'jedne minute';c</span>ase'mm':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+='minuta';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2||number===3||number===4){<span class="cstat-no" title="statement not covered" >result+='minute';}</span>else{<span class="cstat-no" title="statement not covered" >result+='minuta';}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn result;c</span>ase'h':<span class="cstat-no" title="statement not covered" >return withoutSuffix?'jedan sat':'jednog sata';c</span>ase'hh':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+='sat';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2||number===3||number===4){<span class="cstat-no" title="statement not covered" >result+='sata';}</span>else{<span class="cstat-no" title="statement not covered" >result+='sati';}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn result;c</span>ase'dd':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+='dan';}</span>else{<span class="cstat-no" title="statement not covered" >result+='dana';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn result;c</span>ase'MM':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+='mjesec';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2||number===3||number===4){<span class="cstat-no" title="statement not covered" >result+='mjeseca';}</span>else{<span class="cstat-no" title="statement not covered" >result+='mjeseci';}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn result;c</span>ase'yy':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+='godina';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2||number===3||number===4){<span class="cstat-no" title="statement not covered" >result+='godine';}</span>else{<span class="cstat-no" title="statement not covered" >result+='godina';}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn result;}</span>}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('hr',{months:{format:'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),standalone:'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')},monthsShort:'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),monthsParseExact:true,weekdays:'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),weekdaysShort:'ned._pon._uto._sri._et._pet._sub.'.split('_'),weekdaysMin:'ne_po_ut_sr_e_pe_su'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD.MM.YYYY',LL:'Do MMMM YYYY',LLL:'Do MMMM YYYY H:mm',LLLL:'dddd, Do MMMM YYYY H:mm'},calendar:{sameDay:'[danas u] LT',nextDay:'[sutra u] LT',nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[u] [nedjelju] [u] LT';c</span>ase 3:<span class="cstat-no" title="statement not covered" >return'[u] [srijedu] [u] LT';c</span>ase 6:<span class="cstat-no" title="statement not covered" >return'[u] [subotu] [u] LT';c</span>ase 1:case 2:case 4:case 5:<span class="cstat-no" title="statement not covered" >return'[u] dddd [u] LT';}</span>}</span>,lastDay:'[juer u] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[prolu] [nedjelju] [u] LT';c</span>ase 3:<span class="cstat-no" title="statement not covered" >return'[prolu] [srijedu] [u] LT';c</span>ase 6:<span class="cstat-no" title="statement not covered" >return'[prole] [subote] [u] LT';c</span>ase 1:case 2:case 4:case 5:<span class="cstat-no" title="statement not covered" >return'[proli] dddd [u] LT';}</span>}</span>,sameElse:'L'},relativeTime:{future:'za %s',past:'prije %s',s:'par sekundi',ss:translate$3,m:translate$3,mm:translate$3,h:translate$3,hh:translate$3,d:'dan',dd:translate$3,M:'mjesec',MM:translate$3,y:'godinu',yy:translate$3},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
var weekEndings=<span class="cstat-no" title="statement not covered" >'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');</span>function <span class="fstat-no" title="function not covered" >translate$4(</span>number,withoutSuffix,key,isFuture){var num=<span class="cstat-no" title="statement not covered" >number;<span class="cstat-no" title="statement not covered" ></span>switch(key){case's':<span class="cstat-no" title="statement not covered" >return isFuture||withoutSuffix?'nhny msodperc':'nhny msodperce';c</span>ase'ss':<span class="cstat-no" title="statement not covered" >return num+(isFuture||withoutSuffix)?' msodperc':' msodperce';c</span>ase'm':<span class="cstat-no" title="statement not covered" >return'egy'+(isFuture||withoutSuffix?' perc':' perce');c</span>ase'mm':<span class="cstat-no" title="statement not covered" >return num+(isFuture||withoutSuffix?' perc':' perce');c</span>ase'h':<span class="cstat-no" title="statement not covered" >return'egy'+(isFuture||withoutSuffix?' ra':' rja');c</span>ase'hh':<span class="cstat-no" title="statement not covered" >return num+(isFuture||withoutSuffix?' ra':' rja');c</span>ase'd':<span class="cstat-no" title="statement not covered" >return'egy'+(isFuture||withoutSuffix?' nap':' napja');c</span>ase'dd':<span class="cstat-no" title="statement not covered" >return num+(isFuture||withoutSuffix?' nap':' napja');c</span>ase'M':<span class="cstat-no" title="statement not covered" >return'egy'+(isFuture||withoutSuffix?' hnap':' hnapja');c</span>ase'MM':<span class="cstat-no" title="statement not covered" >return num+(isFuture||withoutSuffix?' hnap':' hnapja');c</span>ase'y':<span class="cstat-no" title="statement not covered" >return'egy'+(isFuture||withoutSuffix?' v':' ve');c</span>ase'yy':<span class="cstat-no" title="statement not covered" >return num+(isFuture||withoutSuffix?' v':' ve');}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn'';}</span>function <span class="fstat-no" title="function not covered" >week(</span>isFuture){<span class="cstat-no" title="statement not covered" >return(isFuture?'':'[mlt] ')+'['+weekEndings[this.day()]+'] LT[-kor]';}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('hu',{months:'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),monthsShort:'jan._feb._mrc._pr._mj._jn._jl._aug._szept._okt._nov._dec.'.split('_'),monthsParseExact:true,weekdays:'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),weekdaysShort:'vas_ht_kedd_sze_cst_pn_szo'.split('_'),weekdaysMin:'v_h_k_sze_cs_p_szo'.split('_'),longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'YYYY.MM.DD.',LL:'YYYY. MMMM D.',LLL:'YYYY. MMMM D. H:mm',LLLL:'YYYY. MMMM D., dddd H:mm'},meridiemParse:/de|du/i,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return input.charAt(1).toLowerCase()==='u';}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hours,minutes,isLower){<span class="cstat-no" title="statement not covered" >if(hours&lt;12){<span class="cstat-no" title="statement not covered" >return isLower===true?'de':'DE';}</span>else{<span class="cstat-no" title="statement not covered" >return isLower===true?'du':'DU';}</span>}</span>,calendar:{sameDay:'[ma] LT[-kor]',nextDay:'[holnap] LT[-kor]',nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return week.call(this,true);}</span>,lastDay:'[tegnap] LT[-kor]',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return week.call(this,false);}</span>,sameElse:'L'},relativeTime:{future:'%s mlva',past:'%s',s:translate$4,ss:translate$4,m:translate$4,mm:translate$4,h:translate$4,hh:translate$4,d:translate$4,dd:translate$4,M:translate$4,MM:translate$4,y:translate$4,yy:translate$4},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('hy-am',{months:{format:'___________'.split('_'),standalone:'___________'.split('_')},monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY .',LLL:'D MMMM YYYY ., HH:mm',LLLL:'dddd, D MMMM YYYY ., HH:mm'},calendar:{sameDay:'[] LT',nextDay:'[] LT',lastDay:'[] LT',nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'dddd [ ] LT';}</span>,lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[] dddd [ ] LT';}</span>,sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:'  ',ss:'%d ',m:'',mm:'%d ',h:'',hh:'%d ',d:'',dd:'%d ',M:'',MM:'%d ',y:'',yy:'%d '},meridiemParse:/|||/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return /^(|)$/.test(input);}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;17){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span>,dayOfMonthOrdinalParse:/\d{1,2}|\d{1,2}-(|)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){case'DDD':case'w':case'W':case'DDDo':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >return number+'-';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn number+'-';d</span>efault:<span class="cstat-no" title="statement not covered" >return number;}</span>}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('id',{months:'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),monthsShort:'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),weekdays:'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),weekdaysShort:'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),weekdaysMin:'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),longDateFormat:{LT:'HH.mm',LTS:'HH.mm.ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY [pukul] HH.mm',LLLL:'dddd, D MMMM YYYY [pukul] HH.mm'},meridiemParse:/pagi|siang|sore|malam/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem==='pagi'){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem==='siang'){<span class="cstat-no" title="statement not covered" >return hour&gt;=11?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem==='sore'||meridiem==='malam'){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hours,minutes,isLower){<span class="cstat-no" title="statement not covered" >if(hours&lt;11){<span class="cstat-no" title="statement not covered" >return'pagi';}</span>else <span class="cstat-no" title="statement not covered" >if(hours&lt;15){<span class="cstat-no" title="statement not covered" >return'siang';}</span>else <span class="cstat-no" title="statement not covered" >if(hours&lt;19){<span class="cstat-no" title="statement not covered" >return'sore';}</span>else{<span class="cstat-no" title="statement not covered" >return'malam';}</span>}</span></span></span>,calendar:{sameDay:'[Hari ini pukul] LT',nextDay:'[Besok pukul] LT',nextWeek:'dddd [pukul] LT',lastDay:'[Kemarin pukul] LT',lastWeek:'dddd [lalu pukul] LT',sameElse:'L'},relativeTime:{future:'dalam %s',past:'%s yang lalu',s:'beberapa detik',ss:'%d detik',m:'semenit',mm:'%d menit',h:'sejam',hh:'%d jam',d:'sehari',dd:'%d hari',M:'sebulan',MM:'%d bulan',y:'setahun',yy:'%d tahun'},week:{dow:0,// Sunday is the first day of the week.</span>
doy:6// The week that contains Jan 6th is the first week of the year.
}});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >plural$2(</span>n){<span class="cstat-no" title="statement not covered" >if(n%100===11){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(n%10===1){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn true;}</span>function <span class="fstat-no" title="function not covered" >translate$5(</span>number,withoutSuffix,key,isFuture){var result=<span class="cstat-no" title="statement not covered" >number+' ';<span class="cstat-no" title="statement not covered" ></span>switch(key){case's':<span class="cstat-no" title="statement not covered" >return withoutSuffix||isFuture?'nokkrar sekndur':'nokkrum sekndum';c</span>ase'ss':<span class="cstat-no" title="statement not covered" >if(plural$2(number)){<span class="cstat-no" title="statement not covered" >return result+(withoutSuffix||isFuture?'sekndur':'sekndum');}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn result+'seknda';c</span>ase'm':<span class="cstat-no" title="statement not covered" >return withoutSuffix?'mnta':'mntu';c</span>ase'mm':<span class="cstat-no" title="statement not covered" >if(plural$2(number)){<span class="cstat-no" title="statement not covered" >return result+(withoutSuffix||isFuture?'mntur':'mntum');}</span>else <span class="cstat-no" title="statement not covered" >if(withoutSuffix){<span class="cstat-no" title="statement not covered" >return result+'mnta';}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn result+'mntu';c</span>ase'hh':<span class="cstat-no" title="statement not covered" >if(plural$2(number)){<span class="cstat-no" title="statement not covered" >return result+(withoutSuffix||isFuture?'klukkustundir':'klukkustundum');}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn result+'klukkustund';c</span>ase'd':<span class="cstat-no" title="statement not covered" >if(withoutSuffix){<span class="cstat-no" title="statement not covered" >return'dagur';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn isFuture?'dag':'degi';c</span>ase'dd':<span class="cstat-no" title="statement not covered" >if(plural$2(number)){<span class="cstat-no" title="statement not covered" >if(withoutSuffix){<span class="cstat-no" title="statement not covered" >return result+'dagar';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn result+(isFuture?'daga':'dgum');}</span>else <span class="cstat-no" title="statement not covered" >if(withoutSuffix){<span class="cstat-no" title="statement not covered" >return result+'dagur';}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn result+(isFuture?'dag':'degi');c</span>ase'M':<span class="cstat-no" title="statement not covered" >if(withoutSuffix){<span class="cstat-no" title="statement not covered" >return'mnuur';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn isFuture?'mnu':'mnui';c</span>ase'MM':<span class="cstat-no" title="statement not covered" >if(plural$2(number)){<span class="cstat-no" title="statement not covered" >if(withoutSuffix){<span class="cstat-no" title="statement not covered" >return result+'mnuir';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn result+(isFuture?'mnui':'mnuum');}</span>else <span class="cstat-no" title="statement not covered" >if(withoutSuffix){<span class="cstat-no" title="statement not covered" >return result+'mnuur';}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn result+(isFuture?'mnu':'mnui');c</span>ase'y':<span class="cstat-no" title="statement not covered" >return withoutSuffix||isFuture?'r':'ri';c</span>ase'yy':<span class="cstat-no" title="statement not covered" >if(plural$2(number)){<span class="cstat-no" title="statement not covered" >return result+(withoutSuffix||isFuture?'r':'rum');}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn result+(withoutSuffix||isFuture?'r':'ri');}</span>}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('is',{months:'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),monthsShort:'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),weekdays:'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),weekdaysShort:'sun_mn_ri_mi_fim_fs_lau'.split('_'),weekdaysMin:'Su_M_r_Mi_Fi_F_La'.split('_'),longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD.MM.YYYY',LL:'D. MMMM YYYY',LLL:'D. MMMM YYYY [kl.] H:mm',LLLL:'dddd, D. MMMM YYYY [kl.] H:mm'},calendar:{sameDay:'[ dag kl.] LT',nextDay:'[ morgun kl.] LT',nextWeek:'dddd [kl.] LT',lastDay:'[ gr kl.] LT',lastWeek:'[sasta] dddd [kl.] LT',sameElse:'L'},relativeTime:{future:'eftir %s',past:'fyrir %s san',s:translate$5,ss:translate$5,m:translate$5,mm:translate$5,h:'klukkustund',hh:translate$5,d:translate$5,dd:translate$5,M:translate$5,MM:translate$5,y:translate$5,yy:translate$5},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('it-ch',{months:'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),monthsShort:'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),weekdays:'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),weekdaysShort:'dom_lun_mar_mer_gio_ven_sab'.split('_'),weekdaysMin:'do_lu_ma_me_gi_ve_sa'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},calendar:{sameDay:'[Oggi alle] LT',nextDay:'[Domani alle] LT',nextWeek:'dddd [alle] LT',lastDay:'[Ieri alle] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[la scorsa] dddd [alle] LT';d</span>efault:<span class="cstat-no" title="statement not covered" >return'[lo scorso] dddd [alle] LT';}</span>}</span>,sameElse:'L'},relativeTime:{future:<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >return(/^[0-9].+$/.test(s)?'tra':'in')+' '+s;}</span>,past:'%s fa',s:'alcuni secondi',ss:'%d secondi',m:'un minuto',mm:'%d minuti',h:"un'ora",hh:'%d ore',d:'un giorno',dd:'%d giorni',M:'un mese',MM:'%d mesi',y:'un anno',yy:'%d anni'},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('it',{months:'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),monthsShort:'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),weekdays:'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),weekdaysShort:'dom_lun_mar_mer_gio_ven_sab'.split('_'),weekdaysMin:'do_lu_ma_me_gi_ve_sa'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},calendar:{sameDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[Oggi a'+(this.hours()&gt;1?'lle ':this.hours()===0?' ':"ll'")+']LT';}</span>,nextDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[Domani a'+(this.hours()&gt;1?'lle ':this.hours()===0?' ':"ll'")+']LT';}</span>,nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'dddd [a'+(this.hours()&gt;1?'lle ':this.hours()===0?' ':"ll'")+']LT';}</span>,lastDay:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return'[Ieri a'+(this.hours()&gt;1?'lle ':this.hours()===0?' ':"ll'")+']LT';}</span>,lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[La scorsa] dddd [a'+(this.hours()&gt;1?'lle ':this.hours()===0?' ':"ll'")+']LT';d</span>efault:<span class="cstat-no" title="statement not covered" >return'[Lo scorso] dddd [a'+(this.hours()&gt;1?'lle ':this.hours()===0?' ':"ll'")+']LT';}</span>}</span>,sameElse:'L'},relativeTime:{future:'tra %s',past:'%s fa',s:'alcuni secondi',ss:'%d secondi',m:'un minuto',mm:'%d minuti',h:"un'ora",hh:'%d ore',d:'un giorno',dd:'%d giorni',w:'una settimana',ww:'%d settimane',M:'un mese',MM:'%d mesi',y:'un anno',yy:'%d anni'},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('ja',{eras:[{since:'2019-05-01',offset:1,name:'',narrow:'',abbr:'R'},{since:'1989-01-08',until:'2019-04-30',offset:1,name:'',narrow:'',abbr:'H'},{since:'1926-12-25',until:'1989-01-07',offset:1,name:'',narrow:'',abbr:'S'},{since:'1912-07-30',until:'1926-12-24',offset:1,name:'',narrow:'',abbr:'T'},{since:'1873-01-01',until:'1912-07-29',offset:6,name:'',narrow:'',abbr:'M'},{since:'0001-01-01',until:'1873-12-31',offset:1,name:'',narrow:'AD',abbr:'AD'},{since:'0000-12-31',until:-Infinity,offset:1,name:'',narrow:'BC',abbr:'BC'}],eraYearOrdinalRegex:/(|\d+)/,eraYearOrdinalParse:<span class="fstat-no" title="function not covered" >fu</span>nction(input,match){<span class="cstat-no" title="statement not covered" >return match[1]===''?1:parseInt(match[1]||input,10);}</span>,months:'1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),monthsShort:'1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'YYYY/MM/DD',LL:'YYYYMD',LLL:'YYYYMD HH:mm',LLLL:'YYYYMD dddd HH:mm',l:'YYYY/MM/DD',ll:'YYYYMD',lll:'YYYYMD HH:mm',llll:'YYYYMD(ddd) HH:mm'},meridiemParse:/|/i,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return input==='';}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span>,calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(now){<span class="cstat-no" title="statement not covered" >if(now.week()!==this.week()){<span class="cstat-no" title="statement not covered" >return'[]dddd LT';}</span>else{<span class="cstat-no" title="statement not covered" >return'dddd LT';}</span>}</span>,lastDay:'[] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(now){<span class="cstat-no" title="statement not covered" >if(this.week()!==now.week()){<span class="cstat-no" title="statement not covered" >return'[]dddd LT';}</span>else{<span class="cstat-no" title="statement not covered" >return'dddd LT';}</span>}</span>,sameElse:'L'},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){case'y':<span class="cstat-no" title="statement not covered" >return number===1?'':number+'';c</span>ase'd':case'D':case'DDD':<span class="cstat-no" title="statement not covered" >return number+'';d</span>efault:<span class="cstat-no" title="statement not covered" >return number;}</span>}</span>,relativeTime:{future:'%s',past:'%s',s:'',ss:'%d',m:'1',mm:'%d',h:'1',hh:'%d',d:'1',dd:'%d',M:'1',MM:'%d',y:'1',yy:'%d'}});/</span>/! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('jv',{months:'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),monthsShort:'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),weekdays:'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),weekdaysShort:'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),weekdaysMin:'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),longDateFormat:{LT:'HH.mm',LTS:'HH.mm.ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY [pukul] HH.mm',LLLL:'dddd, D MMMM YYYY [pukul] HH.mm'},meridiemParse:/enjing|siyang|sonten|ndalu/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem==='enjing'){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem==='siyang'){<span class="cstat-no" title="statement not covered" >return hour&gt;=11?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem==='sonten'||meridiem==='ndalu'){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hours,minutes,isLower){<span class="cstat-no" title="statement not covered" >if(hours&lt;11){<span class="cstat-no" title="statement not covered" >return'enjing';}</span>else <span class="cstat-no" title="statement not covered" >if(hours&lt;15){<span class="cstat-no" title="statement not covered" >return'siyang';}</span>else <span class="cstat-no" title="statement not covered" >if(hours&lt;19){<span class="cstat-no" title="statement not covered" >return'sonten';}</span>else{<span class="cstat-no" title="statement not covered" >return'ndalu';}</span>}</span></span></span>,calendar:{sameDay:'[Dinten puniko pukul] LT',nextDay:'[Mbenjang pukul] LT',nextWeek:'dddd [pukul] LT',lastDay:'[Kala wingi pukul] LT',lastWeek:'dddd [kepengker pukul] LT',sameElse:'L'},relativeTime:{future:'wonten ing %s',past:'%s ingkang kepengker',s:'sawetawis detik',ss:'%d detik',m:'setunggal menit',mm:'%d menit',h:'setunggal jam',hh:'%d jam',d:'sedinten',dd:'%d dinten',M:'sewulan',MM:'%d wulan',y:'setaun',yy:'%d taun'},week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('ka',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:{standalone:'______'.split('_'),format:'______'.split('_'),isFormat:/(|)/},weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[] LT[-]',nextDay:'[] LT[-]',lastDay:'[] LT[-]',nextWeek:'[] dddd LT[-]',lastWeek:'[] dddd LT-',sameElse:'L'},relativeTime:{future:<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >return s.replace(/(|||||)(|)/,<span class="fstat-no" title="function not covered" >fu</span>nction($0,$1,$2){<span class="cstat-no" title="statement not covered" >return $2===''?$1+'':$1+$2+'';}</span>);}</span>,past:<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >if(/(||||)/.test(s)){<span class="cstat-no" title="statement not covered" >return s.replace(/(|)$/,' ');}<span class="cstat-no" title="statement not covered" ></span>i</span>f(//.test(s)){<span class="cstat-no" title="statement not covered" >return s.replace(/$/,' ');}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s;}</span>,s:' ',ss:'%d ',m:'',mm:'%d ',h:'',hh:'%d ',d:'',dd:'%d ',M:'',MM:'%d ',y:'',yy:'%d '},dayOfMonthOrdinalParse:/0|1-|-\d{1,2}|\d{1,2}-/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >if(number===0){<span class="cstat-no" title="statement not covered" >return number;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(number===1){<span class="cstat-no" title="statement not covered" >return number+'-';}<span class="cstat-no" title="statement not covered" ></span>i</span>f(number&lt;20||number&lt;=100&amp;&amp;number%20===0||number%100===0){<span class="cstat-no" title="statement not covered" >return'-'+number;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn number+'-';}</span>,week:{dow:1,doy:7}});/</span>/! moment.js locale configuration
var suffixes$1=<span class="cstat-no" title="statement not covered" >{0:'-',1:'-',2:'-',3:'-',4:'-',5:'-',6:'-',7:'-',8:'-',9:'-',10:'-',20:'-',30:'-',40:'-',50:'-',60:'-',70:'-',80:'-',90:'-',100:'-'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('kk',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[ ] LT',nextDay:'[ ] LT',nextWeek:'dddd [] LT',lastDay:'[ ] LT',lastWeek:'[ ] dddd [] LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},dayOfMonthOrdinalParse:/\d{1,2}-(|)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var a=<span class="cstat-no" title="statement not covered" >number%10,</span>b=<span class="cstat-no" title="statement not covered" >number&gt;=100?100:null;<span class="cstat-no" title="statement not covered" ></span>return number+(suffixes$1[number]||suffixes$1[a]||suffixes$1[b]);}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
var symbolMap$9=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap$8=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('km',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},meridiemParse:/|/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return input==='';}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span>,calendar:{sameDay:'[ ] LT',nextDay:'[ ] LT',nextWeek:'dddd [] LT',lastDay:'[ ] LT',lastWeek:'dddd [] [] LT',sameElse:'L'},relativeTime:{future:'%s',past:'%s',s:'',ss:'%d ',m:'',mm:'%d ',h:'',hh:'%d ',d:'',dd:'%d ',M:'',MM:'%d ',y:'',yy:'%d '},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap$8[match];}</span>);}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$9[match];}</span>);}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var symbolMap$a=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap$9=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('kn',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),monthsParseExact:true,weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'A h:mm',LTS:'A h:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY, A h:mm',LLLL:'dddd, D MMMM YYYY, A h:mm'},calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'dddd, LT',lastDay:'[] LT',lastWeek:'[] dddd, LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap$9[match];}</span>);}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$a[match];}</span>);}</span>,meridiemParse:/|||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&lt;4?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&gt;=10?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;10){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;17){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;20){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span>,dayOfMonthOrdinalParse:/\d{1,2}()/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >return number+'';}</span>,week:{dow:0,// Sunday is the first day of the week.</span>
doy:6// The week that contains Jan 6th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('ko',{months:'1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),monthsShort:'1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'A h:mm',LTS:'A h:mm:ss',L:'YYYY.MM.DD.',LL:'YYYY MMMM D',LLL:'YYYY MMMM D A h:mm',LLLL:'YYYY MMMM D dddd A h:mm',l:'YYYY.MM.DD.',ll:'YYYY MMMM D',lll:'YYYY MMMM D A h:mm',llll:'YYYY MMMM D dddd A h:mm'},calendar:{sameDay:' LT',nextDay:' LT',nextWeek:'dddd LT',lastDay:' LT',lastWeek:' dddd LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:' ',ss:'%d',m:'1',mm:'%d',h:' ',hh:'%d',d:'',dd:'%d',M:' ',MM:'%d',y:' ',yy:'%d'},dayOfMonthOrdinalParse:/\d{1,2}(||)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){case'd':case'D':case'DDD':<span class="cstat-no" title="statement not covered" >return number+'';c</span>ase'M':<span class="cstat-no" title="statement not covered" >return number+'';c</span>ase'w':case'W':<span class="cstat-no" title="statement not covered" >return number+'';d</span>efault:<span class="cstat-no" title="statement not covered" >return number;}</span>}</span>,meridiemParse:/|/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(token){<span class="cstat-no" title="statement not covered" >return token==='';}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isUpper){<span class="cstat-no" title="statement not covered" >return hour&lt;12?'':'';}</span>});/</span>/! moment.js locale configuration
var symbolMap$b=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap$a=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'},</span>months$8=<span class="cstat-no" title="statement not covered" >[' ','','','','','','','','',' ',' ',' '];<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('ku',{months:months$8,monthsShort:months$8,weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},meridiemParse:/|/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return //.test(input);}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span>,calendar:{sameDay:'[ ] LT',nextDay:'[ ] LT',nextWeek:'dddd [] LT',lastDay:'[ ] LT',lastWeek:'dddd [] LT',sameElse:'L'},relativeTime:{future:' %s',past:'%s',s:' ',ss:' %d',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap$a[match];}</span>).replace(//g,',');}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$b[match];}</span>).replace(/,/g,'');}</span>,week:{dow:6,// Saturday is the first day of the week.</span>
doy:12// The week that contains Jan 12th is the first week of the year.
}});//! moment.js locale configuration
var suffixes$2=<span class="cstat-no" title="statement not covered" >{0:'-',1:'-',2:'-',3:'-',4:'-',5:'-',6:'-',7:'-',8:'-',9:'-',10:'-',20:'-',30:'-',40:'-',50:'-',60:'-',70:'-',80:'-',90:'-',100:'-'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('ky',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[ ] LT',nextDay:'[ ] LT',nextWeek:'dddd [] LT',lastDay:'[ ] LT',lastWeek:'[ ] dddd [] [] LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},dayOfMonthOrdinalParse:/\d{1,2}-(|||)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var a=<span class="cstat-no" title="statement not covered" >number%10,</span>b=<span class="cstat-no" title="statement not covered" >number&gt;=100?100:null;<span class="cstat-no" title="statement not covered" ></span>return number+(suffixes$2[number]||suffixes$2[a]||suffixes$2[b]);}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >processRelativeTime$6(</span>number,withoutSuffix,key,isFuture){var format=<span class="cstat-no" title="statement not covered" >{m:['eng Minutt','enger Minutt'],h:['eng Stonn','enger Stonn'],d:['een Dag','engem Dag'],M:['ee Mount','engem Mount'],y:['ee Joer','engem Joer']};<span class="cstat-no" title="statement not covered" ></span>return withoutSuffix?format[key][0]:format[key][1];}</span>function <span class="fstat-no" title="function not covered" >processFutureTime(</span>string){var number=<span class="cstat-no" title="statement not covered" >string.substr(0,string.indexOf(' '));<span class="cstat-no" title="statement not covered" ></span>if(eifelerRegelAppliesToNumber(number)){<span class="cstat-no" title="statement not covered" >return'a '+string;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn'an '+string;}</span>function <span class="fstat-no" title="function not covered" >processPastTime(</span>string){var number=<span class="cstat-no" title="statement not covered" >string.substr(0,string.indexOf(' '));<span class="cstat-no" title="statement not covered" ></span>if(eifelerRegelAppliesToNumber(number)){<span class="cstat-no" title="statement not covered" >return'viru '+string;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn'virun '+string;}</span>/**
     * Returns true if the word before the given number loses the '-n' ending.
     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
     *
     * @param number {integer}
     * @returns {boolean}
     */function <span class="fstat-no" title="function not covered" >eifelerRegelAppliesToNumber(</span>number){<span class="cstat-no" title="statement not covered" >number=parseInt(number,10);<span class="cstat-no" title="statement not covered" >i</span>f(isNaN(number)){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(number&lt;0){// Negative Number --&gt; always true</span>
<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(number&lt;10){// Only 1 digit</span>
<span class="cstat-no" title="statement not covered" >if(4&lt;=number&amp;&amp;number&lt;=7){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span>else <span class="cstat-no" title="statement not covered" >if(number&lt;100){// 2 digits</span>
var lastDigit=<span class="cstat-no" title="statement not covered" >number%10,</span>firstDigit=<span class="cstat-no" title="statement not covered" >number/10;<span class="cstat-no" title="statement not covered" ></span>if(lastDigit===0){<span class="cstat-no" title="statement not covered" >return eifelerRegelAppliesToNumber(firstDigit);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn eifelerRegelAppliesToNumber(lastDigit);}</span>else <span class="cstat-no" title="statement not covered" >if(number&lt;10000){// 3 or 4 digits --&gt; recursively check first digit</span>
<span class="cstat-no" title="statement not covered" >while(number&gt;=10){<span class="cstat-no" title="statement not covered" >number=number/10;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn eifelerRegelAppliesToNumber(number);}</span>else{// Anything larger than 4 digits: recursively check first n-3 digits
<span class="cstat-no" title="statement not covered" >number=number/1000;<span class="cstat-no" title="statement not covered" >r</span>eturn eifelerRegelAppliesToNumber(number);}</span>}<span class="cstat-no" title="statement not covered" >hooks.defineLocale('lb',{months:'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),monthsShort:'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),monthsParseExact:true,weekdays:'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),weekdaysShort:'So._M._D._M._Do._Fr._Sa.'.split('_'),weekdaysMin:'So_M_D_M_Do_Fr_Sa'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'H:mm [Auer]',LTS:'H:mm:ss [Auer]',L:'DD.MM.YYYY',LL:'D. MMMM YYYY',LLL:'D. MMMM YYYY H:mm [Auer]',LLLL:'dddd, D. MMMM YYYY H:mm [Auer]'},calendar:{sameDay:'[Haut um] LT',sameElse:'L',nextDay:'[Muer um] LT',nextWeek:'dddd [um] LT',lastDay:'[Gschter um] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){// Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule</span>
<span class="cstat-no" title="statement not covered" >switch(this.day()){case 2:case 4:<span class="cstat-no" title="statement not covered" >return'[Leschten] dddd [um] LT';d</span>efault:<span class="cstat-no" title="statement not covered" >return'[Leschte] dddd [um] LT';}</span>}</span>},relativeTime:{future:processFutureTime,past:processPastTime,s:'e puer Sekonnen',ss:'%d Sekonnen',m:processRelativeTime$6,mm:'%d Minutten',h:processRelativeTime$6,hh:'%d Stonnen',d:processRelativeTime$6,dd:'%d Deeg',M:processRelativeTime$6,MM:'%d Mint',y:processRelativeTime$6,yy:'%d Joer'},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('lo',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},meridiemParse:/|/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return input==='';}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span>,calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'[]dddd[] LT',lastDay:'[] LT',lastWeek:'[]dddd[] LT',sameElse:'L'},relativeTime:{future:' %s',past:'%s',s:'',ss:'%d ',m:'1 ',mm:'%d ',h:'1 ',hh:'%d ',d:'1 ',dd:'%d ',M:'1 ',MM:'%d ',y:'1 ',yy:'%d '},dayOfMonthOrdinalParse:/()\d{1,2}/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >return''+number;}</span>});/</span>/! moment.js locale configuration
var units=<span class="cstat-no" title="statement not covered" >{ss:'sekund_sekundi_sekundes',m:'minut_minuts_minut',mm:'minuts_minui_minutes',h:'valanda_valandos_valand',hh:'valandos_valand_valandas',d:'diena_dienos_dien',dd:'dienos_dien_dienas',M:'mnuo_mnesio_mnes',MM:'mnesiai_mnesi_mnesius',y:'metai_met_metus',yy:'metai_met_metus'};</span>function <span class="fstat-no" title="function not covered" >translateSeconds(</span>number,withoutSuffix,key,isFuture){<span class="cstat-no" title="statement not covered" >if(withoutSuffix){<span class="cstat-no" title="statement not covered" >return'kelios sekunds';}</span>else{<span class="cstat-no" title="statement not covered" >return isFuture?'keli sekundi':'kelias sekundes';}</span>}</span>function <span class="fstat-no" title="function not covered" >translateSingular(</span>number,withoutSuffix,key,isFuture){<span class="cstat-no" title="statement not covered" >return withoutSuffix?forms(key)[0]:isFuture?forms(key)[1]:forms(key)[2];}</span>function <span class="fstat-no" title="function not covered" >special(</span>number){<span class="cstat-no" title="statement not covered" >return number%10===0||number&gt;10&amp;&amp;number&lt;20;}</span>function <span class="fstat-no" title="function not covered" >forms(</span>key){<span class="cstat-no" title="statement not covered" >return units[key].split('_');}</span>function <span class="fstat-no" title="function not covered" >translate$6(</span>number,withoutSuffix,key,isFuture){var result=<span class="cstat-no" title="statement not covered" >number+' ';<span class="cstat-no" title="statement not covered" ></span>if(number===1){<span class="cstat-no" title="statement not covered" >return result+translateSingular(number,withoutSuffix,key[0],isFuture);}</span>else <span class="cstat-no" title="statement not covered" >if(withoutSuffix){<span class="cstat-no" title="statement not covered" >return result+(special(number)?forms(key)[1]:forms(key)[0]);}</span>else{<span class="cstat-no" title="statement not covered" >if(isFuture){<span class="cstat-no" title="statement not covered" >return result+forms(key)[1];}</span>else{<span class="cstat-no" title="statement not covered" >return result+(special(number)?forms(key)[1]:forms(key)[2]);}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span></span>hooks.defineLocale('lt',{months:{format:'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),standalone:'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),isFormat:/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/},monthsShort:'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),weekdays:{format:'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),standalone:'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),isFormat:/dddd HH:mm/},weekdaysShort:'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),weekdaysMin:'S_P_A_T_K_Pn_'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'YYYY-MM-DD',LL:'YYYY [m.] MMMM D [d.]',LLL:'YYYY [m.] MMMM D [d.], HH:mm [val.]',LLLL:'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',l:'YYYY-MM-DD',ll:'YYYY [m.] MMMM D [d.]',lll:'YYYY [m.] MMMM D [d.], HH:mm [val.]',llll:'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'},calendar:{sameDay:'[iandien] LT',nextDay:'[Rytoj] LT',nextWeek:'dddd LT',lastDay:'[Vakar] LT',lastWeek:'[Prajus] dddd LT',sameElse:'L'},relativeTime:{future:'po %s',past:'prie %s',s:translateSeconds,ss:translate$6,m:translateSingular,mm:translate$6,h:translateSingular,hh:translate$6,d:translateSingular,dd:translate$6,M:translateSingular,MM:translate$6,y:translateSingular,yy:translate$6},dayOfMonthOrdinalParse:/\d{1,2}-oji/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >return number+'-oji';}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var units$1=<span class="cstat-no" title="statement not covered" >{ss:'sekundes_sekundm_sekunde_sekundes'.split('_'),m:'mintes_mintm_minte_mintes'.split('_'),mm:'mintes_mintm_minte_mintes'.split('_'),h:'stundas_stundm_stunda_stundas'.split('_'),hh:'stundas_stundm_stunda_stundas'.split('_'),d:'dienas_dienm_diena_dienas'.split('_'),dd:'dienas_dienm_diena_dienas'.split('_'),M:'mnea_mneiem_mnesis_mnei'.split('_'),MM:'mnea_mneiem_mnesis_mnei'.split('_'),y:'gada_gadiem_gads_gadi'.split('_'),yy:'gada_gadiem_gads_gadi'.split('_')};</span>/**
     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
     */function <span class="fstat-no" title="function not covered" >format$1(</span>forms,number,withoutSuffix){<span class="cstat-no" title="statement not covered" >if(withoutSuffix){// E.g. "21 minte", "3 mintes".</span>
<span class="cstat-no" title="statement not covered" >return number%10===1&amp;&amp;number%100!==11?forms[2]:forms[3];}</span>else{// E.g. "21 mintes" as in "pc 21 mintes".
// E.g. "3 mintm" as in "pc 3 mintm".
<span class="cstat-no" title="statement not covered" >return number%10===1&amp;&amp;number%100!==11?forms[0]:forms[1];}</span>}function <span class="fstat-no" title="function not covered" >relativeTimeWithPlural$1(</span>number,withoutSuffix,key){<span class="cstat-no" title="statement not covered" >return number+' '+format$1(units$1[key],number,withoutSuffix);}</span>function <span class="fstat-no" title="function not covered" >relativeTimeWithSingular(</span>number,withoutSuffix,key){<span class="cstat-no" title="statement not covered" >return format$1(units$1[key],number,withoutSuffix);}</span>function <span class="fstat-no" title="function not covered" >relativeSeconds(</span>number,withoutSuffix){<span class="cstat-no" title="statement not covered" >return withoutSuffix?'daas sekundes':'dam sekundm';}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('lv',{months:'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),monthsShort:'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),weekdays:'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),weekdaysShort:'Sv_P_O_T_C_Pk_S'.split('_'),weekdaysMin:'Sv_P_O_T_C_Pk_S'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY.',LL:'YYYY. [gada] D. MMMM',LLL:'YYYY. [gada] D. MMMM, HH:mm',LLLL:'YYYY. [gada] D. MMMM, dddd, HH:mm'},calendar:{sameDay:'[odien pulksten] LT',nextDay:'[Rt pulksten] LT',nextWeek:'dddd [pulksten] LT',lastDay:'[Vakar pulksten] LT',lastWeek:'[Pagju] dddd [pulksten] LT',sameElse:'L'},relativeTime:{future:'pc %s',past:'pirms %s',s:relativeSeconds,ss:relativeTimeWithPlural$1,m:relativeTimeWithSingular,mm:relativeTimeWithPlural$1,h:relativeTimeWithSingular,hh:relativeTimeWithPlural$1,d:relativeTimeWithSingular,dd:relativeTimeWithPlural$1,M:relativeTimeWithSingular,MM:relativeTimeWithPlural$1,y:relativeTimeWithSingular,yy:relativeTimeWithPlural$1},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var translator=<span class="cstat-no" title="statement not covered" >{words:{//Different grammatical cases</span>
ss:['sekund','sekunda','sekundi'],m:['jedan minut','jednog minuta'],mm:['minut','minuta','minuta'],h:['jedan sat','jednog sata'],hh:['sat','sata','sati'],dd:['dan','dana','dana'],MM:['mjesec','mjeseca','mjeseci'],yy:['godina','godine','godina']},correctGrammaticalCase:<span class="fstat-no" title="function not covered" >fu</span>nction(number,wordKey){<span class="cstat-no" title="statement not covered" >return number===1?wordKey[0]:number&gt;=2&amp;&amp;number&lt;=4?wordKey[1]:wordKey[2];}</span>,translate:<span class="fstat-no" title="function not covered" >fu</span>nction(number,withoutSuffix,key){var wordKey=<span class="cstat-no" title="statement not covered" >translator.words[key];<span class="cstat-no" title="statement not covered" ></span>if(key.length===1){<span class="cstat-no" title="statement not covered" >return withoutSuffix?wordKey[0]:wordKey[1];}</span>else{<span class="cstat-no" title="statement not covered" >return number+' '+translator.correctGrammaticalCase(number,wordKey);}</span>}</span>};<span class="cstat-no" title="statement not covered" >hooks.defineLocale('me',{months:'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),monthsShort:'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),monthsParseExact:true,weekdays:'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),weekdaysShort:'ned._pon._uto._sri._et._pet._sub.'.split('_'),weekdaysMin:'ne_po_ut_sr_e_pe_su'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD.MM.YYYY',LL:'D. MMMM YYYY',LLL:'D. MMMM YYYY H:mm',LLLL:'dddd, D. MMMM YYYY H:mm'},calendar:{sameDay:'[danas u] LT',nextDay:'[sjutra u] LT',nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[u] [nedjelju] [u] LT';c</span>ase 3:<span class="cstat-no" title="statement not covered" >return'[u] [srijedu] [u] LT';c</span>ase 6:<span class="cstat-no" title="statement not covered" >return'[u] [subotu] [u] LT';c</span>ase 1:case 2:case 4:case 5:<span class="cstat-no" title="statement not covered" >return'[u] dddd [u] LT';}</span>}</span>,lastDay:'[jue u] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){var lastWeekDays=<span class="cstat-no" title="statement not covered" >['[prole] [nedjelje] [u] LT','[prolog] [ponedjeljka] [u] LT','[prolog] [utorka] [u] LT','[prole] [srijede] [u] LT','[prolog] [etvrtka] [u] LT','[prolog] [petka] [u] LT','[prole] [subote] [u] LT'];<span class="cstat-no" title="statement not covered" ></span>return lastWeekDays[this.day()];}</span>,sameElse:'L'},relativeTime:{future:'za %s',past:'prije %s',s:'nekoliko sekundi',ss:translator.translate,m:translator.translate,mm:translator.translate,h:translator.translate,hh:translator.translate,d:'dan',dd:translator.translate,M:'mjesec',MM:translator.translate,y:'godinu',yy:translator.translate},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('mi',{months:'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),monthsShort:'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),monthsRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,monthsStrictRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,monthsShortRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,monthsShortStrictRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,weekdays:'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),weekdaysShort:'Ta_Ma_T_We_Ti_Pa_H'.split('_'),weekdaysMin:'Ta_Ma_T_We_Ti_Pa_H'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY [i] HH:mm',LLLL:'dddd, D MMMM YYYY [i] HH:mm'},calendar:{sameDay:'[i teie mahana, i] LT',nextDay:'[apopo i] LT',nextWeek:'dddd [i] LT',lastDay:'[inanahi i] LT',lastWeek:'dddd [whakamutunga i] LT',sameElse:'L'},relativeTime:{future:'i roto i %s',past:'%s i mua',s:'te hkona ruarua',ss:'%d hkona',m:'he meneti',mm:'%d meneti',h:'te haora',hh:'%d haora',d:'he ra',dd:'%d ra',M:'he marama',MM:'%d marama',y:'he tau',yy:'%d tau'},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('mk',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'e_o_____a'.split('_'),longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'D.MM.YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY H:mm',LLLL:'dddd, D MMMM YYYY H:mm'},calendar:{sameDay:'[ ] LT',nextDay:'[ ] LT',nextWeek:'[] dddd [] LT',lastDay:'[ ] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:case 3:case 6:<span class="cstat-no" title="statement not covered" >return'[] dddd [] LT';c</span>ase 1:case 2:case 4:case 5:<span class="cstat-no" title="statement not covered" >return'[] dddd [] LT';}</span>}</span>,sameElse:'L'},relativeTime:{future:' %s',past:' %s',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},dayOfMonthOrdinalParse:/\d{1,2}-(|||||)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var lastDigit=<span class="cstat-no" title="statement not covered" >number%10,</span>last2Digits=<span class="cstat-no" title="statement not covered" >number%100;<span class="cstat-no" title="statement not covered" ></span>if(number===0){<span class="cstat-no" title="statement not covered" >return number+'-';}</span>else <span class="cstat-no" title="statement not covered" >if(last2Digits===0){<span class="cstat-no" title="statement not covered" >return number+'-';}</span>else <span class="cstat-no" title="statement not covered" >if(last2Digits&gt;10&amp;&amp;last2Digits&lt;20){<span class="cstat-no" title="statement not covered" >return number+'-';}</span>else <span class="cstat-no" title="statement not covered" >if(lastDigit===1){<span class="cstat-no" title="statement not covered" >return number+'-';}</span>else <span class="cstat-no" title="statement not covered" >if(lastDigit===2){<span class="cstat-no" title="statement not covered" >return number+'-';}</span>else <span class="cstat-no" title="statement not covered" >if(lastDigit===7||lastDigit===8){<span class="cstat-no" title="statement not covered" >return number+'-';}</span>else{<span class="cstat-no" title="statement not covered" >return number+'-';}</span>}</span></span></span></span></span></span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('ml',{months:'___________'.split('_'),monthsShort:'._._._.___._._._._._.'.split('_'),monthsParseExact:true,weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'A h:mm -',LTS:'A h:mm:ss -',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY, A h:mm -',LLLL:'dddd, D MMMM YYYY, A h:mm -'},calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'dddd, LT',lastDay:'[] LT',lastWeek:'[] dddd, LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},meridiemParse:/|| ||/i,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''&amp;&amp;hour&gt;=4||meridiem===' '||meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>else{<span class="cstat-no" title="statement not covered" >return hour;}</span>}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;17){<span class="cstat-no" title="statement not covered" >return' ';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;20){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span>});/</span>/! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >translate$7(</span>number,withoutSuffix,key,isFuture){<span class="cstat-no" title="statement not covered" >switch(key){case's':<span class="cstat-no" title="statement not covered" >return withoutSuffix?' ':' ';c</span>ase'ss':<span class="cstat-no" title="statement not covered" >return number+(withoutSuffix?' ':' ');c</span>ase'm':case'mm':<span class="cstat-no" title="statement not covered" >return number+(withoutSuffix?' ':' ');c</span>ase'h':case'hh':<span class="cstat-no" title="statement not covered" >return number+(withoutSuffix?' ':' ');c</span>ase'd':case'dd':<span class="cstat-no" title="statement not covered" >return number+(withoutSuffix?' ':' ');c</span>ase'M':case'MM':<span class="cstat-no" title="statement not covered" >return number+(withoutSuffix?' ':' ');c</span>ase'y':case'yy':<span class="cstat-no" title="statement not covered" >return number+(withoutSuffix?' ':' ');d</span>efault:<span class="cstat-no" title="statement not covered" >return number;}</span>}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('mn',{months:' _ _ _ _ _ _ _ _ _ _  _  '.split('_'),monthsShort:'1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 '.split('_'),monthsParseExact:true,weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'YYYY-MM-DD',LL:'YYYY  MMMM D',LLL:'YYYY  MMMM D HH:mm',LLLL:'dddd, YYYY  MMMM D HH:mm'},meridiemParse:/|/i,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return input==='';}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span>,calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'[] dddd LT',lastDay:'[] LT',lastWeek:'[] dddd LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:translate$7,ss:translate$7,m:translate$7,mm:translate$7,h:translate$7,hh:translate$7,d:translate$7,dd:translate$7,M:translate$7,MM:translate$7,y:translate$7,yy:translate$7},dayOfMonthOrdinalParse:/\d{1,2} /,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){case'd':case'D':case'DDD':<span class="cstat-no" title="statement not covered" >return number+' ';d</span>efault:<span class="cstat-no" title="statement not covered" >return number;}</span>}</span>});/</span>/! moment.js locale configuration
var symbolMap$c=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap$b=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'};</span>function <span class="fstat-no" title="function not covered" >relativeTimeMr(</span>number,withoutSuffix,string,isFuture){var output=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>if(withoutSuffix){<span class="cstat-no" title="statement not covered" >switch(string){case's':<span class="cstat-no" title="statement not covered" >output=' ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'ss':<span class="cstat-no" title="statement not covered" >output='%d ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'm':<span class="cstat-no" title="statement not covered" >output=' ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'mm':<span class="cstat-no" title="statement not covered" >output='%d ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'h':<span class="cstat-no" title="statement not covered" >output=' ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'hh':<span class="cstat-no" title="statement not covered" >output='%d ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'd':<span class="cstat-no" title="statement not covered" >output=' ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'dd':<span class="cstat-no" title="statement not covered" >output='%d ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'M':<span class="cstat-no" title="statement not covered" >output=' ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'MM':<span class="cstat-no" title="statement not covered" >output='%d ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'y':<span class="cstat-no" title="statement not covered" >output=' ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'yy':<span class="cstat-no" title="statement not covered" >output='%d ';<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>else{<span class="cstat-no" title="statement not covered" >switch(string){case's':<span class="cstat-no" title="statement not covered" >output=' ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'ss':<span class="cstat-no" title="statement not covered" >output='%d ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'm':<span class="cstat-no" title="statement not covered" >output=' ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'mm':<span class="cstat-no" title="statement not covered" >output='%d ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'h':<span class="cstat-no" title="statement not covered" >output=' ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'hh':<span class="cstat-no" title="statement not covered" >output='%d ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'd':<span class="cstat-no" title="statement not covered" >output=' ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'dd':<span class="cstat-no" title="statement not covered" >output='%d ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'M':<span class="cstat-no" title="statement not covered" >output=' ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'MM':<span class="cstat-no" title="statement not covered" >output='%d ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'y':<span class="cstat-no" title="statement not covered" >output=' ';<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase'yy':<span class="cstat-no" title="statement not covered" >output='%d ';<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn output.replace(/%d/i,number);}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('mr',{months:'___________'.split('_'),monthsShort:'._._._._._._._._._._._.'.split('_'),monthsParseExact:true,weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'A h:mm ',LTS:'A h:mm:ss ',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY, A h:mm ',LLLL:'dddd, D MMMM YYYY, A h:mm '},calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'dddd, LT',lastDay:'[] LT',lastWeek:'[] dddd, LT',sameElse:'L'},relativeTime:{future:'%s',past:'%s',s:relativeTimeMr,ss:relativeTimeMr,m:relativeTimeMr,mm:relativeTimeMr,h:relativeTimeMr,hh:relativeTimeMr,d:relativeTimeMr,dd:relativeTimeMr,M:relativeTimeMr,MM:relativeTimeMr,y:relativeTimeMr,yy:relativeTimeMr},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap$b[match];}</span>);}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$c[match];}</span>);}</span>,meridiemParse:/||||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''||meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''||meridiem===''||meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&gt;=12?hour:hour+12;}</span>}</span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&gt;=0&amp;&amp;hour&lt;6){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;17){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;20){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span>,week:{dow:0,// Sunday is the first day of the week.</span>
doy:6// The week that contains Jan 6th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('ms-my',{months:'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),monthsShort:'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),weekdays:'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),weekdaysShort:'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),weekdaysMin:'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),longDateFormat:{LT:'HH.mm',LTS:'HH.mm.ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY [pukul] HH.mm',LLLL:'dddd, D MMMM YYYY [pukul] HH.mm'},meridiemParse:/pagi|tengahari|petang|malam/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem==='pagi'){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem==='tengahari'){<span class="cstat-no" title="statement not covered" >return hour&gt;=11?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem==='petang'||meridiem==='malam'){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hours,minutes,isLower){<span class="cstat-no" title="statement not covered" >if(hours&lt;11){<span class="cstat-no" title="statement not covered" >return'pagi';}</span>else <span class="cstat-no" title="statement not covered" >if(hours&lt;15){<span class="cstat-no" title="statement not covered" >return'tengahari';}</span>else <span class="cstat-no" title="statement not covered" >if(hours&lt;19){<span class="cstat-no" title="statement not covered" >return'petang';}</span>else{<span class="cstat-no" title="statement not covered" >return'malam';}</span>}</span></span></span>,calendar:{sameDay:'[Hari ini pukul] LT',nextDay:'[Esok pukul] LT',nextWeek:'dddd [pukul] LT',lastDay:'[Kelmarin pukul] LT',lastWeek:'dddd [lepas pukul] LT',sameElse:'L'},relativeTime:{future:'dalam %s',past:'%s yang lepas',s:'beberapa saat',ss:'%d saat',m:'seminit',mm:'%d minit',h:'sejam',hh:'%d jam',d:'sehari',dd:'%d hari',M:'sebulan',MM:'%d bulan',y:'setahun',yy:'%d tahun'},week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('ms',{months:'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),monthsShort:'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),weekdays:'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),weekdaysShort:'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),weekdaysMin:'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),longDateFormat:{LT:'HH.mm',LTS:'HH.mm.ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY [pukul] HH.mm',LLLL:'dddd, D MMMM YYYY [pukul] HH.mm'},meridiemParse:/pagi|tengahari|petang|malam/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem==='pagi'){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem==='tengahari'){<span class="cstat-no" title="statement not covered" >return hour&gt;=11?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem==='petang'||meridiem==='malam'){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hours,minutes,isLower){<span class="cstat-no" title="statement not covered" >if(hours&lt;11){<span class="cstat-no" title="statement not covered" >return'pagi';}</span>else <span class="cstat-no" title="statement not covered" >if(hours&lt;15){<span class="cstat-no" title="statement not covered" >return'tengahari';}</span>else <span class="cstat-no" title="statement not covered" >if(hours&lt;19){<span class="cstat-no" title="statement not covered" >return'petang';}</span>else{<span class="cstat-no" title="statement not covered" >return'malam';}</span>}</span></span></span>,calendar:{sameDay:'[Hari ini pukul] LT',nextDay:'[Esok pukul] LT',nextWeek:'dddd [pukul] LT',lastDay:'[Kelmarin pukul] LT',lastWeek:'dddd [lepas pukul] LT',sameElse:'L'},relativeTime:{future:'dalam %s',past:'%s yang lepas',s:'beberapa saat',ss:'%d saat',m:'seminit',mm:'%d minit',h:'sejam',hh:'%d jam',d:'sehari',dd:'%d hari',M:'sebulan',MM:'%d bulan',y:'setahun',yy:'%d tahun'},week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('mt',{months:'Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru'.split('_'),monthsShort:'Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di'.split('_'),weekdays:'Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt'.split('_'),weekdaysShort:'ad_Tne_Tli_Erb_am_im_Sib'.split('_'),weekdaysMin:'a_Tn_Tl_Er_a_i_Si'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[Illum fil-]LT',nextDay:'[Gada fil-]LT',nextWeek:'dddd [fil-]LT',lastDay:'[Il-biera fil-]LT',lastWeek:'dddd [li gadda] [fil-]LT',sameElse:'L'},relativeTime:{future:'f %s',past:'%s ilu',s:'ftit sekondi',ss:'%d sekondi',m:'minuta',mm:'%d minuti',h:'siega',hh:'%d siegat',d:'urnata',dd:'%d ranet',M:'xahar',MM:'%d xhur',y:'sena',yy:'%d sni'},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var symbolMap$d=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap$c=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('my',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},calendar:{sameDay:'[.] LT []',nextDay:'[] LT []',nextWeek:'dddd LT []',lastDay:'[.] LT []',lastWeek:'[] dddd LT []',sameElse:'L'},relativeTime:{future:' %s ',past:' %s ',s:'.',ss:'%d ',m:'',mm:'%d ',h:'',hh:'%d ',d:'',dd:'%d ',M:'',MM:'%d ',y:'',yy:'%d '},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap$c[match];}</span>);}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$d[match];}</span>);}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('nb',{months:'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),monthsShort:'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),monthsParseExact:true,weekdays:'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),weekdaysShort:'s._ma._ti._on._to._fr._l.'.split('_'),weekdaysMin:'s_ma_ti_on_to_fr_l'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D. MMMM YYYY',LLL:'D. MMMM YYYY [kl.] HH:mm',LLLL:'dddd D. MMMM YYYY [kl.] HH:mm'},calendar:{sameDay:'[i dag kl.] LT',nextDay:'[i morgen kl.] LT',nextWeek:'dddd [kl.] LT',lastDay:'[i gr kl.] LT',lastWeek:'[forrige] dddd [kl.] LT',sameElse:'L'},relativeTime:{future:'om %s',past:'%s siden',s:'noen sekunder',ss:'%d sekunder',m:'ett minutt',mm:'%d minutter',h:'en time',hh:'%d timer',d:'en dag',dd:'%d dager',w:'en uke',ww:'%d uker',M:'en mned',MM:'%d mneder',y:'ett r',yy:'%d r'},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var symbolMap$e=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap$d=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('ne',{months:'___________'.split('_'),monthsShort:'._.__.___._._._._._.'.split('_'),monthsParseExact:true,weekdays:'______'.split('_'),weekdaysShort:'._._._._._._.'.split('_'),weekdaysMin:'._._._._._._.'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'A h:mm ',LTS:'A h:mm:ss ',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY, A h:mm ',LLLL:'dddd, D MMMM YYYY, A h:mm '},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap$d[match];}</span>);}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$e[match];}</span>);}</span>,meridiemParse:/|||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&lt;4?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&gt;=10?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;3){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;16){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;20){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span>,calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'[] dddd[,] LT',lastDay:'[] LT',lastWeek:'[] dddd[,] LT',sameElse:'L'},relativeTime:{future:'%s',past:'%s ',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},week:{dow:0,// Sunday is the first day of the week.</span>
doy:6// The week that contains Jan 6th is the first week of the year.
}});//! moment.js locale configuration
var monthsShortWithDots$1=<span class="cstat-no" title="statement not covered" >'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),</span>monthsShortWithoutDots$1=<span class="cstat-no" title="statement not covered" >'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_'),</span>monthsParse$8=<span class="cstat-no" title="statement not covered" >[/^jan/i,/^feb/i,/^maart|mrt.?$/i,/^apr/i,/^mei$/i,/^jun[i.]?$/i,/^jul[i.]?$/i,/^aug/i,/^sep/i,/^okt/i,/^nov/i,/^dec/i],</span>monthsRegex$8=<span class="cstat-no" title="statement not covered" >/^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('nl-be',{months:'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),monthsShort:<span class="fstat-no" title="function not covered" >fu</span>nction(m,format){<span class="cstat-no" title="statement not covered" >if(!m){<span class="cstat-no" title="statement not covered" >return monthsShortWithDots$1;}</span>else <span class="cstat-no" title="statement not covered" >if(/-MMM-/.test(format)){<span class="cstat-no" title="statement not covered" >return monthsShortWithoutDots$1[m.month()];}</span>else{<span class="cstat-no" title="statement not covered" >return monthsShortWithDots$1[m.month()];}</span>}</span></span>,monthsRegex:monthsRegex$8,monthsShortRegex:monthsRegex$8,monthsStrictRegex:/^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,monthsShortStrictRegex:/^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,monthsParse:monthsParse$8,longMonthsParse:monthsParse$8,shortMonthsParse:monthsParse$8,weekdays:'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),weekdaysShort:'zo._ma._di._wo._do._vr._za.'.split('_'),weekdaysMin:'zo_ma_di_wo_do_vr_za'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},calendar:{sameDay:'[vandaag om] LT',nextDay:'[morgen om] LT',nextWeek:'dddd [om] LT',lastDay:'[gisteren om] LT',lastWeek:'[afgelopen] dddd [om] LT',sameElse:'L'},relativeTime:{future:'over %s',past:'%s geleden',s:'een paar seconden',ss:'%d seconden',m:'n minuut',mm:'%d minuten',h:'n uur',hh:'%d uur',d:'n dag',dd:'%d dagen',M:'n maand',MM:'%d maanden',y:'n jaar',yy:'%d jaar'},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >return number+(number===1||number===8||number&gt;=20?'ste':'de');}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var monthsShortWithDots$2=<span class="cstat-no" title="statement not covered" >'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),</span>monthsShortWithoutDots$2=<span class="cstat-no" title="statement not covered" >'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_'),</span>monthsParse$9=<span class="cstat-no" title="statement not covered" >[/^jan/i,/^feb/i,/^maart|mrt.?$/i,/^apr/i,/^mei$/i,/^jun[i.]?$/i,/^jul[i.]?$/i,/^aug/i,/^sep/i,/^okt/i,/^nov/i,/^dec/i],</span>monthsRegex$9=<span class="cstat-no" title="statement not covered" >/^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('nl',{months:'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),monthsShort:<span class="fstat-no" title="function not covered" >fu</span>nction(m,format){<span class="cstat-no" title="statement not covered" >if(!m){<span class="cstat-no" title="statement not covered" >return monthsShortWithDots$2;}</span>else <span class="cstat-no" title="statement not covered" >if(/-MMM-/.test(format)){<span class="cstat-no" title="statement not covered" >return monthsShortWithoutDots$2[m.month()];}</span>else{<span class="cstat-no" title="statement not covered" >return monthsShortWithDots$2[m.month()];}</span>}</span></span>,monthsRegex:monthsRegex$9,monthsShortRegex:monthsRegex$9,monthsStrictRegex:/^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,monthsShortStrictRegex:/^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,monthsParse:monthsParse$9,longMonthsParse:monthsParse$9,shortMonthsParse:monthsParse$9,weekdays:'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),weekdaysShort:'zo._ma._di._wo._do._vr._za.'.split('_'),weekdaysMin:'zo_ma_di_wo_do_vr_za'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD-MM-YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},calendar:{sameDay:'[vandaag om] LT',nextDay:'[morgen om] LT',nextWeek:'dddd [om] LT',lastDay:'[gisteren om] LT',lastWeek:'[afgelopen] dddd [om] LT',sameElse:'L'},relativeTime:{future:'over %s',past:'%s geleden',s:'een paar seconden',ss:'%d seconden',m:'n minuut',mm:'%d minuten',h:'n uur',hh:'%d uur',d:'n dag',dd:'%d dagen',w:'n week',ww:'%d weken',M:'n maand',MM:'%d maanden',y:'n jaar',yy:'%d jaar'},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >return number+(number===1||number===8||number&gt;=20?'ste':'de');}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('nn',{months:'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),monthsShort:'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),monthsParseExact:true,weekdays:'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),weekdaysShort:'su._m._ty._on._to._fr._lau.'.split('_'),weekdaysMin:'su_m_ty_on_to_fr_la'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D. MMMM YYYY',LLL:'D. MMMM YYYY [kl.] H:mm',LLLL:'dddd D. MMMM YYYY [kl.] HH:mm'},calendar:{sameDay:'[I dag klokka] LT',nextDay:'[I morgon klokka] LT',nextWeek:'dddd [klokka] LT',lastDay:'[I gr klokka] LT',lastWeek:'[Fregande] dddd [klokka] LT',sameElse:'L'},relativeTime:{future:'om %s',past:'%s sidan',s:'nokre sekund',ss:'%d sekund',m:'eit minutt',mm:'%d minutt',h:'ein time',hh:'%d timar',d:'ein dag',dd:'%d dagar',w:'ei veke',ww:'%d veker',M:'ein mnad',MM:'%d mnader',y:'eit r',yy:'%d r'},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('oc-lnc',{months:{standalone:'genir_febrir_mar_abril_mai_junh_julhet_agost_setembre_octbre_novembre_decembre'.split('_'),format:"de genir_de febrir_de mar_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octbre_de novembre_de decembre".split('_'),isFormat:/D[oD]?(\s)+MMMM/},monthsShort:'gen._febr._mar_abr._mai_junh_julh._ago._set._oct._nov._dec.'.split('_'),monthsParseExact:true,weekdays:'dimenge_diluns_dimars_dimcres_dijus_divendres_dissabte'.split('_'),weekdaysShort:'dg._dl._dm._dc._dj._dv._ds.'.split('_'),weekdaysMin:'dg_dl_dm_dc_dj_dv_ds'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM [de] YYYY',ll:'D MMM YYYY',LLL:'D MMMM [de] YYYY [a] H:mm',lll:'D MMM YYYY, H:mm',LLLL:'dddd D MMMM [de] YYYY [a] H:mm',llll:'ddd D MMM YYYY, H:mm'},calendar:{sameDay:'[ui a] LT',nextDay:'[deman a] LT',nextWeek:'dddd [a] LT',lastDay:'[ir a] LT',lastWeek:'dddd [passat a] LT',sameElse:'L'},relativeTime:{future:"d'aqu %s",past:'fa %s',s:'unas segondas',ss:'%d segondas',m:'una minuta',mm:'%d minutas',h:'una ora',hh:'%d oras',d:'un jorn',dd:'%d jorns',M:'un mes',MM:'%d meses',y:'un an',yy:'%d ans'},dayOfMonthOrdinalParse:/\d{1,2}(r|n|t||a)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){var output=<span class="cstat-no" title="statement not covered" >number===1?'r':number===2?'n':number===3?'r':number===4?'t':'';<span class="cstat-no" title="statement not covered" ></span>if(period==='w'||period==='W'){<span class="cstat-no" title="statement not covered" >output='a';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn number+output;}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4}});//! moment.js locale configuration
var symbolMap$f=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap$e=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('pa-in',{// There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.</span>
months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'A h:mm ',LTS:'A h:mm:ss ',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY, A h:mm ',LLLL:'dddd, D MMMM YYYY, A h:mm '},calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'[] dddd, LT',lastDay:'[] LT',lastWeek:'[] dddd, LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap$e[match];}</span>);}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$f[match];}</span>);}</span>,// Punjabi notation for meridiems are quite fuzzy in practice. While there exists
// a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
meridiemParse:/|||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&lt;4?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&gt;=10?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;10){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;17){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;20){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span>,week:{dow:0,// Sunday is the first day of the week.
doy:6// The week that contains Jan 6th is the first week of the year.
}});//! moment.js locale configuration
var monthsNominative=<span class="cstat-no" title="statement not covered" >'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),</span>monthsSubjective=<span class="cstat-no" title="statement not covered" >'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_'),</span>monthsParse$a=<span class="cstat-no" title="statement not covered" >[/^sty/i,/^lut/i,/^mar/i,/^kwi/i,/^maj/i,/^cze/i,/^lip/i,/^sie/i,/^wrz/i,/^pa/i,/^lis/i,/^gru/i];</span>function <span class="fstat-no" title="function not covered" >plural$3(</span>n){<span class="cstat-no" title="statement not covered" >return n%10&lt;5&amp;&amp;n%10&gt;1&amp;&amp;~~(n/10)%10!==1;}</span>function <span class="fstat-no" title="function not covered" >translate$8(</span>number,withoutSuffix,key){var result=<span class="cstat-no" title="statement not covered" >number+' ';<span class="cstat-no" title="statement not covered" ></span>switch(key){case'ss':<span class="cstat-no" title="statement not covered" >return result+(plural$3(number)?'sekundy':'sekund');c</span>ase'm':<span class="cstat-no" title="statement not covered" >return withoutSuffix?'minuta':'minut';c</span>ase'mm':<span class="cstat-no" title="statement not covered" >return result+(plural$3(number)?'minuty':'minut');c</span>ase'h':<span class="cstat-no" title="statement not covered" >return withoutSuffix?'godzina':'godzin';c</span>ase'hh':<span class="cstat-no" title="statement not covered" >return result+(plural$3(number)?'godziny':'godzin');c</span>ase'ww':<span class="cstat-no" title="statement not covered" >return result+(plural$3(number)?'tygodnie':'tygodni');c</span>ase'MM':<span class="cstat-no" title="statement not covered" >return result+(plural$3(number)?'miesice':'miesicy');c</span>ase'yy':<span class="cstat-no" title="statement not covered" >return result+(plural$3(number)?'lata':'lat');}</span>}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('pl',{months:<span class="fstat-no" title="function not covered" >fu</span>nction(momentToFormat,format){<span class="cstat-no" title="statement not covered" >if(!momentToFormat){<span class="cstat-no" title="statement not covered" >return monthsNominative;}</span>else <span class="cstat-no" title="statement not covered" >if(/D MMMM/.test(format)){<span class="cstat-no" title="statement not covered" >return monthsSubjective[momentToFormat.month()];}</span>else{<span class="cstat-no" title="statement not covered" >return monthsNominative[momentToFormat.month()];}</span>}</span></span>,monthsShort:'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),monthsParse:monthsParse$a,longMonthsParse:monthsParse$a,shortMonthsParse:monthsParse$a,weekdays:'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),weekdaysShort:'ndz_pon_wt_r_czw_pt_sob'.split('_'),weekdaysMin:'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[Dzi o] LT',nextDay:'[Jutro o] LT',nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[W niedziel o] LT';c</span>ase 2:<span class="cstat-no" title="statement not covered" >return'[We wtorek o] LT';c</span>ase 3:<span class="cstat-no" title="statement not covered" >return'[W rod o] LT';c</span>ase 6:<span class="cstat-no" title="statement not covered" >return'[W sobot o] LT';d</span>efault:<span class="cstat-no" title="statement not covered" >return'[W] dddd [o] LT';}</span>}</span>,lastDay:'[Wczoraj o] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[W zesz niedziel o] LT';c</span>ase 3:<span class="cstat-no" title="statement not covered" >return'[W zesz rod o] LT';c</span>ase 6:<span class="cstat-no" title="statement not covered" >return'[W zesz sobot o] LT';d</span>efault:<span class="cstat-no" title="statement not covered" >return'[W zeszy] dddd [o] LT';}</span>}</span>,sameElse:'L'},relativeTime:{future:'za %s',past:'%s temu',s:'kilka sekund',ss:translate$8,m:translate$8,mm:translate$8,h:translate$8,hh:translate$8,d:'1 dzie',dd:'%d dni',w:'tydzie',ww:translate$8,M:'miesic',MM:translate$8,y:'rok',yy:translate$8},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('pt-br',{months:'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),monthsShort:'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),weekdays:'domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado'.split('_'),weekdaysShort:'dom_seg_ter_qua_qui_sex_sb'.split('_'),weekdaysMin:'do_2_3_4_5_6_s'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D [de] MMMM [de] YYYY',LLL:'D [de] MMMM [de] YYYY [s] HH:mm',LLLL:'dddd, D [de] MMMM [de] YYYY [s] HH:mm'},calendar:{sameDay:'[Hoje s] LT',nextDay:'[Amanh s] LT',nextWeek:'dddd [s] LT',lastDay:'[Ontem s] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.day()===0||this.day()===6?'[ltimo] dddd [s] LT'// Saturday + Sunday</span></span>
:'[ltima] dddd [s] LT';// Monday - Friday
},sameElse:'L'},relativeTime:{future:'em %s',past:'h %s',s:'poucos segundos',ss:'%d segundos',m:'um minuto',mm:'%d minutos',h:'uma hora',hh:'%d horas',d:'um dia',dd:'%d dias',M:'um ms',MM:'%d meses',y:'um ano',yy:'%d anos'},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',invalidDate:'Data invlida'});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('pt',{months:'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),monthsShort:'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),weekdays:'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),weekdaysShort:'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),weekdaysMin:'Do_2_3_4_5_6_S'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D [de] MMMM [de] YYYY',LLL:'D [de] MMMM [de] YYYY HH:mm',LLLL:'dddd, D [de] MMMM [de] YYYY HH:mm'},calendar:{sameDay:'[Hoje s] LT',nextDay:'[Amanh s] LT',nextWeek:'dddd [s] LT',lastDay:'[Ontem s] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.day()===0||this.day()===6?'[ltimo] dddd [s] LT'// Saturday + Sunday</span></span>
:'[ltima] dddd [s] LT';// Monday - Friday
},sameElse:'L'},relativeTime:{future:'em %s',past:'h %s',s:'segundos',ss:'%d segundos',m:'um minuto',mm:'%d minutos',h:'uma hora',hh:'%d horas',d:'um dia',dd:'%d dias',w:'uma semana',ww:'%d semanas',M:'um ms',MM:'%d meses',y:'um ano',yy:'%d anos'},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',week:{dow:1,// Monday is the first day of the week.
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >relativeTimeWithPlural$2(</span>number,withoutSuffix,key){var format=<span class="cstat-no" title="statement not covered" >{ss:'secunde',mm:'minute',hh:'ore',dd:'zile',ww:'sptmni',MM:'luni',yy:'ani'},</span>separator=<span class="cstat-no" title="statement not covered" >' ';<span class="cstat-no" title="statement not covered" ></span>if(number%100&gt;=20||number&gt;=100&amp;&amp;number%100===0){<span class="cstat-no" title="statement not covered" >separator=' de ';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn number+separator+format[key];}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('ro',{months:'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),monthsShort:'ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),monthsParseExact:true,weekdays:'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),weekdaysShort:'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),weekdaysMin:'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY H:mm',LLLL:'dddd, D MMMM YYYY H:mm'},calendar:{sameDay:'[azi la] LT',nextDay:'[mine la] LT',nextWeek:'dddd [la] LT',lastDay:'[ieri la] LT',lastWeek:'[fosta] dddd [la] LT',sameElse:'L'},relativeTime:{future:'peste %s',past:'%s n urm',s:'cteva secunde',ss:relativeTimeWithPlural$2,m:'un minut',mm:relativeTimeWithPlural$2,h:'o or',hh:relativeTimeWithPlural$2,d:'o zi',dd:relativeTimeWithPlural$2,w:'o sptmn',ww:relativeTimeWithPlural$2,M:'o lun',MM:relativeTimeWithPlural$2,y:'un an',yy:relativeTimeWithPlural$2},week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >plural$4(</span>word,num){var forms=<span class="cstat-no" title="statement not covered" >word.split('_');<span class="cstat-no" title="statement not covered" ></span>return num%10===1&amp;&amp;num%100!==11?forms[0]:num%10&gt;=2&amp;&amp;num%10&lt;=4&amp;&amp;(num%100&lt;10||num%100&gt;=20)?forms[1]:forms[2];}</span>function <span class="fstat-no" title="function not covered" >relativeTimeWithPlural$3(</span>number,withoutSuffix,key){var format=<span class="cstat-no" title="statement not covered" >{ss:withoutSuffix?'__':'__',mm:withoutSuffix?'__':'__',hh:'__',dd:'__',ww:'__',MM:'__',yy:'__'};<span class="cstat-no" title="statement not covered" ></span>if(key==='m'){<span class="cstat-no" title="statement not covered" >return withoutSuffix?'':'';}</span>else{<span class="cstat-no" title="statement not covered" >return number+' '+plural$4(format[key],+number);}</span>}</span>var monthsParse$b=<span class="cstat-no" title="statement not covered" >[/^/i,/^/i,/^/i,/^/i,/^[]/i,/^/i,/^/i,/^/i,/^/i,/^/i,/^/i,/^/i];</span>// http://new.gramota.ru/spravka/rules/139-prop :  103
//  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
// CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('ru',{months:{format:'___________'.split('_'),standalone:'___________'.split('_')},monthsShort:{//  CLDR  "."  ".",       ?</span>
format:'._._._.____._._._._.'.split('_'),standalone:'._.__.____._._._._.'.split('_')},weekdays:{standalone:'______'.split('_'),format:'______'.split('_'),isFormat:/\[ ?[] ?(?:||)? ?] ?dddd/},weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),monthsParse:monthsParse$b,longMonthsParse:monthsParse$b,shortMonthsParse:monthsParse$b,//    ,   ,  ,  4 ,      
monthsRegex:/^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,//  
monthsShortRegex:/^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,//    
monthsStrictRegex:/^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,// ,     
monthsShortStrictRegex:/^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY .',LLL:'D MMMM YYYY ., H:mm',LLLL:'dddd, D MMMM YYYY ., H:mm'},calendar:{sameDay:'[, ] LT',nextDay:'[, ] LT',lastDay:'[, ] LT',nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(now){<span class="cstat-no" title="statement not covered" >if(now.week()!==this.week()){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[ ] dddd, [] LT';c</span>ase 1:case 2:case 4:<span class="cstat-no" title="statement not covered" >return'[ ] dddd, [] LT';c</span>ase 3:case 5:case 6:<span class="cstat-no" title="statement not covered" >return'[ ] dddd, [] LT';}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(this.day()===2){<span class="cstat-no" title="statement not covered" >return'[] dddd, [] LT';}</span>else{<span class="cstat-no" title="statement not covered" >return'[] dddd, [] LT';}</span>}</span>}</span>,lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(now){<span class="cstat-no" title="statement not covered" >if(now.week()!==this.week()){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[ ] dddd, [] LT';c</span>ase 1:case 2:case 4:<span class="cstat-no" title="statement not covered" >return'[ ] dddd, [] LT';c</span>ase 3:case 5:case 6:<span class="cstat-no" title="statement not covered" >return'[ ] dddd, [] LT';}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(this.day()===2){<span class="cstat-no" title="statement not covered" >return'[] dddd, [] LT';}</span>else{<span class="cstat-no" title="statement not covered" >return'[] dddd, [] LT';}</span>}</span>}</span>,sameElse:'L'},relativeTime:{future:' %s',past:'%s ',s:' ',ss:relativeTimeWithPlural$3,m:relativeTimeWithPlural$3,mm:relativeTimeWithPlural$3,h:'',hh:relativeTimeWithPlural$3,d:'',dd:relativeTimeWithPlural$3,w:'',ww:relativeTimeWithPlural$3,M:'',MM:relativeTimeWithPlural$3,y:'',yy:relativeTimeWithPlural$3},meridiemParse:/|||/i,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return /^(|)$/.test(input);}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;17){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span>,dayOfMonthOrdinalParse:/\d{1,2}-(||)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){case'M':case'd':case'DDD':<span class="cstat-no" title="statement not covered" >return number+'-';c</span>ase'D':<span class="cstat-no" title="statement not covered" >return number+'-';c</span>ase'w':case'W':<span class="cstat-no" title="statement not covered" >return number+'-';d</span>efault:<span class="cstat-no" title="statement not covered" >return number;}</span>}</span>,week:{dow:1,// Monday is the first day of the week.
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var months$9=<span class="cstat-no" title="statement not covered" >['','','','','','','','','','','',''],</span>days$1=<span class="cstat-no" title="statement not covered" >['','','','','','',''];<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('sd',{months:months$9,monthsShort:months$9,weekdays:days$1,weekdaysShort:days$1,weekdaysMin:days$1,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},meridiemParse:/|/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return''===input;}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn'';}</span>,calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'dddd [  ] LT',lastDay:'[] LT',lastWeek:'[ ] dddd [] LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(//g,',');}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/,/g,'');}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('se',{months:'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),monthsShort:'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),weekdays:'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),weekdaysShort:'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),weekdaysMin:'s_v_m_g_d_b_L'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'MMMM D. [b.] YYYY',LLL:'MMMM D. [b.] YYYY [ti.] HH:mm',LLLL:'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'},calendar:{sameDay:'[otne ti] LT',nextDay:'[ihttin ti] LT',nextWeek:'dddd [ti] LT',lastDay:'[ikte ti] LT',lastWeek:'[ovddit] dddd [ti] LT',sameElse:'L'},relativeTime:{future:'%s geaes',past:'mait %s',s:'moadde sekunddat',ss:'%d sekunddat',m:'okta minuhta',mm:'%d minuhtat',h:'okta diimmu',hh:'%d diimmut',d:'okta beaivi',dd:'%d beaivvit',M:'okta mnnu',MM:'%d mnut',y:'okta jahki',yy:'%d jagit'},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
/*jshint -W100*/<span class="cstat-no" title="statement not covered" >hooks.defineLocale('si',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'a h:mm',LTS:'a h:mm:ss',L:'YYYY/MM/DD',LL:'YYYY MMMM D',LLL:'YYYY MMMM D, a h:mm',LLLL:'YYYY MMMM D [] dddd, a h:mm:ss'},calendar:{sameDay:'[] LT[]',nextDay:'[] LT[]',nextWeek:'dddd LT[]',lastDay:'[] LT[]',lastWeek:'[] dddd LT[]',sameElse:'L'},relativeTime:{future:'%s',past:'%s ',s:' ',ss:' %d',m:'',mm:' %d',h:'',hh:' %d',d:'',dd:' %d',M:'',MM:' %d',y:'',yy:' %d'},dayOfMonthOrdinalParse:/\d{1,2} /,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >return number+' ';}</span>,meridiemParse:/ | |.|../,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return input==='..'||input===' ';}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hours,minutes,isLower){<span class="cstat-no" title="statement not covered" >if(hours&gt;11){<span class="cstat-no" title="statement not covered" >return isLower?'..':' ';}</span>else{<span class="cstat-no" title="statement not covered" >return isLower?'..':' ';}</span>}</span>});/</span>/! moment.js locale configuration
var months$a=<span class="cstat-no" title="statement not covered" >'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),</span>monthsShort$7=<span class="cstat-no" title="statement not covered" >'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');</span>function <span class="fstat-no" title="function not covered" >plural$5(</span>n){<span class="cstat-no" title="statement not covered" >return n&gt;1&amp;&amp;n&lt;5;}</span>function <span class="fstat-no" title="function not covered" >translate$9(</span>number,withoutSuffix,key,isFuture){var result=<span class="cstat-no" title="statement not covered" >number+' ';<span class="cstat-no" title="statement not covered" ></span>switch(key){case's':// a few seconds / in a few seconds / a few seconds ago</span>
<span class="cstat-no" title="statement not covered" >return withoutSuffix||isFuture?'pr seknd':'pr sekundami';c</span>ase'ss':// 9 seconds / in 9 seconds / 9 seconds ago
<span class="cstat-no" title="statement not covered" >if(withoutSuffix||isFuture){<span class="cstat-no" title="statement not covered" >return result+(plural$5(number)?'sekundy':'seknd');}</span>else{<span class="cstat-no" title="statement not covered" >return result+'sekundami';}</span>c</span>ase'm':// a minute / in a minute / a minute ago
<span class="cstat-no" title="statement not covered" >return withoutSuffix?'minta':isFuture?'mintu':'mintou';c</span>ase'mm':// 9 minutes / in 9 minutes / 9 minutes ago
<span class="cstat-no" title="statement not covered" >if(withoutSuffix||isFuture){<span class="cstat-no" title="statement not covered" >return result+(plural$5(number)?'minty':'mint');}</span>else{<span class="cstat-no" title="statement not covered" >return result+'mintami';}</span>c</span>ase'h':// an hour / in an hour / an hour ago
<span class="cstat-no" title="statement not covered" >return withoutSuffix?'hodina':isFuture?'hodinu':'hodinou';c</span>ase'hh':// 9 hours / in 9 hours / 9 hours ago
<span class="cstat-no" title="statement not covered" >if(withoutSuffix||isFuture){<span class="cstat-no" title="statement not covered" >return result+(plural$5(number)?'hodiny':'hodn');}</span>else{<span class="cstat-no" title="statement not covered" >return result+'hodinami';}</span>c</span>ase'd':// a day / in a day / a day ago
<span class="cstat-no" title="statement not covered" >return withoutSuffix||isFuture?'de':'dom';c</span>ase'dd':// 9 days / in 9 days / 9 days ago
<span class="cstat-no" title="statement not covered" >if(withoutSuffix||isFuture){<span class="cstat-no" title="statement not covered" >return result+(plural$5(number)?'dni':'dn');}</span>else{<span class="cstat-no" title="statement not covered" >return result+'dami';}</span>c</span>ase'M':// a month / in a month / a month ago
<span class="cstat-no" title="statement not covered" >return withoutSuffix||isFuture?'mesiac':'mesiacom';c</span>ase'MM':// 9 months / in 9 months / 9 months ago
<span class="cstat-no" title="statement not covered" >if(withoutSuffix||isFuture){<span class="cstat-no" title="statement not covered" >return result+(plural$5(number)?'mesiace':'mesiacov');}</span>else{<span class="cstat-no" title="statement not covered" >return result+'mesiacmi';}</span>c</span>ase'y':// a year / in a year / a year ago
<span class="cstat-no" title="statement not covered" >return withoutSuffix||isFuture?'rok':'rokom';c</span>ase'yy':// 9 years / in 9 years / 9 years ago
<span class="cstat-no" title="statement not covered" >if(withoutSuffix||isFuture){<span class="cstat-no" title="statement not covered" >return result+(plural$5(number)?'roky':'rokov');}</span>else{<span class="cstat-no" title="statement not covered" >return result+'rokmi';}</span>}</span>}<span class="cstat-no" title="statement not covered" >hooks.defineLocale('sk',{months:months$a,monthsShort:monthsShort$7,weekdays:'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),weekdaysShort:'ne_po_ut_st_t_pi_so'.split('_'),weekdaysMin:'ne_po_ut_st_t_pi_so'.split('_'),longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD.MM.YYYY',LL:'D. MMMM YYYY',LLL:'D. MMMM YYYY H:mm',LLLL:'dddd D. MMMM YYYY H:mm'},calendar:{sameDay:'[dnes o] LT',nextDay:'[zajtra o] LT',nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[v nedeu o] LT';c</span>ase 1:case 2:<span class="cstat-no" title="statement not covered" >return'[v] dddd [o] LT';c</span>ase 3:<span class="cstat-no" title="statement not covered" >return'[v stredu o] LT';c</span>ase 4:<span class="cstat-no" title="statement not covered" >return'[vo tvrtok o] LT';c</span>ase 5:<span class="cstat-no" title="statement not covered" >return'[v piatok o] LT';c</span>ase 6:<span class="cstat-no" title="statement not covered" >return'[v sobotu o] LT';}</span>}</span>,lastDay:'[vera o] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[minul nedeu o] LT';c</span>ase 1:case 2:<span class="cstat-no" title="statement not covered" >return'[minul] dddd [o] LT';c</span>ase 3:<span class="cstat-no" title="statement not covered" >return'[minul stredu o] LT';c</span>ase 4:case 5:<span class="cstat-no" title="statement not covered" >return'[minul] dddd [o] LT';c</span>ase 6:<span class="cstat-no" title="statement not covered" >return'[minul sobotu o] LT';}</span>}</span>,sameElse:'L'},relativeTime:{future:'za %s',past:'pred %s',s:translate$9,ss:translate$9,m:translate$9,mm:translate$9,h:translate$9,hh:translate$9,d:translate$9,dd:translate$9,M:translate$9,MM:translate$9,y:translate$9,yy:translate$9},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >processRelativeTime$7(</span>number,withoutSuffix,key,isFuture){var result=<span class="cstat-no" title="statement not covered" >number+' ';<span class="cstat-no" title="statement not covered" ></span>switch(key){case's':<span class="cstat-no" title="statement not covered" >return withoutSuffix||isFuture?'nekaj sekund':'nekaj sekundami';c</span>ase'ss':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix?'sekundo':'sekundi';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'sekundi':'sekundah';}</span>else <span class="cstat-no" title="statement not covered" >if(number&lt;5){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'sekunde':'sekundah';}</span>else{<span class="cstat-no" title="statement not covered" >result+='sekund';}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn result;c</span>ase'm':<span class="cstat-no" title="statement not covered" >return withoutSuffix?'ena minuta':'eno minuto';c</span>ase'mm':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix?'minuta':'minuto';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'minuti':'minutama';}</span>else <span class="cstat-no" title="statement not covered" >if(number&lt;5){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'minute':'minutami';}</span>else{<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'minut':'minutami';}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn result;c</span>ase'h':<span class="cstat-no" title="statement not covered" >return withoutSuffix?'ena ura':'eno uro';c</span>ase'hh':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix?'ura':'uro';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'uri':'urama';}</span>else <span class="cstat-no" title="statement not covered" >if(number&lt;5){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'ure':'urami';}</span>else{<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'ur':'urami';}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn result;c</span>ase'd':<span class="cstat-no" title="statement not covered" >return withoutSuffix||isFuture?'en dan':'enim dnem';c</span>ase'dd':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'dan':'dnem';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'dni':'dnevoma';}</span>else{<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'dni':'dnevi';}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn result;c</span>ase'M':<span class="cstat-no" title="statement not covered" >return withoutSuffix||isFuture?'en mesec':'enim mesecem';c</span>ase'MM':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'mesec':'mesecem';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'meseca':'mesecema';}</span>else <span class="cstat-no" title="statement not covered" >if(number&lt;5){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'mesece':'meseci';}</span>else{<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'mesecev':'meseci';}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn result;c</span>ase'y':<span class="cstat-no" title="statement not covered" >return withoutSuffix||isFuture?'eno leto':'enim letom';c</span>ase'yy':<span class="cstat-no" title="statement not covered" >if(number===1){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'leto':'letom';}</span>else <span class="cstat-no" title="statement not covered" >if(number===2){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'leti':'letoma';}</span>else <span class="cstat-no" title="statement not covered" >if(number&lt;5){<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'leta':'leti';}</span>else{<span class="cstat-no" title="statement not covered" >result+=withoutSuffix||isFuture?'let':'leti';}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn result;}</span>}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('sl',{months:'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),monthsShort:'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),monthsParseExact:true,weekdays:'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),weekdaysShort:'ned._pon._tor._sre._et._pet._sob.'.split('_'),weekdaysMin:'ne_po_to_sr_e_pe_so'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD. MM. YYYY',LL:'D. MMMM YYYY',LLL:'D. MMMM YYYY H:mm',LLLL:'dddd, D. MMMM YYYY H:mm'},calendar:{sameDay:'[danes ob] LT',nextDay:'[jutri ob] LT',nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[v] [nedeljo] [ob] LT';c</span>ase 3:<span class="cstat-no" title="statement not covered" >return'[v] [sredo] [ob] LT';c</span>ase 6:<span class="cstat-no" title="statement not covered" >return'[v] [soboto] [ob] LT';c</span>ase 1:case 2:case 4:case 5:<span class="cstat-no" title="statement not covered" >return'[v] dddd [ob] LT';}</span>}</span>,lastDay:'[veraj ob] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[prejnjo] [nedeljo] [ob] LT';c</span>ase 3:<span class="cstat-no" title="statement not covered" >return'[prejnjo] [sredo] [ob] LT';c</span>ase 6:<span class="cstat-no" title="statement not covered" >return'[prejnjo] [soboto] [ob] LT';c</span>ase 1:case 2:case 4:case 5:<span class="cstat-no" title="statement not covered" >return'[prejnji] dddd [ob] LT';}</span>}</span>,sameElse:'L'},relativeTime:{future:'ez %s',past:'pred %s',s:processRelativeTime$7,ss:processRelativeTime$7,m:processRelativeTime$7,mm:processRelativeTime$7,h:processRelativeTime$7,hh:processRelativeTime$7,d:processRelativeTime$7,dd:processRelativeTime$7,M:processRelativeTime$7,MM:processRelativeTime$7,y:processRelativeTime$7,yy:processRelativeTime$7},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('sq',{months:'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),monthsShort:'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),weekdays:'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),weekdaysShort:'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),weekdaysMin:'D_H_Ma_M_E_P_Sh'.split('_'),weekdaysParseExact:true,meridiemParse:/PD|MD/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return input.charAt(0)==='M';}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hours,minutes,isLower){<span class="cstat-no" title="statement not covered" >return hours&lt;12?'PD':'MD';}</span>,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[Sot n] LT',nextDay:'[Nesr n] LT',nextWeek:'dddd [n] LT',lastDay:'[Dje n] LT',lastWeek:'dddd [e kaluar n] LT',sameElse:'L'},relativeTime:{future:'n %s',past:'%s m par',s:'disa sekonda',ss:'%d sekonda',m:'nj minut',mm:'%d minuta',h:'nj or',hh:'%d or',d:'nj dit',dd:'%d dit',M:'nj muaj',MM:'%d muaj',y:'nj vit',yy:'%d vite'},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var translator$1=<span class="cstat-no" title="statement not covered" >{words:{//Different grammatical cases</span>
ss:['','',''],m:[' ',' '],mm:['','',''],h:[' ',' '],hh:['','',''],dd:['','',''],MM:['','',''],yy:['','','']},correctGrammaticalCase:<span class="fstat-no" title="function not covered" >fu</span>nction(number,wordKey){<span class="cstat-no" title="statement not covered" >return number===1?wordKey[0]:number&gt;=2&amp;&amp;number&lt;=4?wordKey[1]:wordKey[2];}</span>,translate:<span class="fstat-no" title="function not covered" >fu</span>nction(number,withoutSuffix,key){var wordKey=<span class="cstat-no" title="statement not covered" >translator$1.words[key];<span class="cstat-no" title="statement not covered" ></span>if(key.length===1){<span class="cstat-no" title="statement not covered" >return withoutSuffix?wordKey[0]:wordKey[1];}</span>else{<span class="cstat-no" title="statement not covered" >return number+' '+translator$1.correctGrammaticalCase(number,wordKey);}</span>}</span>};<span class="cstat-no" title="statement not covered" >hooks.defineLocale('sr-cyrl',{months:'___________'.split('_'),monthsShort:'._._._.____._._._._.'.split('_'),monthsParseExact:true,weekdays:'______'.split('_'),weekdaysShort:'._._._._._._.'.split('_'),weekdaysMin:'______'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'D. M. YYYY.',LL:'D. MMMM YYYY.',LLL:'D. MMMM YYYY. H:mm',LLLL:'dddd, D. MMMM YYYY. H:mm'},calendar:{sameDay:'[ ] LT',nextDay:'[ ] LT',nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[] [] [] LT';c</span>ase 3:<span class="cstat-no" title="statement not covered" >return'[] [] [] LT';c</span>ase 6:<span class="cstat-no" title="statement not covered" >return'[] [] [] LT';c</span>ase 1:case 2:case 4:case 5:<span class="cstat-no" title="statement not covered" >return'[] dddd [] LT';}</span>}</span>,lastDay:'[ ] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){var lastWeekDays=<span class="cstat-no" title="statement not covered" >['[] [] [] LT','[] [] [] LT','[] [] [] LT','[] [] [] LT','[] [] [] LT','[] [] [] LT','[] [] [] LT'];<span class="cstat-no" title="statement not covered" ></span>return lastWeekDays[this.day()];}</span>,sameElse:'L'},relativeTime:{future:' %s',past:' %s',s:' ',ss:translator$1.translate,m:translator$1.translate,mm:translator$1.translate,h:translator$1.translate,hh:translator$1.translate,d:'',dd:translator$1.translate,M:'',MM:translator$1.translate,y:'',yy:translator$1.translate},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 1st is the first week of the year.
}});//! moment.js locale configuration
var translator$2=<span class="cstat-no" title="statement not covered" >{words:{//Different grammatical cases</span>
ss:['sekunda','sekunde','sekundi'],m:['jedan minut','jedne minute'],mm:['minut','minute','minuta'],h:['jedan sat','jednog sata'],hh:['sat','sata','sati'],dd:['dan','dana','dana'],MM:['mesec','meseca','meseci'],yy:['godina','godine','godina']},correctGrammaticalCase:<span class="fstat-no" title="function not covered" >fu</span>nction(number,wordKey){<span class="cstat-no" title="statement not covered" >return number===1?wordKey[0]:number&gt;=2&amp;&amp;number&lt;=4?wordKey[1]:wordKey[2];}</span>,translate:<span class="fstat-no" title="function not covered" >fu</span>nction(number,withoutSuffix,key){var wordKey=<span class="cstat-no" title="statement not covered" >translator$2.words[key];<span class="cstat-no" title="statement not covered" ></span>if(key.length===1){<span class="cstat-no" title="statement not covered" >return withoutSuffix?wordKey[0]:wordKey[1];}</span>else{<span class="cstat-no" title="statement not covered" >return number+' '+translator$2.correctGrammaticalCase(number,wordKey);}</span>}</span>};<span class="cstat-no" title="statement not covered" >hooks.defineLocale('sr',{months:'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),monthsShort:'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),monthsParseExact:true,weekdays:'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),weekdaysShort:'ned._pon._uto._sre._et._pet._sub.'.split('_'),weekdaysMin:'ne_po_ut_sr_e_pe_su'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'D. M. YYYY.',LL:'D. MMMM YYYY.',LLL:'D. MMMM YYYY. H:mm',LLLL:'dddd, D. MMMM YYYY. H:mm'},calendar:{sameDay:'[danas u] LT',nextDay:'[sutra u] LT',nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:<span class="cstat-no" title="statement not covered" >return'[u] [nedelju] [u] LT';c</span>ase 3:<span class="cstat-no" title="statement not covered" >return'[u] [sredu] [u] LT';c</span>ase 6:<span class="cstat-no" title="statement not covered" >return'[u] [subotu] [u] LT';c</span>ase 1:case 2:case 4:case 5:<span class="cstat-no" title="statement not covered" >return'[u] dddd [u] LT';}</span>}</span>,lastDay:'[jue u] LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){var lastWeekDays=<span class="cstat-no" title="statement not covered" >['[prole] [nedelje] [u] LT','[prolog] [ponedeljka] [u] LT','[prolog] [utorka] [u] LT','[prole] [srede] [u] LT','[prolog] [etvrtka] [u] LT','[prolog] [petka] [u] LT','[prole] [subote] [u] LT'];<span class="cstat-no" title="statement not covered" ></span>return lastWeekDays[this.day()];}</span>,sameElse:'L'},relativeTime:{future:'za %s',past:'pre %s',s:'nekoliko sekundi',ss:translator$2.translate,m:translator$2.translate,mm:translator$2.translate,h:translator$2.translate,hh:translator$2.translate,d:'dan',dd:translator$2.translate,M:'mesec',MM:translator$2.translate,y:'godinu',yy:translator$2.translate},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('ss',{months:"Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),monthsShort:'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),weekdays:'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),weekdaysShort:'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),weekdaysMin:'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'h:mm A',LTS:'h:mm:ss A',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY h:mm A',LLLL:'dddd, D MMMM YYYY h:mm A'},calendar:{sameDay:'[Namuhla nga] LT',nextDay:'[Kusasa nga] LT',nextWeek:'dddd [nga] LT',lastDay:'[Itolo nga] LT',lastWeek:'dddd [leliphelile] [nga] LT',sameElse:'L'},relativeTime:{future:'nga %s',past:'wenteka nga %s',s:'emizuzwana lomcane',ss:'%d mzuzwana',m:'umzuzu',mm:'%d emizuzu',h:'lihora',hh:'%d emahora',d:'lilanga',dd:'%d emalanga',M:'inyanga',MM:'%d tinyanga',y:'umnyaka',yy:'%d iminyaka'},meridiemParse:/ekuseni|emini|entsambama|ebusuku/,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hours,minutes,isLower){<span class="cstat-no" title="statement not covered" >if(hours&lt;11){<span class="cstat-no" title="statement not covered" >return'ekuseni';}</span>else <span class="cstat-no" title="statement not covered" >if(hours&lt;15){<span class="cstat-no" title="statement not covered" >return'emini';}</span>else <span class="cstat-no" title="statement not covered" >if(hours&lt;19){<span class="cstat-no" title="statement not covered" >return'entsambama';}</span>else{<span class="cstat-no" title="statement not covered" >return'ebusuku';}</span>}</span></span></span>,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem==='ekuseni'){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem==='emini'){<span class="cstat-no" title="statement not covered" >return hour&gt;=11?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem==='entsambama'||meridiem==='ebusuku'){<span class="cstat-no" title="statement not covered" >if(hour===0){<span class="cstat-no" title="statement not covered" >return 0;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn hour+12;}</span>}</span></span></span>,dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('sv',{months:'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),monthsShort:'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),weekdays:'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),weekdaysShort:'sn_mn_tis_ons_tor_fre_lr'.split('_'),weekdaysMin:'s_m_ti_on_to_fr_l'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'YYYY-MM-DD',LL:'D MMMM YYYY',LLL:'D MMMM YYYY [kl.] HH:mm',LLLL:'dddd D MMMM YYYY [kl.] HH:mm',lll:'D MMM YYYY HH:mm',llll:'ddd D MMM YYYY HH:mm'},calendar:{sameDay:'[Idag] LT',nextDay:'[Imorgon] LT',lastDay:'[Igr] LT',nextWeek:'[P] dddd LT',lastWeek:'[I] dddd[s] LT',sameElse:'L'},relativeTime:{future:'om %s',past:'fr %s sedan',s:'ngra sekunder',ss:'%d sekunder',m:'en minut',mm:'%d minuter',h:'en timme',hh:'%d timmar',d:'en dag',dd:'%d dagar',M:'en mnad',MM:'%d mnader',y:'ett r',yy:'%d r'},dayOfMonthOrdinalParse:/\d{1,2}(\:e|\:a)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var b=<span class="cstat-no" title="statement not covered" >number%10,</span>output=<span class="cstat-no" title="statement not covered" >~~(number%100/10)===1?':e':b===1?':a':b===2?':a':b===3?':e':':e';<span class="cstat-no" title="statement not covered" ></span>return number+output;}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('sw',{months:'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),monthsShort:'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),weekdays:'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),weekdaysShort:'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),weekdaysMin:'J2_J3_J4_J5_Al_Ij_J1'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'hh:mm A',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[leo saa] LT',nextDay:'[kesho saa] LT',nextWeek:'[wiki ijayo] dddd [saat] LT',lastDay:'[jana] LT',lastWeek:'[wiki iliyopita] dddd [saat] LT',sameElse:'L'},relativeTime:{future:'%s baadaye',past:'tokea %s',s:'hivi punde',ss:'sekunde %d',m:'dakika moja',mm:'dakika %d',h:'saa limoja',hh:'masaa %d',d:'siku moja',dd:'siku %d',M:'mwezi mmoja',MM:'miezi %d',y:'mwaka mmoja',yy:'miaka %d'},week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
var symbolMap$g=<span class="cstat-no" title="statement not covered" >{1:'',2:'',3:'',4:'',5:'',6:'',7:'',8:'',9:'',0:''},</span>numberMap$f=<span class="cstat-no" title="statement not covered" >{'':'1','':'2','':'3','':'4','':'5','':'6','':'7','':'8','':'9','':'0'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('ta',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY, HH:mm',LLLL:'dddd, D MMMM YYYY, HH:mm'},calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'dddd, LT',lastDay:'[] LT',lastWeek:'[ ] dddd, LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:'  ',ss:'%d ',m:' ',mm:'%d ',h:'  ',hh:'%d  ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >return number+'';}</span>,preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/[]/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return numberMap$f[match];}</span>);}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/\d/g,<span class="fstat-no" title="function not covered" >fu</span>nction(match){<span class="cstat-no" title="statement not covered" >return symbolMap$g[match];}</span>);}</span>,// refer http://ta.wikipedia.org/s/1er1</span>
meridiemParse:/|||||/,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;2){<span class="cstat-no" title="statement not covered" >return' ';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;6){<span class="cstat-no" title="statement not covered" >return' ';/</span>/ </span></span>
}else <span class="cstat-no" title="statement not covered" >if(hour&lt;10){<span class="cstat-no" title="statement not covered" >return' ';/</span>/ </span>
}else <span class="cstat-no" title="statement not covered" >if(hour&lt;14){<span class="cstat-no" title="statement not covered" >return' ';/</span>/ </span>
}else <span class="cstat-no" title="statement not covered" >if(hour&lt;18){<span class="cstat-no" title="statement not covered" >return' ';/</span>/ </span>
}else <span class="cstat-no" title="statement not covered" >if(hour&lt;22){<span class="cstat-no" title="statement not covered" >return' ';/</span>/ </span>
}else{<span class="cstat-no" title="statement not covered" >return' ';}</span>},meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&lt;2?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''||meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&gt;=10?hour:hour+12;}</span>else{<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span>,week:{dow:0,// Sunday is the first day of the week.
doy:6// The week that contains Jan 6th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('te',{months:'___________'.split('_'),monthsShort:'._.__.____._._._._.'.split('_'),monthsParseExact:true,weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'A h:mm',LTS:'A h:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY, A h:mm',LLLL:'dddd, D MMMM YYYY, A h:mm'},calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'dddd, LT',lastDay:'[] LT',lastWeek:'[] dddd, LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:'%d',meridiemParse:/|||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&lt;4?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&gt;=10?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;10){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;17){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;20){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span>,week:{dow:0,// Sunday is the first day of the week.</span>
doy:6// The week that contains Jan 6th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('tet',{months:'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),monthsShort:'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),weekdays:'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),weekdaysShort:'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),weekdaysMin:'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[Ohin iha] LT',nextDay:'[Aban iha] LT',nextWeek:'dddd [iha] LT',lastDay:'[Horiseik iha] LT',lastWeek:'dddd [semana kotuk] [iha] LT',sameElse:'L'},relativeTime:{future:'iha %s',past:'%s liuba',s:'segundu balun',ss:'segundu %d',m:'minutu ida',mm:'minutu %d',h:'oras ida',hh:'oras %d',d:'loron ida',dd:'loron %d',M:'fulan ida',MM:'fulan %d',y:'tinan ida',yy:'tinan %d'},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var b=<span class="cstat-no" title="statement not covered" >number%10,</span>output=<span class="cstat-no" title="statement not covered" >~~(number%100/10)===1?'th':b===1?'st':b===2?'nd':b===3?'rd':'th';<span class="cstat-no" title="statement not covered" ></span>return number+output;}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var suffixes$3=<span class="cstat-no" title="statement not covered" >{0:'-',1:'-',2:'-',3:'-',4:'-',5:'-',6:'-',7:'-',8:'-',9:'-',10:'-',12:'-',13:'-',20:'-',30:'-',40:'-',50:'-',60:'-',70:'-',80:'-',90:'-',100:'-'};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('tg',{months:{format:'___________'.split('_'),standalone:'___________'.split('_')},monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[ ] LT',nextDay:'[ ] LT',lastDay:'[ ] LT',nextWeek:'dddd[] [  ] LT',lastWeek:'dddd[] [  ] LT',sameElse:'L'},relativeTime:{future:' %s',past:'%s ',s:' ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},meridiemParse:/|||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&lt;4?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&gt;=11?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;11){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;16){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;19){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span>,dayOfMonthOrdinalParse:/\d{1,2}-(|)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var a=<span class="cstat-no" title="statement not covered" >number%10,</span>b=<span class="cstat-no" title="statement not covered" >number&gt;=100?100:null;<span class="cstat-no" title="statement not covered" ></span>return number+(suffixes$3[number]||suffixes$3[a]||suffixes$3[b]);}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 1th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('th',{months:'___________'.split('_'),monthsShort:'.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),monthsParseExact:true,weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),// yes, three characters difference</span>
weekdaysMin:'._._._._._._.'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'H:mm',LTS:'H:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY  H:mm',LLLL:'dddd D MMMM YYYY  H:mm'},meridiemParse:/|/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return input==='';}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span>,calendar:{sameDay:'[ ] LT',nextDay:'[ ] LT',nextWeek:'dddd[ ] LT',lastDay:'[ ] LT',lastWeek:'[]dddd[ ] LT',sameElse:'L'},relativeTime:{future:' %s',past:'%s',s:'',ss:'%d ',m:'1 ',mm:'%d ',h:'1 ',hh:'%d ',d:'1 ',dd:'%d ',w:'1 ',ww:'%d ',M:'1 ',MM:'%d ',y:'1 ',yy:'%d '}});//! moment.js locale configuration
var suffixes$4=<span class="cstat-no" title="statement not covered" >{1:"'inji",5:"'inji",8:"'inji",70:"'inji",80:"'inji",2:"'nji",7:"'nji",20:"'nji",50:"'nji",3:"'nji",4:"'nji",100:"'nji",6:"'njy",9:"'unjy",10:"'unjy",30:"'unjy",60:"'ynjy",90:"'ynjy"};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('tk',{months:'anwar_Fewral_Mart_Aprel_Ma_Iun_Iul_Awgust_Sentabr_Oktabr_Noabr_Dekabr'.split('_'),monthsShort:'an_Few_Mar_Apr_Ma_In_Il_Awg_Sen_Okt_No_Dek'.split('_'),weekdays:'ekenbe_Duenbe_Sienbe_arenbe_Penenbe_Anna_enbe'.split('_'),weekdaysShort:'ek_Du_Si_ar_Pen_Ann_en'.split('_'),weekdaysMin:'k_D_S_r_Pn_An_n'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[bugn sagat] LT',nextDay:'[ertir sagat] LT',nextWeek:'[indiki] dddd [sagat] LT',lastDay:'[dn] LT',lastWeek:'[geen] dddd [sagat] LT',sameElse:'L'},relativeTime:{future:'%s so',past:'%s ',s:'birne sekunt',m:'bir minut',mm:'%d minut',h:'bir sagat',hh:'%d sagat',d:'bir gn',dd:'%d gn',M:'bir a',MM:'%d a',y:'bir yl',yy:'%d yl'},ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){case'd':case'D':case'Do':case'DD':<span class="cstat-no" title="statement not covered" >return number;d</span>efault:<span class="cstat-no" title="statement not covered" >if(number===0){// special case for zero</span></span></span>
<span class="cstat-no" title="statement not covered" >return number+"'unjy";}</span>var a=<span class="cstat-no" title="statement not covered" >number%10,</span>b=<span class="cstat-no" title="statement not covered" >number%100-a,</span>c=<span class="cstat-no" title="statement not covered" >number&gt;=100?100:null;<span class="cstat-no" title="statement not covered" ></span>return number+(suffixes$4[a]||suffixes$4[b]||suffixes$4[c]);}</span>},week:{dow:1,// Monday is the first day of the week.
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('tl-ph',{months:'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),monthsShort:'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),weekdays:'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),weekdaysShort:'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),weekdaysMin:'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'MM/D/YYYY',LL:'MMMM D, YYYY',LLL:'MMMM D, YYYY HH:mm',LLLL:'dddd, MMMM DD, YYYY HH:mm'},calendar:{sameDay:'LT [ngayong araw]',nextDay:'[Bukas ng] LT',nextWeek:'LT [sa susunod na] dddd',lastDay:'LT [kahapon]',lastWeek:'LT [noong nakaraang] dddd',sameElse:'L'},relativeTime:{future:'sa loob ng %s',past:'%s ang nakalipas',s:'ilang segundo',ss:'%d segundo',m:'isang minuto',mm:'%d minuto',h:'isang oras',hh:'%d oras',d:'isang araw',dd:'%d araw',M:'isang buwan',MM:'%d buwan',y:'isang taon',yy:'%d taon'},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >return number;}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var numbersNouns=<span class="cstat-no" title="statement not covered" >'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');</span>function <span class="fstat-no" title="function not covered" >translateFuture(</span>output){var time=<span class="cstat-no" title="statement not covered" >output;<span class="cstat-no" title="statement not covered" ></span>time=output.indexOf('jaj')!==-1?time.slice(0,-3)+'leS':output.indexOf('jar')!==-1?time.slice(0,-3)+'waQ':output.indexOf('DIS')!==-1?time.slice(0,-3)+'nem':time+' pIq';<span class="cstat-no" title="statement not covered" >r</span>eturn time;}</span>function <span class="fstat-no" title="function not covered" >translatePast(</span>output){var time=<span class="cstat-no" title="statement not covered" >output;<span class="cstat-no" title="statement not covered" ></span>time=output.indexOf('jaj')!==-1?time.slice(0,-3)+'Hu':output.indexOf('jar')!==-1?time.slice(0,-3)+'wen':output.indexOf('DIS')!==-1?time.slice(0,-3)+'ben':time+' ret';<span class="cstat-no" title="statement not covered" >r</span>eturn time;}</span>function <span class="fstat-no" title="function not covered" >translate$a(</span>number,withoutSuffix,string,isFuture){var numberNoun=<span class="cstat-no" title="statement not covered" >numberAsNoun(number);<span class="cstat-no" title="statement not covered" ></span>switch(string){case'ss':<span class="cstat-no" title="statement not covered" >return numberNoun+' lup';c</span>ase'mm':<span class="cstat-no" title="statement not covered" >return numberNoun+' tup';c</span>ase'hh':<span class="cstat-no" title="statement not covered" >return numberNoun+' rep';c</span>ase'dd':<span class="cstat-no" title="statement not covered" >return numberNoun+' jaj';c</span>ase'MM':<span class="cstat-no" title="statement not covered" >return numberNoun+' jar';c</span>ase'yy':<span class="cstat-no" title="statement not covered" >return numberNoun+' DIS';}</span>}</span>function <span class="fstat-no" title="function not covered" >numberAsNoun(</span>number){var hundred=<span class="cstat-no" title="statement not covered" >Math.floor(number%1000/100),</span>ten=<span class="cstat-no" title="statement not covered" >Math.floor(number%100/10),</span>one=<span class="cstat-no" title="statement not covered" >number%10,</span>word=<span class="cstat-no" title="statement not covered" >'';<span class="cstat-no" title="statement not covered" ></span>if(hundred&gt;0){<span class="cstat-no" title="statement not covered" >word+=numbersNouns[hundred]+'vatlh';}<span class="cstat-no" title="statement not covered" ></span>i</span>f(ten&gt;0){<span class="cstat-no" title="statement not covered" >word+=(word!==''?' ':'')+numbersNouns[ten]+'maH';}<span class="cstat-no" title="statement not covered" ></span>i</span>f(one&gt;0){<span class="cstat-no" title="statement not covered" >word+=(word!==''?' ':'')+numbersNouns[one];}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn word===''?'pagh':word;}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('tlh',{months:'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),monthsShort:'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),monthsParseExact:true,weekdays:'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),weekdaysShort:'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),weekdaysMin:'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[DaHjaj] LT',nextDay:'[waleS] LT',nextWeek:'LLL',lastDay:'[waHu] LT',lastWeek:'LLL',sameElse:'L'},relativeTime:{future:translateFuture,past:translatePast,s:'puS lup',ss:translate$a,m:'wa tup',mm:translate$a,h:'wa rep',hh:translate$a,d:'wa jaj',dd:translate$a,M:'wa jar',MM:translate$a,y:'wa DIS',yy:translate$a},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
var suffixes$5=<span class="cstat-no" title="statement not covered" >{1:"'inci",5:"'inci",8:"'inci",70:"'inci",80:"'inci",2:"'nci",7:"'nci",20:"'nci",50:"'nci",3:"'nc",4:"'nc",100:"'nc",6:"'nc",9:"'uncu",10:"'uncu",30:"'uncu",60:"'nc",90:"'nc"};<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('tr',{months:'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),monthsShort:'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),weekdays:'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),weekdaysShort:'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),weekdaysMin:'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hours,minutes,isLower){<span class="cstat-no" title="statement not covered" >if(hours&lt;12){<span class="cstat-no" title="statement not covered" >return isLower?'':'';}</span>else{<span class="cstat-no" title="statement not covered" >return isLower?'s':'S';}</span>}</span>,meridiemParse:/||s|S/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return input==='s'||input==='S';}</span>,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[bugn saat] LT',nextDay:'[yarn saat] LT',nextWeek:'[gelecek] dddd [saat] LT',lastDay:'[dn] LT',lastWeek:'[geen] dddd [saat] LT',sameElse:'L'},relativeTime:{future:'%s sonra',past:'%s nce',s:'birka saniye',ss:'%d saniye',m:'bir dakika',mm:'%d dakika',h:'bir saat',hh:'%d saat',d:'bir gn',dd:'%d gn',w:'bir hafta',ww:'%d hafta',M:'bir ay',MM:'%d ay',y:'bir yl',yy:'%d yl'},ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){case'd':case'D':case'Do':case'DD':<span class="cstat-no" title="statement not covered" >return number;d</span>efault:<span class="cstat-no" title="statement not covered" >if(number===0){// special case for zero</span></span></span>
<span class="cstat-no" title="statement not covered" >return number+"'nc";}</span>var a=<span class="cstat-no" title="statement not covered" >number%10,</span>b=<span class="cstat-no" title="statement not covered" >number%100-a,</span>c=<span class="cstat-no" title="statement not covered" >number&gt;=100?100:null;<span class="cstat-no" title="statement not covered" ></span>return number+(suffixes$5[a]||suffixes$5[b]||suffixes$5[c]);}</span>},week:{dow:1,// Monday is the first day of the week.
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
// After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
// This is currently too difficult (maybe even impossible) to add.
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('tzl',{months:'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),monthsShort:'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),weekdays:'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),weekdaysShort:'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),weekdaysMin:'S_L_Ma_M_Xh_Vi_S'.split('_'),longDateFormat:{LT:'HH.mm',LTS:'HH.mm.ss',L:'DD.MM.YYYY',LL:'D. MMMM [dallas] YYYY',LLL:'D. MMMM [dallas] YYYY HH.mm',LLLL:'dddd, [li] D. MMMM [dallas] YYYY HH.mm'},meridiemParse:/d\'o|d\'a/i,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return"d'o"===input.toLowerCase();}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hours,minutes,isLower){<span class="cstat-no" title="statement not covered" >if(hours&gt;11){<span class="cstat-no" title="statement not covered" >return isLower?"d'o":"D'O";}</span>else{<span class="cstat-no" title="statement not covered" >return isLower?"d'a":"D'A";}</span>}</span>,calendar:{sameDay:'[oxhi ] LT',nextDay:'[dem ] LT',nextWeek:'dddd [] LT',lastDay:'[ieiri ] LT',lastWeek:'[sr el] dddd [lasteu ] LT',sameElse:'L'},relativeTime:{future:'osprei %s',past:'ja%s',s:processRelativeTime$8,ss:processRelativeTime$8,m:processRelativeTime$8,mm:processRelativeTime$8,h:processRelativeTime$8,hh:processRelativeTime$8,d:processRelativeTime$8,dd:processRelativeTime$8,M:processRelativeTime$8,MM:processRelativeTime$8,y:processRelativeTime$8,yy:processRelativeTime$8},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:'%d.',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});function <span class="fstat-no" title="function not covered" >processRelativeTime$8(</span>number,withoutSuffix,key,isFuture){var format=<span class="cstat-no" title="statement not covered" >{s:['viensas secunds',"'iensas secunds"],ss:[number+' secunds',''+number+' secunds'],m:["'n mut","'iens mut"],mm:[number+' muts',''+number+' muts'],h:["'n ora","'iensa ora"],hh:[number+' oras',''+number+' oras'],d:["'n ziua","'iensa ziua"],dd:[number+' ziuas',''+number+' ziuas'],M:["'n mes","'iens mes"],MM:[number+' mesen',''+number+' mesen'],y:["'n ar","'iens ar"],yy:[number+' ars',''+number+' ars']};<span class="cstat-no" title="statement not covered" ></span>return isFuture?format[key][0]:withoutSuffix?format[key][0]:format[key][1];}</span>//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('tzm-latn',{months:'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),monthsShort:'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),weekdays:'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),weekdaysShort:'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),weekdaysMin:'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},calendar:{sameDay:'[asdkh g] LT',nextDay:'[aska g] LT',nextWeek:'dddd [g] LT',lastDay:'[assant g] LT',lastWeek:'dddd [g] LT',sameElse:'L'},relativeTime:{future:'dadkh s yan %s',past:'yan %s',s:'imik',ss:'%d imik',m:'minu',mm:'%d minu',h:'saa',hh:'%d tassain',d:'ass',dd:'%d ossan',M:'ayowr',MM:'%d iyyirn',y:'asgas',yy:'%d isgasn'},week:{dow:6,// Saturday is the first day of the week.</span>
doy:12// The week that contains Jan 12th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('tzm',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},calendar:{sameDay:'[ ] LT',nextDay:'[ ] LT',nextWeek:'dddd [] LT',lastDay:'[ ] LT',lastWeek:'dddd [] LT',sameElse:'L'},relativeTime:{future:'   %s',past:' %s',s:'',ss:'%d ',m:'',mm:'%d ',h:'',hh:'%d ',d:'',dd:'%d o',M:'o',MM:'%d ',y:'',yy:'%d '},week:{dow:6,// Saturday is the first day of the week.</span>
doy:12// The week that contains Jan 12th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('ug-cn',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'YYYY-MM-DD',LL:'YYYY-M-D-',LLL:'YYYY-M-D- HH:mm',LLLL:'dddd YYYY-M-D- HH:mm'},meridiemParse:/ || || |/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===' '||meridiem===''||meridiem===' '){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===' '||meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>else{<span class="cstat-no" title="statement not covered" >return hour&gt;=11?hour:hour+12;}</span>}</span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){var hm=<span class="cstat-no" title="statement not covered" >hour*100+minute;<span class="cstat-no" title="statement not covered" ></span>if(hm&lt;600){<span class="cstat-no" title="statement not covered" >return' ';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;900){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;1130){<span class="cstat-no" title="statement not covered" >return' ';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;1230){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;1800){<span class="cstat-no" title="statement not covered" >return' ';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span></span>,calendar:{sameDay:'[ ] LT',nextDay:'[ ] LT',nextWeek:'[] dddd [] LT',lastDay:'[] LT',lastWeek:'[] dddd [] LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},dayOfMonthOrdinalParse:/\d{1,2}(-|-|-)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){case'd':case'D':case'DDD':<span class="cstat-no" title="statement not covered" >return number+'-';c</span>ase'w':case'W':<span class="cstat-no" title="statement not covered" >return number+'-';d</span>efault:<span class="cstat-no" title="statement not covered" >return number;}</span>}</span>,preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(//g,',');}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/,/g,'');}</span>,week:{// GB/T 7408-1994ISO 8601:1988</span>
dow:1,// Monday is the first day of the week.
doy:7// The week that contains Jan 1st is the first week of the year.
}});//! moment.js locale configuration
function <span class="fstat-no" title="function not covered" >plural$6(</span>word,num){var forms=<span class="cstat-no" title="statement not covered" >word.split('_');<span class="cstat-no" title="statement not covered" ></span>return num%10===1&amp;&amp;num%100!==11?forms[0]:num%10&gt;=2&amp;&amp;num%10&lt;=4&amp;&amp;(num%100&lt;10||num%100&gt;=20)?forms[1]:forms[2];}</span>function <span class="fstat-no" title="function not covered" >relativeTimeWithPlural$4(</span>number,withoutSuffix,key){var format=<span class="cstat-no" title="statement not covered" >{ss:withoutSuffix?'__':'__',mm:withoutSuffix?'__':'__',hh:withoutSuffix?'__':'__',dd:'__',MM:'__',yy:'__'};<span class="cstat-no" title="statement not covered" ></span>if(key==='m'){<span class="cstat-no" title="statement not covered" >return withoutSuffix?'':'';}</span>else <span class="cstat-no" title="statement not covered" >if(key==='h'){<span class="cstat-no" title="statement not covered" >return withoutSuffix?'':'';}</span>else{<span class="cstat-no" title="statement not covered" >return number+' '+plural$6(format[key],+number);}</span>}</span></span>function <span class="fstat-no" title="function not covered" >weekdaysCaseReplace(</span>m,format){var weekdays=<span class="cstat-no" title="statement not covered" >{nominative:'______'.split('_'),accusative:'______'.split('_'),genitive:'______'.split('_')},</span>nounCase;<span class="cstat-no" title="statement not covered" >if(m===true){<span class="cstat-no" title="statement not covered" >return weekdays['nominative'].slice(1,7).concat(weekdays['nominative'].slice(0,1));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!m){<span class="cstat-no" title="statement not covered" >return weekdays['nominative'];}<span class="cstat-no" title="statement not covered" ></span>n</span>ounCase=/(\[[]\]) ?dddd/.test(format)?'accusative':/\[?(?:|)? ?\] ?dddd/.test(format)?'genitive':'nominative';<span class="cstat-no" title="statement not covered" >r</span>eturn weekdays[nounCase][m.day()];}</span>function <span class="fstat-no" title="function not covered" >processHoursFunction(</span>str){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return str+''+(this.hours()===11?'':'')+'] LT';}</span>;}<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('uk',{months:{format:'___________'.split('_'),standalone:'___________'.split('_')},monthsShort:'___________'.split('_'),weekdays:weekdaysCaseReplace,weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD.MM.YYYY',LL:'D MMMM YYYY .',LLL:'D MMMM YYYY ., HH:mm',LLLL:'dddd, D MMMM YYYY ., HH:mm'},calendar:{sameDay:processHoursFunction('[ '),nextDay:processHoursFunction('[ '),lastDay:processHoursFunction('[ '),nextWeek:processHoursFunction('[] dddd ['),lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >switch(this.day()){case 0:case 3:case 5:case 6:<span class="cstat-no" title="statement not covered" >return processHoursFunction('[] dddd [').call(this);c</span>ase 1:case 2:case 4:<span class="cstat-no" title="statement not covered" >return processHoursFunction('[] dddd [').call(this);}</span>}</span>,sameElse:'L'},relativeTime:{future:' %s',past:'%s ',s:' ',ss:relativeTimeWithPlural$4,m:relativeTimeWithPlural$4,mm:relativeTimeWithPlural$4,h:'',hh:relativeTimeWithPlural$4,d:'',dd:relativeTimeWithPlural$4,M:'',MM:relativeTimeWithPlural$4,y:'',yy:relativeTimeWithPlural$4},// M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason</span>
meridiemParse:/|||/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return /^(|)$/.test(input);}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;4){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hour&lt;17){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span>,dayOfMonthOrdinalParse:/\d{1,2}-(|)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){case'M':case'd':case'DDD':case'w':case'W':<span class="cstat-no" title="statement not covered" >return number+'-';c</span>ase'D':<span class="cstat-no" title="statement not covered" >return number+'-';d</span>efault:<span class="cstat-no" title="statement not covered" >return number;}</span>}</span>,week:{dow:1,// Monday is the first day of the week.
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
var months$b=<span class="cstat-no" title="statement not covered" >['','','','','','','','','','','',''],</span>days$2=<span class="cstat-no" title="statement not covered" >['','','','','','',''];<span class="cstat-no" title="statement not covered" ></span>hooks.defineLocale('ur',{months:months$b,monthsShort:months$b,weekdays:days$2,weekdaysShort:days$2,weekdaysMin:days$2,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd D MMMM YYYY HH:mm'},meridiemParse:/|/,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return''===input;}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){<span class="cstat-no" title="statement not covered" >if(hour&lt;12){<span class="cstat-no" title="statement not covered" >return'';}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn'';}</span>,calendar:{sameDay:'[ ] LT',nextDay:'[ ] LT',nextWeek:'dddd [] LT',lastDay:'[  ] LT',lastWeek:'[] dddd [] LT',sameElse:'L'},relativeTime:{future:'%s ',past:'%s ',s:' ',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},preparse:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(//g,',');}</span>,postformat:<span class="fstat-no" title="function not covered" >fu</span>nction(string){<span class="cstat-no" title="statement not covered" >return string.replace(/,/g,'');}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('uz-latn',{months:'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),monthsShort:'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),weekdays:'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),weekdaysShort:'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),weekdaysMin:'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'D MMMM YYYY, dddd HH:mm'},calendar:{sameDay:'[Bugun soat] LT [da]',nextDay:'[Ertaga] LT [da]',nextWeek:'dddd [kuni soat] LT [da]',lastDay:'[Kecha soat] LT [da]',lastWeek:"[O'tgan] dddd [kuni soat] LT [da]",sameElse:'L'},relativeTime:{future:'Yaqin %s ichida',past:'Bir necha %s oldin',s:'soniya',ss:'%d soniya',m:'bir daqiqa',mm:'%d daqiqa',h:'bir soat',hh:'%d soat',d:'bir kun',dd:'%d kun',M:'bir oy',MM:'%d oy',y:'bir yil',yy:'%d yil'},week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 7th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('uz',{months:'___________'.split('_'),monthsShort:'___________'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'D MMMM YYYY, dddd HH:mm'},calendar:{sameDay:'[ ] LT []',nextDay:'[] LT []',nextWeek:'dddd [ ] LT []',lastDay:'[ ] LT []',lastWeek:'[] dddd [ ] LT []',sameElse:'L'},relativeTime:{future:' %s ',past:'  %s ',s:'',ss:'%d ',m:' ',mm:'%d ',h:' ',hh:'%d ',d:' ',dd:'%d ',M:' ',MM:'%d ',y:' ',yy:'%d '},week:{dow:1,// Monday is the first day of the week.</span>
doy:7// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('vi',{months:'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),monthsShort:'Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12'.split('_'),monthsParseExact:true,weekdays:'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),weekdaysShort:'CN_T2_T3_T4_T5_T6_T7'.split('_'),weekdaysMin:'CN_T2_T3_T4_T5_T6_T7'.split('_'),weekdaysParseExact:true,meridiemParse:/sa|ch/i,isPM:<span class="fstat-no" title="function not covered" >fu</span>nction(input){<span class="cstat-no" title="statement not covered" >return /^ch$/i.test(input);}</span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hours,minutes,isLower){<span class="cstat-no" title="statement not covered" >if(hours&lt;12){<span class="cstat-no" title="statement not covered" >return isLower?'sa':'SA';}</span>else{<span class="cstat-no" title="statement not covered" >return isLower?'ch':'CH';}</span>}</span>,longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'D MMMM [nm] YYYY',LLL:'D MMMM [nm] YYYY HH:mm',LLLL:'dddd, D MMMM [nm] YYYY HH:mm',l:'DD/M/YYYY',ll:'D MMM YYYY',lll:'D MMM YYYY HH:mm',llll:'ddd, D MMM YYYY HH:mm'},calendar:{sameDay:'[Hm nay lc] LT',nextDay:'[Ngy mai lc] LT',nextWeek:'dddd [tun ti lc] LT',lastDay:'[Hm qua lc] LT',lastWeek:'dddd [tun trc lc] LT',sameElse:'L'},relativeTime:{future:'%s ti',past:'%s trc',s:'vi giy',ss:'%d giy',m:'mt pht',mm:'%d pht',h:'mt gi',hh:'%d gi',d:'mt ngy',dd:'%d ngy',w:'mt tun',ww:'%d tun',M:'mt thng',MM:'%d thng',y:'mt nm',yy:'%d nm'},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){<span class="cstat-no" title="statement not covered" >return number;}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('x-pseudo',{months:'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),monthsShort:'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),monthsParseExact:true,weekdays:'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),weekdaysShort:'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),weekdaysMin:'S~_M~_T_~W_T~h_Fr~_S'.split('_'),weekdaysParseExact:true,longDateFormat:{LT:'HH:mm',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY HH:mm',LLLL:'dddd, D MMMM YYYY HH:mm'},calendar:{sameDay:'[T~d~ t] LT',nextDay:'[T~m~rr~w t] LT',nextWeek:'dddd [t] LT',lastDay:'[~st~rd~ t] LT',lastWeek:'[L~st] dddd [t] LT',sameElse:'L'},relativeTime:{future:'~ %s',past:'%s ~g',s:' ~fw ~sc~ds',ss:'%d s~c~ds',m:' ~m~t',mm:'%d m~~ts',h:'~ h~r',hh:'%d h~rs',d:' ~d',dd:'%d d~s',M:' ~m~th',MM:'%d m~t~hs',y:' ~r',yy:'%d ~rs'},dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number){var b=<span class="cstat-no" title="statement not covered" >number%10,</span>output=<span class="cstat-no" title="statement not covered" >~~(number%100/10)===1?'th':b===1?'st':b===2?'nd':b===3?'rd':'th';<span class="cstat-no" title="statement not covered" ></span>return number+output;}</span>,week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('yo',{months:'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),monthsShort:'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),weekdays:'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),weekdaysShort:'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),weekdaysMin:'Ai_Aj_Is_r_b_t_Ab'.split('_'),longDateFormat:{LT:'h:mm A',LTS:'h:mm:ss A',L:'DD/MM/YYYY',LL:'D MMMM YYYY',LLL:'D MMMM YYYY h:mm A',LLLL:'dddd, D MMMM YYYY h:mm A'},calendar:{sameDay:'[Oni ni] LT',nextDay:'[la ni] LT',nextWeek:"dddd [s ton'b] [ni] LT",lastDay:'[Ana ni] LT',lastWeek:'dddd [s tol] [ni] LT',sameElse:'L'},relativeTime:{future:'ni %s',past:'%s kja',s:'isju aaya die',ss:'aaya %d',m:'isju kan',mm:'isju %d',h:'wakati kan',hh:'wakati %d',d:'j kan',dd:'j %d',M:'osu kan',MM:'osu %d',y:'dun kan',yy:'dun %d'},dayOfMonthOrdinalParse:/j\s\d{1,2}/,ordinal:'j %d',week:{dow:1,// Monday is the first day of the week.</span>
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('zh-cn',{months:'___________'.split('_'),monthsShort:'1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'YYYY/MM/DD',LL:'YYYYMD',LLL:'YYYYMDAhmm',LLLL:'YYYYMDddddAhmm',l:'YYYY/M/D',ll:'YYYYMD',lll:'YYYYMD HH:mm',llll:'YYYYMDdddd HH:mm'},meridiemParse:/|||||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''||meridiem===''||meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''||meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>else{// ''</span></span></span>
<span class="cstat-no" title="statement not covered" >return hour&gt;=11?hour:hour+12;}</span>},meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){var hm=<span class="cstat-no" title="statement not covered" >hour*100+minute;<span class="cstat-no" title="statement not covered" ></span>if(hm&lt;600){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;900){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;1130){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;1230){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;1800){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span></span>,calendar:{sameDay:'[]LT',nextDay:'[]LT',nextWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(now){<span class="cstat-no" title="statement not covered" >if(now.week()!==this.week()){<span class="cstat-no" title="statement not covered" >return'[]dddLT';}</span>else{<span class="cstat-no" title="statement not covered" >return'[]dddLT';}</span>}</span>,lastDay:'[]LT',lastWeek:<span class="fstat-no" title="function not covered" >fu</span>nction(now){<span class="cstat-no" title="statement not covered" >if(this.week()!==now.week()){<span class="cstat-no" title="statement not covered" >return'[]dddLT';}</span>else{<span class="cstat-no" title="statement not covered" >return'[]dddLT';}</span>}</span>,sameElse:'L'},dayOfMonthOrdinalParse:/\d{1,2}(||)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){case'd':case'D':case'DDD':<span class="cstat-no" title="statement not covered" >return number+'';c</span>ase'M':<span class="cstat-no" title="statement not covered" >return number+'';c</span>ase'w':case'W':<span class="cstat-no" title="statement not covered" >return number+'';d</span>efault:<span class="cstat-no" title="statement not covered" >return number;}</span>}</span>,relativeTime:{future:'%s',past:'%s',s:'',ss:'%d ',m:'1 ',mm:'%d ',h:'1 ',hh:'%d ',d:'1 ',dd:'%d ',w:'1 ',ww:'%d ',M:'1 ',MM:'%d ',y:'1 ',yy:'%d '},week:{// GB/T 7408-1994ISO 8601:1988
dow:1,// Monday is the first day of the week.
doy:4// The week that contains Jan 4th is the first week of the year.
}});//! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('zh-hk',{months:'___________'.split('_'),monthsShort:'1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'YYYY/MM/DD',LL:'YYYYMD',LLL:'YYYYMD HH:mm',LLLL:'YYYYMDdddd HH:mm',l:'YYYY/M/D',ll:'YYYYMD',lll:'YYYYMD HH:mm',llll:'YYYYMDdddd HH:mm'},meridiemParse:/|||||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''||meridiem===''||meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&gt;=11?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''||meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){var hm=<span class="cstat-no" title="statement not covered" >hour*100+minute;<span class="cstat-no" title="statement not covered" ></span>if(hm&lt;600){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;900){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;1200){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm===1200){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;1800){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span></span>,calendar:{sameDay:'[]LT',nextDay:'[]LT',nextWeek:'[]ddddLT',lastDay:'[]LT',lastWeek:'[]ddddLT',sameElse:'L'},dayOfMonthOrdinalParse:/\d{1,2}(||)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){case'd':case'D':case'DDD':<span class="cstat-no" title="statement not covered" >return number+'';c</span>ase'M':<span class="cstat-no" title="statement not covered" >return number+'';c</span>ase'w':case'W':<span class="cstat-no" title="statement not covered" >return number+'';d</span>efault:<span class="cstat-no" title="statement not covered" >return number;}</span>}</span>,relativeTime:{future:'%s',past:'%s',s:'',ss:'%d ',m:'1 ',mm:'%d ',h:'1 ',hh:'%d ',d:'1 ',dd:'%d ',M:'1 ',MM:'%d ',y:'1 ',yy:'%d '}});/</span>/! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('zh-mo',{months:'___________'.split('_'),monthsShort:'1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'DD/MM/YYYY',LL:'YYYYMD',LLL:'YYYYMD HH:mm',LLLL:'YYYYMDdddd HH:mm',l:'D/M/YYYY',ll:'YYYYMD',lll:'YYYYMD HH:mm',llll:'YYYYMDdddd HH:mm'},meridiemParse:/|||||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''||meridiem===''||meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&gt;=11?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''||meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){var hm=<span class="cstat-no" title="statement not covered" >hour*100+minute;<span class="cstat-no" title="statement not covered" ></span>if(hm&lt;600){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;900){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;1130){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;1230){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;1800){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span></span>,calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'[]dddd LT',lastDay:'[] LT',lastWeek:'[]dddd LT',sameElse:'L'},dayOfMonthOrdinalParse:/\d{1,2}(||)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){case'd':case'D':case'DDD':<span class="cstat-no" title="statement not covered" >return number+'';c</span>ase'M':<span class="cstat-no" title="statement not covered" >return number+'';c</span>ase'w':case'W':<span class="cstat-no" title="statement not covered" >return number+'';d</span>efault:<span class="cstat-no" title="statement not covered" >return number;}</span>}</span>,relativeTime:{future:'%s',past:'%s',s:'',ss:'%d ',m:'1 ',mm:'%d ',h:'1 ',hh:'%d ',d:'1 ',dd:'%d ',M:'1 ',MM:'%d ',y:'1 ',yy:'%d '}});/</span>/! moment.js locale configuration
<span class="cstat-no" title="statement not covered" >hooks.defineLocale('zh-tw',{months:'___________'.split('_'),monthsShort:'1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),weekdays:'______'.split('_'),weekdaysShort:'______'.split('_'),weekdaysMin:'______'.split('_'),longDateFormat:{LT:'HH:mm',LTS:'HH:mm:ss',L:'YYYY/MM/DD',LL:'YYYYMD',LLL:'YYYYMD HH:mm',LLLL:'YYYYMDdddd HH:mm',l:'YYYY/M/D',ll:'YYYYMD',lll:'YYYYMD HH:mm',llll:'YYYYMDdddd HH:mm'},meridiemParse:/|||||/,meridiemHour:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,meridiem){<span class="cstat-no" title="statement not covered" >if(hour===12){<span class="cstat-no" title="statement not covered" >hour=0;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(meridiem===''||meridiem===''||meridiem===''){<span class="cstat-no" title="statement not covered" >return hour;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''){<span class="cstat-no" title="statement not covered" >return hour&gt;=11?hour:hour+12;}</span>else <span class="cstat-no" title="statement not covered" >if(meridiem===''||meridiem===''){<span class="cstat-no" title="statement not covered" >return hour+12;}</span>}</span></span></span>,meridiem:<span class="fstat-no" title="function not covered" >fu</span>nction(hour,minute,isLower){var hm=<span class="cstat-no" title="statement not covered" >hour*100+minute;<span class="cstat-no" title="statement not covered" ></span>if(hm&lt;600){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;900){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;1130){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;1230){<span class="cstat-no" title="statement not covered" >return'';}</span>else <span class="cstat-no" title="statement not covered" >if(hm&lt;1800){<span class="cstat-no" title="statement not covered" >return'';}</span>else{<span class="cstat-no" title="statement not covered" >return'';}</span>}</span></span></span></span></span>,calendar:{sameDay:'[] LT',nextDay:'[] LT',nextWeek:'[]dddd LT',lastDay:'[] LT',lastWeek:'[]dddd LT',sameElse:'L'},dayOfMonthOrdinalParse:/\d{1,2}(||)/,ordinal:<span class="fstat-no" title="function not covered" >fu</span>nction(number,period){<span class="cstat-no" title="statement not covered" >switch(period){case'd':case'D':case'DDD':<span class="cstat-no" title="statement not covered" >return number+'';c</span>ase'M':<span class="cstat-no" title="statement not covered" >return number+'';c</span>ase'w':case'W':<span class="cstat-no" title="statement not covered" >return number+'';d</span>efault:<span class="cstat-no" title="statement not covered" >return number;}</span>}</span>,relativeTime:{future:'%s',past:'%s',s:'',ss:'%d ',m:'1 ',mm:'%d ',h:'1 ',hh:'%d ',d:'1 ',dd:'%d ',M:'1 ',MM:'%d ',y:'1 ',yy:'%d '}});<span class="cstat-no" title="statement not covered" >h</span>ooks.locale('en');<span class="cstat-no" title="statement not covered" >r</span>eturn hooks;}</span>);</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2024-12-08T12:42:30.967Z
            </div>
        <script src="../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../sorter.js"></script>
        <script src="../../../block-navigation.js"></script>
    </body>
</html>
    